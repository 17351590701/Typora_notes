# 实训

------





## 开发工具

1. **jdk21.0.1**
2. **IDEA**(JAVA)
3. **VSCode(大前端)**
4. **HBuilderX(网页设计)**
5. **Mysql**/Naivat
6. **Maven**

## 开发岗位

- 方向：全栈、java后端方向、大前端方向（web前端）
- 岗位分类：java开发工程师（后端）、大前端开发工程师（web前端）
- 岗位方向：实习岗、java实训工程师、java工程师、高级工程师、项目经理、技术总监、总裁、自主创业（boss）

## 岗位技术栈

### java技术栈

1. IDEA、Linux（CentOS、Ubuntu）、云服务
2. Linux终端：Xshell、宝塔、SecureCRT
3. JavaSE（核心基础）
4. JDBC（数据源/连接池）、Servlet、JavaWeb
5. 数据库：Mysql、Oracle
6. NoSQL：**Redis**、MongoDB、Memcached、**Zookeeper**
7. **框架：Spring、SpringMVC、SpringBoot、SPringCloud、SpringCloudAlibaba**
8. **持久层框架：MyBatis、MyBatis-Plus（MP）、Spring Data JPA**
9. **安全（权限）框架：Spring Security、Shiro、OAuth2.0**
10. **项目管理：Maven、gradle、NPM**
11. **版本控制：Git、Github、Gitee**
12. **消息队列：Kafka、RabbitMQ、RocketMQ**
13. **Driud、SpringBootAdmin、SkyWalking**
14. **开发架构：单体架构、垂直架构、分布式架构、SOA（面向服务的架构）、微服务架构**
15. **辅助工具：Xmind、draw.io、亿图（EdraMax）、ProcessOn**
16. **运维部署：Docker、K8s**
17. **性能优化：SQL优化、JVM优化、Jmeter**
18. **服务器：Tomcat、云服务、Nginx、Apache**

### 前端技术栈

1. 基础：HTML/H5、CSS3、JavaScript、JQuery（Ajax）
2. Es6（原型、原型链、作用域、闭包、异步、this、函数（箭头）、js新特性、TS（TypeScript））
3. js框架：**Vue2/Vue3、React.js、Augular**、svelte
4. 异步请求：jQuery（Ajax）、Axios、fetch
5. 跨域：跨域问题、同源问题、JSONP、CORS、Xss
6. H5、App、微信小程序、UniApp
7. 大前端的后端技术栈：Node.js、Express、Koa、Egg.js、NPM
8. 数据库：Mysql、MongoDB
9. 版本控制：Git/Gitee、SVN
10. 自动化构建工具：脚手架（Vue-cli)、webpack
11. UI组件：ElementUI、BootStrap、**Layui**
12. **服务器渲染框架：Next.js(React.js)、Nuxt.js(Vue.js)**

## 项目实训技术架构

1. IDEA
2. JDK8以上
3. Mysql8.0.35
4. Tomcat10
5. Maven
6. Servlet/jsp、EL表达式、JSTL标签
7. JDBC、DbUtils、数据源（Druid）
8. UI模版、jQuery、LayUI
9. HuTool

## Mysql数据库

### 1、概念

数据库是“按照数据结构来组织、存储、管理数据的仓库”，是一个可以持久化长期储存在计算机内的、有组织的、有共享的、可以统一管理的数据集合    

### 2、数据库分类

- 网状结构数据库
- 层次结构数据库
- **关系数据库**（Oracle、Mysql、DB2、SQL Server）、以表格形式存储
- **非关系型数据库**：MongoDB、Redis、使用哈希表、表中以键值（Key-Value）的方式实现特定的键和指针指向的特定数据

### 3、数据库管理系统

数据库管理系统（DBMS）：管理和操作数据库的系统、用于建立、使用、维护数据库、对数据库进行统一的管理和控制，保证数据库的安全性和完整性

常用的数据库系统：

- Oracle
- DB2
- SQL Server
- SQL Lite
- Mysql

### 4、SQL语句

SQL：是结构化查询语言、用于储存数据、更新、查询和管理关系数据系统的程序设计语言。

通常用于对数据库数据进行 CRUD【增(Create)、删(Delete)、改(update)、查(Retrieve)】操作。

对于数据库的操作，在Mysql的环境下进行指令操作，都是使用“；”结束。

1. 登录数据库

   ```sql
   mysql -u root -p   #回车键
   Enter password:    #输入密码
   #登录mysql DBMS
   ```

2. 查看Mysql中所有的数据库

   ```sql
   show databases;
   ```

3. 创建数据库

   ```sql
   #create database (数据库名)
   create database shixun;  #创建名称为shixun的数据库
   #创建数据库的时候指定字符集
   create database shixun character set utf-8;
   ```

4. 删除数据库

   ```sql
   #drop database (数据库名)
   drop database shixun;
   ```

5. 展示创建数据库信息

   ```sql
   show create database (数据库名）;
   ```

6. 修改数据库信息

   ```sql
   #修改数据库的字符集为gbk
   alter database （数据库名）character set gbk;
   ```

7. 使用数据库

   ```sql
   #当前环境下选中数据库
   use (数据库名);
   ```

8. 查看当前使用的数据库

   ```sql
   select database();
   ```

9. 退出DBMS

   ```sql
   exit
   ```

### 5、数据库表

任何一张表都是由行和列组成：

- 行（row）：称为一行记录/一条数据
- 列（column）：表字段

数据库表每个字段都有：字段名、数据类型、约束等属性

- 字段名：就是一个普通的名字，定义要做到见名知意，不要使用中文和关键字。
- 数据类型：字符（char）、字符串（varchar）、数字类型（int、double、float）、日期等
- 约束：数据库约束有很多，常用的约束有：主键约束，唯一约束，非空约束

对表的操作就是对表的定义（DDL）：create、drop、alter等

#### 5.1、数据库表操作

- 创建表

  语法格式：

  ```sql
  create table 表名(
  字段名1 数据类型,
  字段名2 数据类型,
  字段名3 数据类型,
  约束条件
  );
  ```

  **说明**：如果数据库表名由多个单词组成，建议“_”连接，Eg：cz_emp

  表名禁止使用数字或关键字或特殊符号命名

  数据库在windows系统下不区分大小写，但在Linux系统下是严格区分大小写的，所有在数据库名、表名、字段名都做到统一，避免节外生枝

  需求：

  创建一个学生表，学号、姓名、性别、年龄、电话、出生日期、地址

  ```sql
  #创建数据库
  create database shixun;
  #选中数据库
  use shixun;
  #创建学生表
  create table student(
  id int(10) primary key not null auto_increment,#非空约束，主键自增
  username varchar(20) not null,
  sex char(2),
  age int(10),
  phone varchar(11),
  address varchar(40)
  );
  #查看表结构
  desc student(表名);
  ```

  **注意**：

  - 在同一张表中，字段名不能相同
  - 数据类型长度和约束条件为可选参数，字段名和字段类型是必须的

#### 5.2、更新表

向student表中添加列（字段）

语法：

```sql
#alter table table_name(表名) add column 列名
#添加班级字段 classes
alter table student add column classes varchar(20);
#查看表结构
desc student;
```

#### 5.3、删除列

语法：

```sql
alter table table_name(表名) drop column 列名
#删除年龄字段
alter table student drop column age;
```

**注意**：

在实际开发过程中，需求一旦确定，表一旦设计好之后，是很少会对表结构进行修改操作的，因为修改的成本很高，表结构改了，对应的业务逻辑的java代码也要进行大量的修改。

#### 5.4、字段的约束

在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的合法性、有效性、完整性。

- **非空约束**（not null）：约束的字段不能为空
- **唯一约束**（unique）：约束的字段值不能重复
- **主键约束**（primary key）：约束的字段既不能为空，也不能重复（PK）
- **外键约束**（foreign key）：外键字段的约束（FK）

### 6、DML操作

所谓的DML操作就是对表记录进行读写（CRUD）的操作

#### 6.1、添加语句

语法：

```sql
#insert into 表名 (字段1，字段2，字段3...) values(值1，值2，值3...);

#字段和值要一一对应，数据类型也要对应相同
insert into student (username,sex,phone,address,classes) values ("张雨润","男","17351590701","江苏理工学院","21软件2");

#添加操作时，还可以不写表字段，但values值的个数一定要与表字段个数一一对应
#报错
insert into student values ("张三","男","17351590701","江苏理工学院","21软件2");
#不报错
insert into student values (0,"张三","男","17351590701","江苏理工学院","21软件2");
```

![image-20231226084244083](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061733680.png)

#### 6.2、更新语句

```sql
#update 表名 set 字段1=值1,字段2=值2... where 条件;
update student set classes="21软件1" where id=2;
```

#### 6.3、删除语句

```sql
#删除所有记录（清空）
delete from 表名;

#根据条件删除
delete from 表名 where 条件;

delete from student where id=1;
```

#### 6.4、查询语句

```sql
#查询所有
select * from 表名;

#查询单个字段的值
select 字段名1 from 表名;

#查询多个字段的值
select 字段1,字段2...  from 表名;
```

**备注：**

- 任何一条SQL语句都是以”;“结束
- SQL语句不区分大小写

在SQL语句中使用as关键字可以使用别名，当然在语句中as关键字可以默认省略。

```sql
select username as "姓名" from student;
#或者省略as关键字
select username "姓名" from student;

#也不会报错
select username 姓名 from student;
```

**备注：**
在SQL语句中别名不使用引号也不会报错，但按照语法规则来说，还是给定的别名使用双引号

#### 6,5、排序查询

```sql
select 别名 from 表名 order by 排序列 [排序规则]
```

排序规则：

1. asc：升序排序   (order by 默认)
2. desc：降序排序

```sql
#当进行升序排序时，排序规则可以不显示声明，默认为升序排序规则
select * from student order by id (asc);  #升序
select * from student order by id desc;   #降序
```

#### 6.6、条件查询

```sql
#where 条件：在查询结果中筛选符合条件的记录
select * from 表名 where 条件
```

1. 等值判断(=)

   ```sql
   select * from student where username="张三";
   ```

   

2. 不等值判断（>、<、=、 !=、<>）

   ```sql
   select * from student where classes !="21软件1";(<>同理，也是不等于)
   ```

3. 逻辑判断（and、or、not）

   ```sql
   #查询工资[5000,10000]的员工信息
   select * from emp where salary>=5000 and salary<=10000;
   #查询工资是5000或10000的员工信息
   select * from emp where salary=5000 or salary=10000;
   #查询除了工资是10000的员工信息
   select * from emp where not salary=10000;
   ```

4. 区间判断（between and）

   ```sql
   #区间判断：包含区间边界的两个值[5000,10000]
   select * from emp where salary between 5000 and 10000;
   ```

   **注意**:

   between and 要遵循between 小值 and 大值

5. 枚举查询（in(值1，值2，值3)）

   ```sql
   #查询工资为5000,6000,7000的员工
   select * from emp where salary in (5000,6000,7000);
   ```

6. 模糊查询（ _ ,%）

   ```sql
   #like _（单个任意字符）
   #like %（任意长度的任意字符）
   select * from student where username like '__疯%';
   ```

7. limit分页
   在进行数据库表查询操作中，一般都知道使用select语句进行查询，但是当数据量较大时，select查询就不是很方便，这时分页查询就派上了用场。
   在Mysql中使用**limit关键字进行分页。limit实现分页的方式是取数据库表的中的部分数据。**

   ```sql
   #pageNum 页码 pageSize每页显示记录
   select * from 表名 limit pageNum,pageSize;
   ```

   **注意：pageNum页码从0开始**

   ```sql
   select * from student limit 0,3;#第一页(1-1)*3=0
   select * from student limit 3,3;#第二页(2-1)*3=3
   ```

   分页通用公式：

   ```sql
   #pageNum:当前页，pageSize：每页显示的记录数
   select * from 表名 limit (pageNum-1)*pageSize,pageSize;
   ```

8. count（）函数
   作用：获取数据库表的总记录

   ```sql
   
   select count(*) from 表名;
   #根据字段查询总记录数
   select count(username) from 表名;
   ```

## Maven

Maven是一个（特别是Java编程）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片段能管理一个项目的构建、报告和文档等步骤。

下载地址：http://maven.apache.org/download.cgi

解压路径：D:\apache-maven-3.9.4-bin\apache-maven-3.9.4

配置环境变量：在系统变量Path中，新建D:\apache-maven-3.9.4-bin\apache-maven-3.9.4\bin

测试：mvn -v

### 配置Maven镜像

1. 设置镜像资源存储路径

   ```xml
   <localRepository>
   	D:\apache-maven-3.9.4-bin\maven_repository
   </localRepository>
   ```

2. 配置阿里云镜像
   在setting.xml的<mirrors></mirrors>标签内加入

```xml
<mirror>
  <id>alimaven</id>
  <mirrorOf>central</mirrorOf>
  <name>aliyun maven</name>
  <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
</mirror>
```



## JDBC数据库连接操作

JDBC(java数据库连接)是一种用于执行SQL语句的Java API，可以为多种关系型数据库做统一的操作，其由一组Java语言编写的类和接口组成。

![image-20231226141443181](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061733681.png)

JDBC本质：java官方提供一套规范(接口)，用于帮助开发人员快速实现不同关系型数据库的连接

JDBC是由多个接口和类进行功能实现

| 类型  |     名称      |                描述                 |
| :---: | :-----------: | :---------------------------------: |
| class | DriverManager |    管理多个数据库驱动类，提供了     |
| 接口  |  Connection   |           表示数据库连接            |
| 接口  |   Statement   |      发送SQL语句到数据库的工具      |
| 接口  |   ResultSet   | 保存SQL查询语句的结果数据（结果集） |
| class | SQLException  |  处理数据库应用程序时所发生的异常   |

### 1、Connection对象

```java
 try{
      Class.forName("com.mysql.cj.jdbc.Driver");
      Connection conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/数据库?","root","123456qq");
      if(conn!=null){
         System.out.println("连接成功");
        }else{
         System.out.println("连接失败");
        }
      } catch (SQLException | ClassNotFoundException e) {
            throw new RuntimeException(e);
   }
```



### 2、PreparedStatement对象

通过Connection对象获得PreparedStatement对象，用于对数据库进行通用访问

```java
PreparedStatement pre = conn.prepareStatement(sql);//传递sql
```

prepareStatement()方法传入SQL语句可以预防SQL注入。

优点：防止SQL注入，提高代码可读性，运行效率。

prepareStatement接口提供了两个方法进行数据库表的操作：

- executeQuery():主要用于执行查询操作，此方法返回ResultSet对象
- executeUpdate():主要用于执行（添加，修改，删除）的操作，执行成功之后返回int类型的结果值，这个值是受影响的行。

### 3、ResultSet对象

在执行查询SQL语句后，存放查询到的结果集

```java
ResultSet rs = statement.executeQuery();
```

遍历ResultSet中的数据

ResultSet以表结构进行临时结果的存储，需要通过JDBC API将其中的数据进行依次获取

- 数据行指针（resultSet.next()）：初始位置在第一行数据前，每调用一次boolean返回值类型的next()方法，指针向下移动一行，结果为true，表示当前行有数据

- resultSet.getXXX("列名"):根据列名获取数据

  ```sql
      public static void executeQuerySelectTest() {
          try {
              /*加载驱动*/
              Class.forName("com.mysql.cj.jdbc.Driver");
              /*获取连接对象*/
              Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/shixun?", "root", "123456qq");
              /*获取Statement*/
              Statement statement = connection.createStatement();
              /*执行SQL语句*/
              String sql = "select * from student";
              ResultSet rs = statement.executeQuery(sql);
              /*处理结果集*/
              while (rs.next()) {
                  int id = rs.getInt("id");
                  String username = rs.getString("username");
                  String sex = rs.getString("sex");
                  String phone = rs.getString("phone");
                  String address = rs.getString("address");
                  String classes = rs.getString("classes");
                  System.out.println(id + "\t" + username + "\t" + sex + "\t" + phone + "\t" + address + "\t" + classes);
              }
              rs.close();
              statement.close();
              connection.close();
          } catch (ClassNotFoundException | SQLException e) {
              e.printStackTrace();
          }
      }
  ```

  

### 4、小结

JDBC实现Mysql数据库连接的步骤：

- 导入数据库驱动（数据库依赖）
- 注册驱动
- 获取数据库连接对象（Connection）
- 获取执行对象（PreparedStatement）
- 执行SQL语句并返回结果
- 处理结果
- 释放资源

**综合案例**

1. 修改id=2的用户信息（修改电话、地址信息）

2. 根据用户名来查询某条记录（李四）

3. 添加一条记录

4. 模糊查询（查询名字带“疯”的用户)

5. 根据电话查询某个用户信息

## 数据库连接池

常用的数据库连接池：DBCP、C3P0、**Druid、HikariCP（SpringBoot）**

Druid连接池：阿里开源的数据库连接池，功能强大，是Java语言最好的数据库连接池之一，同时加入了日志监控，可以很好的监控数据库连接池的连接和SQL语句执行的情况。

使用步骤：

1. 导入Druid依赖(连接池依赖)

   ```xml
    <dependency>
         <groupId>com.alibaba</groupId>
         <artifactId>druid</artifactId>
         <version>1.2.20</version>
    </dependency>
   ```

2. 在Resource文件夹内定义连接数据库的配置文件druid.properties

```properties
driveClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/shixun
username=root
password=123456qq
```

- 加载配置文件
- 获取连接池
- 获取连接

单元测试

```java
public class DruidTest {
    @Test
    public void jdbcTryTest() {
//        获取配置文件流对象
        InputStream inputStream = DruidTest.class.getClassLoader().getResourceAsStream("druid.properties");
//    创建Properties对象加载配置文件
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
//            获取连接池对象
            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
//            获取连接对象
            Connection conn =dataSource.getConnection();
            System.out.println(conn);
            if(conn!=null){
                System.out.println("连接成功");
            }else{
                System.out.println("连接失败");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### DBUtils工具类

如果只使用JDBC进行开发，通过其学习和实验发现进行相关CRUD操作时，存在大量冗余代码，为了简化JDBC的使用开发，可以采用Apache common组件：DBUtils工具类来实现。

DBUtils对JDBC的操作进行优化和封装，其提供了是三个核心功能：

- **QueryRunner**：提供了对SQL语句操作的API
- **ResultSetHandler**：用于定义select操作后结果集的处理
- DBUtils类：关闭资源和事务处理的方法

加载DBUtils工具类的依赖



```xml
    <!--DBUtils依赖-->
    <dependency>
      <groupId>commons-dbutils</groupId>
      <artifactId>commons-dbutils</artifactId>
      <version>1.7</version>
    </dependency>
```

#### 1、Update()方法

```java
   public int update(String sql, Object... params) throws SQLException {
        Connection conn = this.prepareConnection();
        return this.update(conn, true, sql, params);
    }
```

备注：

- update()方法用于执行DML（增、删、改）操作

- Object...params：动态参数（动态数组）
  测试案例

  ```java
      @Test
      public void queryRunnerUpdate() {
          QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource());
          String sql = "update student set address=? where username=?";
          Object[] obj = {"成都", "赵云"};
          try {
              int result = queryRunner.update(sql, obj);
              if (result > 0) {
                  System.out.println("修改成功");
              } else {
                  System.out.println("修改失败");
              }
              /*将修改后的值输出到控制台*/
  
          } catch (SQLException e) {
              throw new RuntimeException(e);
          }
      }
  ```

  QueryRunner类基于update()的通用性操作封装的方法

  ```java
  public class Basedao {
      private static QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource());
  
      /**
       * @param sql
       * @param obj
       * @return 增删改的方法集
       */
      public static int update(String sql,Object[] obj){
          try {
              return queryRunner.update(sql,obj);
          } catch (SQLException e) {
              throw new RuntimeException(e);
          }
      }
  }
  ```

  

#### 2、query()方法

```java
  public <T> T query(String sql, ResultSetHandler<T> rsh) throws SQLException {
        Connection conn = this.prepareConnection();
        return this.query(conn, true, sql, rsh, (Object[])null);
    }
```

通过对底层源代码的分析，query()方法的结果是<T>,其通过ResultSetHandler<T>接口的实现对结果进行预处理。

开发过程中常用实现方法有：

1. ArrayListHandler：将结果集中的每一条记录封装到一个Object[]数组中，再将这些数组再次封装到List结合中
2. **BeanListHandler**：将结果集中的每一天记录封装到一个指定的JavaBean中，再将JavaBean封装到一个List集合
3. ScalarHandler：用于单数据，可以用于获取总记录数

**单元测试**

```java
@Test
public void queryArrayListHandler(){
  QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource());
  String sql = "select * from student";
  try {
    //将结果集封装到Object数组中
    List<Object[]> list = queryRunner.query(sql, new ArrayListHandler());
    for(Object[] obj: list){
      System.out.println(Arrays.toString(obj));
    }
    /*将修改后的值输出到控制台*/
  } catch (SQLException e) {
    throw new RuntimeException(e);
  }
}

@Test
public void queryBeanListHandler(){
  QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource());
  String sql = "select * from student";
  try {
    List<Student> list = queryRunner.query(sql, new BeanListHandler<>(Student.class));
    for(Student stu: list){
      //需要再javaBean中加入toString方法
      System.out.println(stu.toString());
    }
    /*将修改后的值输出到控制台*/
  } catch (SQLException e) {
    throw new RuntimeException(e);
  }
}

@Test
public void queryScalarHandler(){
  QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource());
  String sql = "select count(*) from student";
  try{
    long count = queryRunner.query(sql,new ScalarHandler<Long>());
    System.out.println("总记录数："+count);
  }
  catch (SQLException e){
    throw new RuntimeException(e);
  }
}
```

总结：

使用Druid和DbUtils简化JDBC的操作，封装了通用性的实现类，但在实际开发过程中，涉及到的业务和模块非常复杂，为了更好的进行业务的开发和后期的维护和迭代，其需要进一步统一化的操作和分层组织



企业开发过程中的一些行为规范：

- 项目名称：全部字母，全部小写，不要使用中文、数字、特殊符号等来命名。
- 包名：com.项目名称（公司名称）.具体名称   Eg：com.ch.bean
- 类名：类名首字母大写，采用大驼峰命名法规则  Eg：StudentDao
- 方法名：首字母小写，采用小驼峰命名规则  Eg：findById()
- 变量名：采用小驼峰命名规则，不要包含特殊符号、数字、中文等
- 常量：每个单词字母都是大写

## 分层架构

在软件体系架构设计中，分层式架构是最常见，也是最重要的一种架构，架构一般分为三层，从下至上分别为：

- 数据访问层：为业务逻辑层和表示层提供数据
- 业务逻辑层：主要针对具体的问题的操作，也可以理解为对数据层的操作
- 表示层：展示数据的

![image-20231228093058131](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061733682.png)

在实际项目中的分层结构如下：

- com.ch.dao：Dao包（接口包）/接口实现
- com.ch.utils：工具类
- com.ch.bean：实体包
- com.ch.servlet：业务包

封装通用的Dao接口

```java
/**
*
* @param type
* @param sql
* @param obj
* @return 返回单个对象
* @param <T>
*/
public <T>T query(Class<T> type,String sql,Object... obj){
  try {
    return  queryRunner.query(sql,new BeanHandler<>(type),obj);
  } catch (SQLException e) {
    throw new RuntimeException(e);
  }
}

/**
*
* @param type
* @param sql
* @param obj
* @return 列表
* @param <T>
*/
public <T> List<T> queryAll(Class<T> type, String sql, Object... obj){
  try {
    return queryRunner.query(sql,new BeanListHandler<>(type),obj);
  } catch (SQLException e) {
    throw new RuntimeException(e);
  }
}

/**
*
* @param sql
* @param obj
* @return 返回行记录
*/
public int selectCount(String sql,Object... obj){
  try {
    return queryRunner.query(sql,new ScalarHandler<>(),obj);
  } catch (SQLException e) {
    throw new RuntimeException(e);
  }
}
```

## 案例项目

案例引用：网上商城

### 1、商城类型：

- B2B：商家对商家 Eg：阿里巴巴、慧聪网
- B2C：商家对客户 Eg：当当网、京东
- C2C：客户对客户 Eg：淘宝、拼多多
- O2O：线上线下相结合 Eg：美团、滴滴

### 2、常见模块

- 商品管理：后台商品库存管理、上货、出货、编辑管理和商品分类管理等
- 订单管理
- 支付管理
- 物流管理
- 会员管理
- 广告模块

### 3、项目功能介绍

本系统主要分为前台和后台管理两个大模块

其中前台管理主要的模块有：商品列表、商品分类查看、我的购物车、个人信息、广告位

![image-20231228105346948](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061733684.png)

![image-20231228111524052](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061733685.png)

管理员：管理商品、管理用户、个人信息、广告位、数据中台

用户用例图

![image-20231228112553505](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061733686.png)

前置条件：用户注册成功

后置条件：用户登录成功

重点：查看商品信息，把商品加入购物车，对商品进行结算和支付

主要事件流程：

1. 加入登录界面
2. 登录成功、用例开始
3. 登录成功跳转到首页
4. 分类列表查看商品信息
5. 点击“商品图片”查看商品详细信息
6. 点击“加入购物车”把商品加入购物车
7. 点击“我的购物车”查看购物车的商品信息
8. 点击“结算”即可结算商品
9. 点击“我的订单”可以查看结算商品的信息
10. 点击“支付”即可对商品进行支付
11. 点击删除购物车中的商品
12. 点击“个人信息”查看或修改

### 4、数据库设计

- 用户表（tb_user)

  | 字段  | 类型        | 主键 | 约束     | 备注                            |
  | -------- | ----------- | ---- | :------- | ------------------------------- |
  | id    | int         | 是   | 自增     | 序号                            |
  | username | varchar(20) |      | not null | 用户昵称                        |
  | password | varchar(60) |      | not null | 用户密码                        |
  | email    | varchar(60) |      | not null | 邮箱                            |
  | gender   | varchar(2)  |      |          | 性别                            |
  | flag     | int         |      | 默认值   | 状态标记：0未激活，1激活，2无效 |
  | role | int | |  | 角色：0管理员，1会员 |
  | code | int |      |          | 激活码 |
  | picture | varchar(50) | | | 图像 |
  | createtime | varchar(50) | | | 注册时间 |

  

- 商品表（tb_goods)

 | 字段       | 类型        | 主键 | 约束     | 备注               |
  | ---------- | ----------- | ---- | -------- | ------------------ |
  | id         | int         | 是   | 自增     | 主键               |
  | name       | varchar(50) |      | not null | 商品名称           |
  | pubdate    | varchar(20) |      | not null | 时间               |
  | picture    | varchar(50) |      | not null | 图片               |
  | price      | double(7.2) |      | not null | 商品价格           |
  | star       | double(2.1) |      | not null | 评分               |
  | info       | varchar(60) |      |          | 商品信息           |
  | typeid     | int         | 是   | 外键     | 商品类型           |
  | gunm       | int         |      | 默认1024 | 商品数量[库存]     |
  | gstate     | int         |      | 默认0    | 商品状态0上架1下架 |
  | createtime | varchar(50) |      | not null | 入库时间           |

  

- 商品类型表（tb_goods_type)

  | 字段   | 类型        | 主键 | 约束     | 备注              |
  | ------ | ----------- | ---- | -------- | ----------------- |
  | id     | int         | 是   | 自增     | 主键              |
  | name   | varchar(20) |      | not null | 类型名称          |
  | nioc   | varchar(20) |      | not null | 图标              |
  | level  | int         |      | not null | 类型信息          |
  | praent | int         |      | not null | 上一级序号：默认0 |

  

- 购物车表（tb_cart)

| 字段   | 类型        | 主键 | 约束     | 备注     |
  | ------ | ----------- | ---- | -------- | -------- |
  | id     | int         | 是   | 自增     | 主键     |
  | pid    | int         |      | 外键     | 商品序号 |
  | num    | int         |      | not null | 数量     |
  | monery | double(8.2) |      | not null | 金额     |

- 订单表（tb_order)



 | 字段      | 类型        | 主键 | 约束     | 备注         |
  | --------- | ----------- | ---- | -------- | ------------ |
  | id        | varchar(80) | 是   | 自增     | 订单编号uid  |
  | uid       | int         |      | 外键     | 用户序号     |
  | money     | double(8.2) |      | not null | 订单总金额   |
  | ordertime | datatime    |      | not null | 订单时间     |
  | status    | int         |      |          | 订单状态     |
  | aid       | int         |      | 外键     | 收货地址序号 |

- 订单详情表（tb_orderdetail)

 | 字段  | 类型        | 主键 | 约束     | 备注     |
  | ----- | ----------- | ---- | -------- | -------- |
  | id    | int         | 是   | 自增     | 主键     |
  | pid   | int         | 是   | 外键     | 订单id   |
  | pid   | int         |      | 外键     | 商品id   |
  | num   | int         |      | not null | 购买数量 |
  | money | double(8.2) |      | not null | 金额     |

- 地址表（tb_address)

| 字段       | 类型        | 主键 | 约束     | 备注            |
| ---------- | ----------- | ---- | -------- | --------------- |
| id         | int         | 是   | 自增     | 主键            |
| detail     | varchar(80) | 是   | 外键     | 详细地址        |
| name       | varchar(20) |      | 外键     | 收件人姓名      |
| phone      | varchar(20) |      | not null | 手机            |
| level      | int         |      | not null | 地址顺序1是最高 |
| createtime | varchar(20) |      |          | 创建时间        |



## Hutool工具集

Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”

官网API：[Hutool](https://doc.hutool)

### 验证码测试

```java
// URL: http://localhost:8080/zyr/ServletCaptcha
@WebServlet(name="ServletCaptcha",value= "/ServletCaptcha")
public class ServletCaptcha extends HttpServlet {
  @Override
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    System.out.println("====>进入验证码");
    // 定义图形验证码的长、宽验证码字数、干扰元素个数
    CircleCaptcha captcha = CaptchaUtil.createCircleCaptcha(200, 100, 4, 20);
    ServletOutputStream out = response.getOutputStream();
    // 写出到浏览器
    captcha.write(out);
    // 获取生成的验证码字符串
    String code = captcha.getCode();
    System.out.println("====>验证码"+code);
    // 验证图形验证码的有效性，返回boolean值1
    System.out.println(captcha.verify(code));
    out.close();
  }
}
```



