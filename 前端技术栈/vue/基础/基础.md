# 路由传参

## Query传参

- **定义**：Query 参数是通过 URL 的查询字符串（即 URL 后面的 `?` 符号后面的部分）来传递参数。
- **示例**：`http://example.com/user?name=John`
- 优点：
  - 参数显示在 URL 中，方便调试和分享链接。
  - 刷新页面或返回历史记录时参数仍然存在。
  - 可以在任何路由配置中使用，无论是基于 `path` 还是 `name`。
- 缺点：
  - 参数暴露在 URL 中，可能不适合敏感数据。
  - URL 长度有限制，过多参数可能导致 URL 过长


`Father.vue`

```vue
<template>
    <h2>Father</h2>
<!--路由超链接跳转，传递参数-->
    <router-link :to="{path:'/father/son',query:{id:1}}">toson</router-link>
    <router-view></router-view>
<!--方法跳转，传递参数-->
    <button @click="toSon(a)">跳转son</button>
</template>

<script setup>
import { ref } from 'vue'
const a = ref('123')
import { useRouter } from 'vue-router'
const router = useRouter()
const toSon = (a) => {
    router.push(
        {
            path: '/father/son',
            query: { id: 1, a }
        }
    )
}
</script>

<style scoped></style>
```

`Son.vue`

```vue
<template>
    <p>这是Son</p>
    <p>Son:{{ id }}+{{ a }}</p>
</template>

<script setup>
import { ref } from 'vue'
//子组件接受参数
import { useRoute } from 'vue-router';
const route = useRoute();
const id = ref(route.query.id)
const a = ref(route.query.a)
</script>

<style scoped></style>
```

## Params传参

- **定义**：Params 参数是通过动态路由段来传递参数，通常是在路由配置中定义动态段如 `/user/:id`。
- **示例**：`http://example.com/user/123`
- 优点：
  - 参数不显示在 URL 查询字符串中，更美观且适合传递 ID 类型的数据。
  - 更适合用于 RESTful API 风格的 URL 设计。
  - 刷新页面时，如果使用的是命名路由，可以通过 `beforeRouteUpdate` 或者 `watch` 监听 `$route.params` 来获取更新。
- 缺点：
  - 刷新页面或从书签访问时，如果没有服务器端的支持，可能会导致 404 错误，因为服务器需要能够识别这些动态路由。
  - 不能在没有命名路由的情况下使用，必须配合 `name` 属性使用。





# Slot插槽

## 默认插槽


`FS.vue`

```vue
<template>
  <div class="FS">
    <FC1><p>123</p></FC1>
    <FC1><p>456</p></FC1>
    <FC1><p>789</p></FC1>
  </div>
</template>

<script setup>
  import FC1 from "@/components/Slot/FC1.vue";
</script>

<style scoped>
  .FS{
    background-color: #2c3e50;
    width: 500px;
    height: 400px;
    display: flex;
    align-items: center;
    justify-content: space-around;

  }
</style>
```

`FC1.vue`

```vue
<template>
  <div class="Fc1">
     <!--  <slot name="default"></slot>
    默认内容，在具体内容未完成加载时显示
    -->
    <slot><p>默认内容</p></slot>
  </div>

</template>

<script setup>

</script>

<style scoped>
.Fc1{
  background-color: aquamarine;
  width: 100px;
  height: 100px;
}
</style>
```

![img](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407201312021.png)

## 具名插槽

`FS.vue`

```vue
<template>
  <div class="FS">
    <FC1>
      <template v-slot:S1>
        <p>123</p>
      </template>
      <template v-slot:S2>
        <p>456</p>
      </template>
      <template v-slot:S3>
        <p>789</p>
      </template>
    </FC1>
    <FC1>
    </FC1>
    <FC1>
    </FC1>
  </div>
</template>

<script setup>

import FC1 from "@/components/Slot/FC1.vue";
</script>

<style scoped>
.FS {
  background-color: #2c3e50;
  width: 500px;
  height: 400px;
  display: flex;
  align-items: center;
  justify-content: space-around;

}
</style>
```

`FC1.vue`

```vue
<template>
  <div class="Fc1">
  <!--  <slot name="default"></slot>-->
    <slot name="S2"><p>默认内容</p></slot>
    <slot name="S1"><p>默认内容</p></slot>
    <slot name="S3"><p>默认内容</p></slot>
  </div>

</template>

<script setup>

</script>

<style scoped>
.Fc1{
  background-color: aquamarine;
  width: 100px;
  height: auto;
}
</style>
```

![img](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407201312223.png)

## 作用域插槽

通过插槽，**将子组件中的数据传递给父组件**，让父组件选择插入

`FS.vue`

```vue
<template>
<div class="FS">
   <h3>父组件</h3>
   <FC1>
      <template v-slot="params">
         <ul>
            <li v-for="item in params.youxi" :key="item.id">{{item.name}}</li>
   		</ul>
		</template>
	</FC1>
</div>
</template>

<script setup>
   import FC1 from "@/components/Slot/FC1.vue";
</script>

<style scoped>
   .FS {
      background-color: #2c3e50;
      width: 500px;
      height: 400px;
      display: flex;
      align-items: center;
      justify-content: space-around;

   }
</style>
```

`FC1.vue`

```vue
<template>
  <div class="Fc1">
    <h3>游戏列表</h3>
    <!--  <slot name="default"></slot>-->
    <slot :youxi="games" :a="haha" :b="enen"><p>默认内容</p></slot>
  </div>

</template>

<script setup>
import {reactive} from 'vue'

const games = reactive([
  {
    id: 1,
    name: 'game1'
  },
  {
    id: 2,
    name: 'game2',
  }, {
    id: 3,
    name: 'game3'
  }, {
    id: 4,
    name: 'game4'
  }

])
</script>

<style scoped>
.Fc1 {
  background-color: aquamarine;
  width: 100px;
  height: auto;
}
</style>
```

![img](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407201313905.png)

# Pinia状态管理

## Pinia基础

**官网**：https://pinia.vuejs.org/zh/introduction.html

### 1.安装pinia

```bash
npm i pinia
```

### 2.配置pinia环境

在main.js中引入pinia

```vue
import {createPinia} from 'pinia'
const pinia =createPinia()
app.use(pinia)
```

### 3.创建store

在store文件夹中创建count.js

```javascript
import {defineStore} from 'pinia'
export const useCountStore = defineStore('count', {
    //真正存储数据的地方
    state: () => {
        return {
            sum: 6,
            school: '学校',
            address: '地址'
        }
    },
    actions: {
        increment(value:number) {
            this.sum+=value
        }
    }
  getters:{
    bigSum(state){
      return state.sum*10
    }
})
```

### 4.使用创建的store

```vue
<template>
  <p>{{sum}}</p>
</template>
<script setup>
  //引入
  import {useCountStore} from '@/store/count'
  import{storeToRefs} from 'pinia'
  //创建
  const countStore = useCountStore()
  //storeToRefs只解构数据，不解构方法等
  const {sum} = storeToRefs(countStore)
  const n = ref(1)
  countStore.increment(n.value)
</script>
```

### 5.修改数据

#### 方式一：直接修改

```
countStore.sum+=1
```

#### 方式二：批量统一修改

```vue
countStore.$patch({
  sum:100,
  school:'江苏理工学院',
  address:'常州'
})
```

#### 方式三：actions动作创建函数（可复用）

```vue
  actions: {
        increment(value) {
            this.sum+=value
        }
    }
```

调用`countStore.increment(n.value)`



### 6.getters

获取数据时，对数据进行进一步操作

```javascript
getters:{
  bigSum(state){
    return state.sum*10
  }
}
```

## Pinia持久化

**官网**：https://prazdevs.github.io/pinia-plugin-persistedstate/zh/guide/

### 1.下载插件

```bash
npm i pinia-plugin-persistedstate
```

### 2.在main.js中配置

```javascript
//创建pinia
import { createPinia } from 'pinia'
//持久化插件
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
//pinia持久化挂载
pinia.use(piniaPluginPersistedstate)
app.use(pinia)
```

### 3在所需要的store中开启

```javascript
//定义store
export const useStore = defineStore('store', {
    //所有数据持久化
    //persist:true
   //选项卡持久化，使页面刷新关闭时，tabList的值不会清空
    persist: {
       //存储的key
        key:'tabs',
        //存储位置
        storage:localStorage,
        //需要存储的数据
        paths:['tabList']
    }
})
```

# 组件间通信

## 1.父子间通信

- **父传子**：defineProps接受

- **子传父**：通过事件或者函数

> 标签传递， 通过defineProps接受，props值应视为不可改变的
>
> 如果需要在子组件中基于父组件传递的 props 改变值，你应该使用事件来通知父组件进行相应的改变。

`Father.vue`

```vue
<template>
  <div class="father">
    <p>这是父组件</p>
    <button @click="fatherAddNum">父组件点击</button>
    <!--父组件需要监听这个increment事件（比如click点击事件）并对其响应-->
    <Son :a="num"
      @increment="fatherAddNum"
      :addNum="addNum"></Son>
  </div>
</template>

<script setup>
  import {ref} from 'vue'
  import Son from "@/components/Son.vue";

  const num = ref(1)

  //方式一，传递事件，子组件调用函数触发事件通知父组件响应
  function fatherAddNum() {
    num.value += 1;
  }

  //方式二，直接传递方法，子组件直接控制父组件方法
  function addNum() {
    num.value += 1;
  }
</script>

```

`Son.vue`

```vue
<template>
<div class="son">
   <p>这是子组件</p>
   <p>{{ props.a }}</p>
   <!--触发父组件事件increment来调用父函数-->
   <button @click="emit('increment')"> 方式一</button>
   <!--直接使用父组件传递过来的函数-->
   <button @click="addNum">方式二</button>
   </div>
</template>
<script setup>
   import {watchEffect} from "vue";
   const props=defineProps(['a','addNum'])
   // const props = defineProps({
   //     a:{
   //         type:Number,
   //         default:0
   //     }
   // })
   //子组件需要监听这个increment事件并对其响应
   const emit=defineEmits(['increment'])
   watchEffect(()=>{
      if(props.a>10){
         alert("a的值大于10了!")
      }
   })
</script>
```

![img](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407201315435.png)

## 2.爷孙间通信

- **爷传孙**：provice，inject

- **孙传爷**：provice提供回调函数

> 爷和所有后代间通信，而**不打扰**中间的父组件（可传递）

### 1.爷组件中引入provide

```vue
import {provide} from 'vue'
```

`Grandpa.vue`

```vue
<template>
<F></F>
</template>

<script setup>
import F from "@/components/GFC/F.vue";
import {ref,provide} from 'vue'
const money=ref(10000)
function updateMoney(value){
  // money.value=value
  money.value -= value
}
//提供数据
provide('moneyContext',{money,updateMoney})
</script>

```

`Father.vue`

```vue
<template>
  <Child>
</template>
<script setup>
 import Child from '@/views/Child.vue'
</script>
```



### 2.孙组件中引入inject

```vue
import {inject} from 'vue'
```

`Child.vue`

```vue
<template>
  <p>{{money}}</p>
  <button @click="updateMoney(100)">花爷爷100元</button>
</template>
<script setup>
import {inject} from 'vue'
//解构注入，数据money，方法updateMoney
const {money,updateMoney}=inject('moneyContext')
</script>
```

## 3.任意组件间通信(不光父子之间)

### 1.下载插件mitt

```bash
npm i mitt
```

### 2.在utils包下新建emitter.ts文件

```tsx
// 引入mitt
import mitt from 'mitt'
//调用mitt得到emitter
//能绑定事件(emitter.on)，触发(emitter.emit),解绑(emitter.off),全部(emitter.all)
const emitter = mitt()
//暴露
export default emitter
```

### 3.引入emitter

```vue
import emitter from '@/utils/emitter'
```

`F1.vue`

```vue
<template>
  <C1></C1>
  <C2></C2>
</template>

<script setup>
import C1 from "@/components/C1.vue";
import C2 from "@/components/C2.vue";
</script>
```

`C1.vue`

```vue
<template>
<h3>玩具:{{toy}}</h3>
<!--触发事件，且将C1的toy作为参数-->
<button @click="emitter.emit('send-toy',toy)">玩具给C2</button>
</template>

<script setup>
import {ref} from 'vue'
import emitter from "@/utils/emitter";
const toy =ref('奥特曼')
</script>
```

`C2.vue`

```vue

<template>
  <h3>电脑:{{ computer }}</h3>
  <h3>C1给的玩具:{{ toy }}</h3>
</template>

<script setup>
import {onUnmounted, ref} from 'vue'
import emitter from "@/utils/emitter";

const computer = ref('联想')
const toy = ref('')
//绑定事件，将参数value绑定到C2的toy上
emitter.on('send-toy', (value) => {
  toy.value = value
})
  
// 在组件卸载时取消监听事件，减少内存负担
onUnmounted(()=>{
  emitter.off('send-toy')
})
</script>
```



# Axios配置

## 1.在Controller类上添加@CrossOrigin解决跨域

先启动后端，再启动前端

后端接口8080

前端接口8081

## 2.Axios下载

```bash
npm install vue axios@latest
```

## 3.axios的原始使用

```vue
<template>
  以下显示数据:
<p>{{data}}</p>
</template>
<script setup>
import axios from "axios";
import { ref, onMounted } from "vue";

const data = ref("");
onMounted(() => {
  axios.get("/users").then((res) => {
    data.value = res.data;
  });
});

</script>
```

## 4.axios封装为request.js

使用request.js  注意：如果有统一接口前缀api需处理

```javascript
import axios from 'axios'

// 创建一个axios对象出来
const request = axios.create({
    /*统一给接口加上api前缀*/
    //baseURL: 'http://localhost:8080/api',
	  baseURL: 'http://localhost:8080',
    timeout: 5000
})

// request 拦截器
// 可以自请求发送前对请求做一些处理
// 比如统一加token，对请求参数统一加密
request.interceptors.request.use(config => {
    config.headers['Content-Type'] = 'application/json;charset=utf-8';
    const user = localStorage.getItem("user");
    if (user) {
        config.headers['token'] = JSON.parse(user).token;//设置请求头
    }
    return config
}, error => {
    return Promise.reject(error)
});

// response 拦截器
// 可以在接口响应后统一处理结果
request.interceptors.response.use(
    response => {
        // response.data即为后端返回的Result
        let res = response.data;
        // 兼容服务端返回的字符串数据
        if (typeof res === 'string') {
            res = res ? JSON.parse(res) : res
        }
        return res;
    },
    error => {
        console.log('err' + error) // for debug
        return Promise.reject(error)
    }
)


export default request
```

## 5.axios封装为request.ts

```tsx
import axios,
{type AxiosInstance, type InternalAxiosRequestConfig,type AxiosResponse,type AxiosRequestConfig} from 'axios';
import {ElMessage} from 'element-plus'
// axios配置
const config = {
	baseURL: 'http://localhost:8080',
	timeout: 5000
}

//定义返回值类型泛型
export interface Result<T = any> {
	code: number;
	message: string;
	data: T;
}

class request {
	//axios实例化
	private instance: AxiosInstance;

	//初始化的作用
	constructor(configs: AxiosRequestConfig) {
		//实例化axios对象
		this.instance = axios.create(configs);
		//配置拦截器
		this.interceptors()
	}

	//请求发送之前，返回之后做统一处理
	private interceptors() {
		//请求发送之前的处理，请求头携带token
		this.instance.interceptors.request.use(
			(config: InternalAxiosRequestConfig) => {
				//获取token
				let token = '';
				if (token) {
					config.headers['token'] = token;
				}
				return config;
			},
			(error: any) => {
				//处理请求发送之前的错误
				error.data = {};
				error.data.msg = '请求发送失败，请稍后再试';
				// // 处理错误并封装为 Promise.reject,可以在这里记录日志或者进行其他处理
				return Promise.reject(error);
			}
		);

		//请求返回之后的处理，统一处理返回值
		this.instance.interceptors.response.use(
			(res: AxiosResponse) => {
				if(res.data.code === '0'){
					return res.data;
				}else{
					ElMessage.error(res.data.msg||'接口报错!');
					return Promise.reject(res.data||'接口报错!');
				}
			},
			(error: any) => {
				console.log("进入错误");
				error.data = {};
				if(error&&error.response){
					switch(error.response.status){
						case 400:
							error.data.msg = '请求参数错误';
							ElMessage.error(error.data.msg);
							break;
						case 401:
							error.data.msg = '请先登录';
							ElMessage.error(error.data.msg);
							break;
						case 403:
							error.data.msg = '无权限访问';
							ElMessage.error(error.data.msg);
							break;
						case 404:
							error.data.msg = '请求的资源不存在';
							ElMessage.error(error.data.msg);
							break;
						case 405:
							error.data.msg = '请求方法不被允许';
							ElMessage.error(error.data.msg);
							break;
						case 408:
							error.data.msg = '请求超时';
							ElMessage.error(error.data.msg);
							break;
						case 500:
							error.data.msg = '后台接口错误';
							ElMessage.error(error.data.msg);
							break;
						case 501:
							error.data.msg = '服务未实现';
							ElMessage.error(error.data.msg);
							break;
						case 502:
							error.data.msg = '网关错误';
							ElMessage.error(error.data.msg);
							break;
						case 503:
							error.data.msg = '服务不可用';
							ElMessage.error(error.data.msg);
							break;
						case 504:
							error.data.msg = '网关超时';
							ElMessage.error(error.data.msg);
							break;
						case 505:
							error.data.msg = 'HTTP版本不受支持';
							ElMessage.error(error.data.msg);
							break;
						default:
							error.data.msg = `连接错误${error.response.status}`;
							ElMessage.error(error.data.msg);
							break;
					}
				}else{
					error.data.msg = '连接服务器失败';
					ElMessage.error(error.data.msg);
				}
				return Promise.reject(error.data);
			}
		)

	}

	//封装get请求
	get<T=Result>(url: string, params?: object): Promise<T> {
		return this.instance.get(url,{params})
	}
	//封装post请求
	post<T=Result>(url: string, data?:object):Promise<T>{
		return this.instance.post(url,data)
	}
	//put请求
	put<T=Result>(url: string, data?:object):Promise<T>{
		return this.instance.put(url,data)
	}
	//delete请求
	delete<T=Result>(url: string): Promise<T> {
		return this.instance.delete(url)
	}

export default new request(config);
```

## 6.前端使用requset.js

```vue
<template>
  <p>{{ tableData }}</p>
</template>

<script setup>
import request from "@/utils/request";
import {ref} from 'vue'

const tableData = ref([])

function load() {
  request.get("/users").then(res => {
    if (res.code === '0') {
      tableData.value = res.data;
      console.log(res.data)
    } else {
      console.log(res.msg)
    }
  })
}
```

# 引入Element-Plus

## 1.**下载**Element-plus

```bash
npm install element-plus --save

//下载element-plus的icons图标
npm install @element-plus/icons-vue --save
```

## 2.**按需引入**

首先你需要安装`unplugin-vue-components` 和 `unplugin-auto-import`这两款插件

```bash
npm install -D unplugin-vue-components unplugin-auto-import --save
```

config配置：

- ##### Vite

```js
// vite.config.ts
import { defineConfig } from 'vite'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  // ...
  plugins: [
    // ...
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
})
```

- ##### Webpack

```js
// webpack.config.js
const AutoImport = require('unplugin-auto-import/webpack')
const Components = require('unplugin-vue-components/webpack')
const { ElementPlusResolver } = require('unplugin-vue-components/resolvers')

module.exports = {
  // ...
  plugins: [
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
}
```

## 3**.完整引入**

如果你对打包后的文件大小不是很在乎，那么使用完整导入会更方便。

```js
// main.ts
import { createApp } from 'vue'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import App from './App.vue'

const app = createApp(App)

app.use(ElementPlus)
app.mount('#app')
```

## 4.**注册所有图标**

```java
// main.ts

// 如果您正在使用CDN引入，请删除下面一行。
import * as ElementPlusIconsVue from '@element-plus/icons-vue'

const app = createApp(App)
   
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key, component)
}
```

