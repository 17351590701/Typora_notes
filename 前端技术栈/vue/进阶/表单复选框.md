### 封装SelectChecked.vue

```java
<template>
  <!-- 下拉多选框 -->
  <el-select 
  v-model="selectedOptions"
  multiple
  placeholder="请选择"
  :popper-apped-to-body="false"
    @remove-tag="removeTag"
    style="width:100%"
    >
    <el-option 
    v-for="item in options" 
      :key="item.value" 
        :label="item.label" 
          :value="item.value"
            >
            <el-checkbox style="width: 100%" v-model="item.check" @change="isChecked(item)">.
          {{item.label}}
</el-checkbox>
  </el-option>
  <div class="is-all">
    <div @click="selectAll(true)">全选</div>
    <div @click="selectAll(false)">反选</div>
    </div>
    </el-select>
    </template>

    <script lang="ts" setup>

    import {ref, watch} from 'vue'
    //定义下拉数据类型
    type SelectIem = {
    value: string|number,
    label: string,
    check: boolean,
  }

//接受父组件参数
let props = defineProps({
  options: {
    type: Array<SelectIem>,
    required: true,
  },
  width: {
    type: Number,
    default() {
      return 220;
    }
  },
  bindValue: {
    type: Array<string | number>,
    default() {
      return [];
    }
  }
})
  //注册事件
  const emit = defineEmits(['selected'])
  //下拉的数据
  let selectedOptions = ref<Array<string | number>>([])
  //下拉的点击事件
  const isChecked = (item: SelectIem) => {
  if (item.check && selectedOptions.value.indexOf(item.value)==-1) {
    selectedOptions.value.push(item.value)
  } else if (!item.check) {
    selectedOptions.value.forEach((elm, idx) => {
      if (elm == item.value) {
        selectedOptions.value.splice(idx, 1)
      }
    })
  }
  emit("selected", selectedOptions.value)
}
//删除tag
const removeTag = (value: any) => {
  props.options.forEach((elm) => {
    if (elm.value == value) {
      elm.check = false
    }
  })
    emit("selected", selectedOptions.value)
}
// 全选或反选
const selectAll = (isAll: boolean) => {
  if (isAll) {
    selectedOptions.value = [];
    props.options.forEach((item: SelectIem) => {
      item.check = true;
      selectedOptions.value.push(item.value);
    });
  } else {
    // 反选逻辑简化如下
    const currentlySelected = new Map(props.options.map((option) => [option.value, option.check]));
    //奖励所有，将check属性设为反值
    props.options.forEach((item: SelectIem) => {
      item.check = !currentlySelected.get(item.value);
    });
    //重新计算 selectedOptions.value，仅包含当前选中的选项值
    selectedOptions.value = props.options
      .filter((item) => item.check)
      .map((item) => item.value);
  }
  emit("selected", selectedOptions.value);
};

//清空下拉的数据
const clear = () => {
  selectedOptions.value=[];
}
//暴露出去，给外部组件使用
defineExpose({
  clear
})
  watch(
  () => props.bindValue,
  ()=>{
    //设置选中的值
    selectedOptions.value=props.bindValue;
    //设置checkbox为选中
    props.bindValue.forEach(item=>{
      props.options?.forEach(dom=>{
        if(dom.value == item){
          dom.check=true;
        }
      })
    })
  },
  //使第一次打开编辑页面也能显示选中的值
  {
    immediate: true,
  }
)
  </script>
  <style lang="scss" scoped>
  .is-all{
  display: flex;
  padding-left:10px;
  div{
    cursor:pointer;
    margin:6px 10px;
    transition:0.2s;
    &:hover{
      opacity: 0.7;
    }
  }
}

</style>
```





### 使用

前端SysGood模型

```java
//新增，编辑弹窗绑定数据
const addModel = reactive({
  goodId: '',
  goodName: '',
  description: '',
  price: '',
  pictureKey: '',
  createTime: '',
  updateTime: '',
  //发送“，”字符串给后端，保存分类id
  categoryId:''
})
```

后端SysGood模型

```java
@Data
@TableName("sys_good")
public class SysGood {
    @TableId(type= IdType.AUTO)
    private Long goodId;
    private String goodName;
    private String Description;
    private String price;
    private String pictureKey;
    //不属于用户表，需要排除
    @TableField(exist = false)
    private String categoryId;
    private Date createTime;
    private Date updateTime;

}
```



> bindValue:从后端返回的该商品已拥有商品类型id的list集合
>
> ref属性：方便清空数据
>
> options：全部下拉数据选项，集合元素属性为：value,label,check
>
> @selected:勾选值
>
> categoryId:以“,”分隔，存储前端勾选的商品类型id,传递给后端以便保存
>
> categoryIds:以“,”从后端接受，数据库中已有的分类id，以“,”分隔给前端，以便数据回显

```java
  <SelectChecked :bindValue="bindValue" ref="selectRef" :options="options" @selected="selected"style="width:200px"></SelectChecked>
```

#### bindValue:

> GetCategoryListApi：获取已有的商品类型id，以此商品id，在关系表中查询，返回类型id集合
>
> bindValue:从后端返回的该商品已拥有商品类型id的list集合
>
> categoryIds:以“,”从后端接受，数据库中已有的分类id，以“,”分隔给前端，以便数据回显

```java
//商品本就有的分类id集合
const bindValue=ref([])
//存取已经对应的分类id，以“，”分隔，用于复选框回显
const categoryIds = ref('')
//根据商品id查询对应分类
const getCategoryList=async(goodId:string)=>{
  let res = await getCategoryListApi(goodId)
  if (res && res.code == 200) {
    bindValue.value = res.data
    categoryIds.value = res.data.join(',')
  }

```

```vue
<script>
  //根据商品id查询对应分类
  const getCategoryList=async(goodId:string)=>{
    let res = await getCategoryListApi(goodId)
    if (res && res.code == 200) {
      bindValue.value = res.data
      categoryIds.value = res.data.join(',')
    }
<script>
```

```java
    //根据商品id查新对应的商品类型
    @GetMapping("/getCategoryList")
    public Result getCategoryList(Long goodId){
        QueryWrapper<SysCategoryGood> query= new QueryWrapper<>();
        query.lambda().eq(SysCategoryGood::getGoodId,goodId);
        //查询满足条件的category-good表至lisi中
        List<SysCategoryGood> list = sysCategoryGoodService.list(query);
        //categoryId集合
        List<Long> categoryList = new ArrayList<>();
        //判断查询是否为空
        Optional.ofNullable(list).orElse(new ArrayList<>())
                .forEach(item->{
                    categoryList.add(item.getCategoryId());
                });
        return Result.success("查询成功",categoryList);
    }
```



#### options:

> getSelectAPi：获取所有完整的下拉数据，以SelectItem为元素

```vue
<script>
//获取完整下拉菜单数据
const options = ref([])
async function getSelect() {
  let res = await getSelectApi()
  if (res && res.code == 200) {
    options.value=res.data;
  }
}
</script>
```

```java
@Data
public class SelectItem {
    private Long value;
    private String label;
    private Boolean check;

}
```

```java
@GetMapping("/selectList")
public Result selectList(){
  List<SysCategory> list = sysCategoryService.list();
  //返回的值
  List<SelectItem> selectItems = new ArrayList<>();
  Optional.ofNullable(list).orElse((new ArrayList<>()))
    .forEach(item->{
      SelectItem si = new SelectItem();
      si.setCheck(false);
      si.setLabel(item.getCategoryName());
      si.setValue(item.getCategoryId());
      selectItems.add(si);
    });
  return Result.success("查询成功",selectItems);
}
```

#### 新增按钮

```vue
<script>
//新增
const addBtn = async () => {
  tags.value = '0'
  dialog.title = '新增'
  dialog.height = 300
  addRef.value?.resetFields()
  onShow()
  //清空下拉数据
  options.value=[];
  bindValue.value=[];
  //重新获取所有下拉数据
  await getSelect()
  //查询该商品对应的分类
  nextTick(()=>{
	//调用SelectCheck组件中暴露的清空反方法
    selectRef.value.clear()
  })
  //清空form表单
  addRef.value?.resetFields()
}
</script>
```

#### 编辑按钮

>  addModel.categoryId=categoryIds.value
>
> 复选框回显，也便于接着选择

```vue
<script>
//编辑
const editBtn = async(row: GoodModel) => {
  tags.value = '1'
  dialog.title = '编辑'
  dialog.height = 300
  options.value=[];
  bindValue.value=[];
  await getSelect();
  await getCategoryList(row.goodId)
  onShow()
  nextTick(() => {
	//数据回显，将该行所有数据，赋值给新增编辑模型
    Object.assign(addModel, row)
	//复选框回显
    addModel.categoryId=categoryIds.value
  })

  addRef.value?.resetFields();
}
</script>
```

#### Seletcted方法

```vue
<script>
//勾选的值以“,分隔”
const selected = (value: Array<string | number>) => {
  addModel.categoryId = value.join(",")
}
</script>
```



## 后端修改后的增删改逻辑至关系表中

```java
@Service
public class SysGoodServiceImpl extends ServiceImpl<SysGoodMapper, SysGood> implements SysGoodService {
    @Resource
    private SysCategoryGoodService sysCategoryGoodService;

    @Override
    @Transactional
    public void saveGood(SysGood sysGood) {
        // 尝试插入商品信息
        int i = this.baseMapper.insert(sysGood);
        // 如果插入成功，则处理商品和分类的关系
        if (i > 0) {
            // 分类id以逗号分隔为数组
            String[] split = sysGood.getCategoryId().split(",");
            // 保存商品与分类的关系
            InsertGoodCategory(sysGood, split);
        }
    }

    @Override
    public void editGood(SysGood sysGood) {
        int i = this.baseMapper.updateById(sysGood);
        if (i > 0) {
            // 根据角色ID字符串，分割出角色ID数组
            String[] split = sysGood.getCategoryId().split(",");
            // 构造查询Wrapper，用于删除用户原有角色关系
            QueryWrapper<SysCategoryGood> query = new QueryWrapper<>();
            query.lambda().eq(SysCategoryGood::getGoodId,sysGood.getGoodId());
            // 删除用户与角色的原有关系
            sysCategoryGoodService.remove(query);
            // 建立用户与角色的新关系
            InsertGoodCategory(sysGood, split);
        }
    }

    @Override
    public void deleteGood(Long goodId) {
        int i = this.baseMapper.deleteById(goodId);
        // 当删除的行数大于0，即用户存在时，删除该用户所有关联的角色信息
        if (i > 0) {
            QueryWrapper<SysCategoryGood> query = new QueryWrapper<>();
            // 构造查询条件，根据用户ID删除用户角色关联信息
            query.lambda().eq(SysCategoryGood::getGoodId, goodId);
            sysCategoryGoodService.remove(query);
        }
    }

    //
    private void InsertGoodCategory(SysGood sysGood, String[] split) {
        if (split.length > 0) {
            // 初始化一个空的分类列表，用于存储商品与分类关系数据。
            List<SysCategoryGood> categorys = new ArrayList<>();

            for (String s : split) {
                // 为每个商品ID创建一个商品，分类关系对象，并设置商品id，分类id。
                SysCategoryGood categoryGood = new SysCategoryGood();
                categoryGood.setGoodId(sysGood.getGoodId());
                categoryGood.setCategoryId(Long.parseLong(s));
                categorys.add(categoryGood); // 将商品，分类关系，存储到商品与分类列表中。
            }
            // 批量保存用户角色关系到数据库。
            sysCategoryGoodService.saveBatch(categorys);
        }
    }
}

```

