# JVM的组成

![image-20240702140144618](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021401714.png)

# 字节码文件详解

## 字节码文件的组成

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021406696.png" alt="image-20240702140651614" style="zoom:80%;" />

==工具==：jclasslib

### 基本信息

#### Magic魔术

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021414224.png" alt="image-20240702141452143" style="zoom:80%;" />

#### 主副版本号

![0](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021416661.png)

#### 基础信息

![image-20240702142105834](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021421935.png)

### 常量池

- 字节码文件中常量池的作用：避免相同的内容重复定义，浪费空间

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021511371.png" alt="image-20240702151130258" style="zoom:80%;" />

### 方法

- 操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置

```bash
iconst_0 # 将0放入操作数栈中
istore_1 # 将i存入局部变量数组下标为1的
iload_1 # 加载i的值到操作数栈（复制一份）
iinc 1 by 1 # 直接累加在局部变量表数组，而非操作数组
istore_1 # 操作数栈中的i（0）存入局部变量数组中
return
```

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021522274.png" alt="image-20240702152233185" style="zoom:80%;" />

### 常见工具

- javap ：JDK自带的反编译工具，**适合在服务器上查看字节码文件内容**
- jclasslib：可以在代码**编译之后**实时看到字节码文件内容
- arthas：全局视角实时查看应用load、内存、gc、线程的状态信息，并且能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率

==Arthas==

官网：https://arthas.aliyun.com/doc/

下载解压后，在终端运行 `java -jar arthas-boot.jar`启动

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021601666.png" alt="image-20240702160141570" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021609104.png" alt="image-20240702160903034" style="zoom:80%;" />

```bash
java -jar arthas-boot.jar
# 反编译字节码为源代码类
jad com.itheima.springbootclassfile.controller.UserController
```

# 类的生命周期

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021622234.png" alt="image-20240702162222174" style="zoom:80%;" />

## 加载阶段

1. 加载阶段第一步是==类加载器==根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息
2. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中
3. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中
   1. 生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息
4. 同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象
   1. 作用是Java代码中区获取类的信息以及存储静态字段的数据（JDK8及之后）

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021621797.png" alt="image-20240702162157689" style="zoom:80%;" />

## 连接阶段

### 验证

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021639211.png" alt="image-20240702163919149" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021641806.png" alt="image-20240702164108725" style="zoom:80%;" />

### 准备

> final修饰的变量，即在类的初始化前，已经有值，使用 `int i = Student.value;`不会导致类的初始化

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021704864.png" alt="image-20240702170406751" style="zoom:80%;" />

### 解析

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021710162.png" alt="image-20240702171004086" style="zoom:80%;" />

## 初始化阶段

- 初始化阶段会执行==静态代码块中的代码==，并为==静态变量赋值==
- 初始化阶段会执行字节码文件中`clinit`部分的字节码指令

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021947245.png" alt="image-20240702194714146" style="zoom:80%;" />

![image-20240702194753965](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021947046.png)

==结果：1==

> 以下几种方式会导致类的初始化

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407021949323.png" alt="image-20240702194931279" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022003943.png" alt="image-20240702200344845" style="zoom:80%;" />

由于要运行Test1()，所以在main()之前，先运行了static{}静态方法块。static{}--->{}--->构造方法

> clinit指令在特定情况下不会出现，比如：如下几种情况是不会进行初始化指令执行的。

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022007158.png" alt="image-20240702200741114" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022012231.png" alt="image-20240702201259143" style="zoom:80%;" />

## 总结

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022015520.png" alt="image-20240702201528451" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022016426.png" alt="image-20240702201659365" style="zoom:80%;" />

# 类加载器

类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。类加载器只参与加载过程中的字节码获取并加载到内存这一部分

## 类加载器的分类

- Java代码中实现
- Java虚拟机底层源码实现

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022027838.png" alt="image-20240702202707746" style="zoom:80%;" />

### 启动类加载器-Bootstrap

![image-20240702203256911](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022032018.png)

### Java中的默认类加载器

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022045554.png" alt="image-20240702204520458" style="zoom:80%;" />

#### 扩展类加载器

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407022043679.png" alt="image-20240702204350574" style="zoom:80%;" />

## 双亲委派机制

由于Java虚拟机中有多个类加载器，双亲委派机制的核心是==解决一个类到底由谁加载的问题==

- 保证类加载的安全性
- 避免重复加载

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407032055380.png" alt="image-20240703205542260" style="zoom:80%;" />

### 例题

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407032059765.png" alt="image-20240703205949685" style="zoom: 67%;" />

> 在Java中如何使用代码的方式加载一个类？
>
> - 使用Class.forName方法，使用当前类的类加载器去加载指定的类
> - 获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载

```java
//获取main方法所在类的类加载器，应用程序类加载器
ClassLoader classLoader = Demo01.class.getClassLoader();
//尝试使用 应用程序类加载器 加载 java.lang.String
Class<?> stringClazz = classLoader.loadClass("java.lang.String");
// 打印为 null,即 为bootstrap启动类加载器，已经加载过的String
System.out.println(stringClazz.getClassLoader());
```

### 总结

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407032111551.png" alt="image-20240703211135453" style="zoom: 80%;" />

## 打破双亲委派机制

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407032112361.png" alt="image-20240703211246259" style="zoom:80%;" />

### 自定义类加载器

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041613673.png" alt="image-20240704161347526" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041614798.png" alt="image-20240704161417698" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041616429.png" alt="image-20240704161642319" style="zoom:80%;" />

#### 案例

```java
public class BreakClassLoader extends ClassLoader{
   ...
      @Override
      public Class<?> loadClass(String name) throws ClassNotFoundException{
      byte[] data = loadClassData(name);
      return defineClass(name,data,0,data.length);
   }
   ...
}
```

### 线程上下文类加载器

```java
// 获取应用程序类加载器
Thread.currentThread().getContextClassLoader();
```



#### 案例

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041642133.png" alt="image-20240704164204015" style="zoom:80%;" />

## 总结

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041657803.png" alt="image-20240704165706726" style="zoom:67%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041657351.png" alt="image-20240704165746239" style="zoom:67%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041658780.png" alt="image-20240704165808678" style="zoom:67%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041658013.png" alt="image-20240704165841942" style="zoom:67%;" />

# 运行时数据区域（JVM管理的内存）

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041701060.png" alt="image-20240704170121948" style="zoom:67%;" />

## 程序计数器

> 程序计数器中为下一次要解释的解释指令的==内存地址==

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041706046.png" alt="image-20240704170637949" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041708486.png" alt="image-20240704170832366" style="zoom:67%;" />

==思考==

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041709039.png" alt="image-20240704170920961" style="zoom:67%;" />

## 栈

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041711341.png" alt="image-20240704171131229" style="zoom: 67%;" />

### 栈帧的组成

![image-20240704184650692](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041846799.png)

#### 局部变量表

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041726360.png" alt="image-20240704172633238" style="zoom:67%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041843162.png" alt="image-20240704184329048" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041845600.png" alt="image-20240704184549480" style="zoom:80%;" />

#### 操作数栈

操作数栈深度，操作数栈中最多同时存在的字节码指令变量数

![image-20240704185058169](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041850244.png)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041848634.png" alt="image-20240704184859538" style="zoom:80%;" />

#### 帧数据

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041852029.png" alt="image-20240704185222940" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041853825.png" alt="image-20240704185336729" style="zoom: 80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041854505.png" alt="image-20240704185404396" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041856952.png" alt="image-20240704185643817" style="zoom:80%;" />

#### 栈内存溢出

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041858581.png" alt="image-20240704185838473" style="zoom:80%;" />

##### 默认大小

> 如果不指定栈的大小，JVM将创建一个具有==默认大小的栈==。大小取决于操作系统和计算机的体系结构
>
> windows环境下，默认大小**基本为1024k**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041905499.png" alt="image-20240704190532386" style="zoom:80%;" />

##### 注意事项

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041905015.png" alt="image-20240704190507910" style="zoom:80%;" />

#### 本地方法栈

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041907570.png" alt="image-20240704190725472" style="zoom:80%;" />

## 堆

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041911165.png" alt="image-20240704191153054" style="zoom:80%;" />

### 案例-模拟堆区溢出

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041949024.png" alt="image-20240704194944921" style="zoom:80%;" />

```java
ArrayList<Object> objects = new ArrayList<>();
while(true){
   objects.add(new byte[1024*1024&100]);
}
```

### Java堆

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407041952566.png" alt="image-20240704195203489" style="zoom:80%;" />

> ==问题：==时不时当used=max=total的时候，堆内存就溢出了？
>
> ==答：==错误

#### 设置大小

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042007684.png" alt="image-20240704200713574" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042008804.png" alt="image-20240704200830702" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042009470.png" alt="image-20240704200918394" style="zoom:80%;" />

## 方法区

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042011970.png" alt="image-20240704201151874" style="zoom:80%;" />

> ==类的元信息==：包括类的全限定名、访问修饰符、超类、实现的接口、字段信息、方法信息（方法名、返回类型、参数列表、字节码等）、静态初始化器等。
> ==常量池==：每个类都有一个运行时常量池，它是类文件中常量池表的内存表示。它存储了编译期就已确定的各种字面量（如字符串、整数、浮点数等）和符号引用（如类和方法的全限定名等）。
> ==静态变量==：类的静态变量存储在方法区中，而不是堆上。这意味着无论类实例化了多少个对象，静态变量都只有一份拷贝，所有对象共享。
> 即时编译后的代码：JVM的即时编译器（JIT）可能会把部分字节码编译成本地机器码，并存储在方法区中，以便提高程序的执行效率。

==JDK版本区别==

> JDK 6 **字符串常量池**存于**方法区**（永久代），而**方法区**又存于**堆**
>
> JDK 7 **方法区**（永久代）与 **字符串常量池** 同级 存于 **堆**
>
> JDK 8 **方法区**（元空间）独立于堆，**堆**中存放**字符串常量池**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042016675.png" alt="image-20240704201652526" style="zoom:80%;" />

### 元信息

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042043116.png" alt="image-20240704204345021" style="zoom:80%;" />



### 运行时常量池

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042044296.png" alt="image-20240704204432182" style="zoom:80%;" />

### 字符串常量池（JDK8后存放于堆）

> 为什么说 `new String("abc")`时创建了两个String对象?
>
> 1. 如果常量池中不存在abc字符串对象,则先在常量池中创建String对象，作为共享实例
> 2. 再在堆内存中新建一个String对象，通过复制常量池中的"abc"字符串内容来初始化的

比较`s1`和`s2`的地址

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042019178.png" alt="image-20240704201920066" style="zoom:80%;" />

#### 案例1

> `String d= a+b`实际上new了一个StringBuilder对象来连接字符串，所以d是存储在堆内存中的。

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042028048.png" alt="image-20240704202804909" style="zoom:80%;" />

#### 案例2

> 当直接使用 `String d = "1"+"2"`时，c==d为true

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042030996.png" alt="image-20240704203057866" style="zoom:80%;" />

#### 案例3

> `String.intern()`方法是可以手动将字符串防区字符串常量池中
>
> 由于JVM需要用到`"java"`所以在初始化时，在字符串常量池中已经有了 `"java"`
>
> JDK6中的`s1.intern()` 是将 `"think123"`存入字符串常量池
>
> JDK8中的`s1.intern()` 是将堆内存中`"think123"`的地址存入字符串常量池

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042037399.png" alt="image-20240704203734321" style="zoom:80%;" />

## 直接内存

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042049695.png" alt="image-20240704204947581" style="zoom:80%;" />

设置直接内存大小

```bash
-XX:MaxDirectMemorySize=1g
```

# 自动垃圾回收

![image-20240704210959812](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042109989.png)

> ==线程不共享==的部分，不需要垃圾回收机制

![image-20240704211105255](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042111126.png)

![image-20240704210838953](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042108092.png)

## 方法区回收

![image-20240704212515124](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042125242.png)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407042125669.png" alt="image-20240704212539592" style="zoom:80%;" />

```java
ArrayList<Object> objects = new ArrayList<>();
while(true){
   URLClassLoader loader = new URLClassLoader(
      new URL[]{new URL("file:D\\lib\\")});
   Class<?> clazz = loader.loaderCLass("com.itheima.my.A");
   Object o = clazz.newInstance();
   
   // objects.add(o); //模拟对象 o 在使用
   // classes.add(clazz); //模拟Class对象 clazz 在使用
   // Loaders.add(loader); //模拟类加载器 loader 在使用
   
   System.gc();
}
```

## 堆回收

### 判断是否可回收

> Java中的对象是否能被回收，是根据对象是否被引用来决定的

`demo=null`不再保存Demo实例对象在堆内存中的地址，可以被回收

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051213988.png" alt="image-20240705121319852" style="zoom:80%;" />

此时`a1`实例对象有两个引用

1. `a1`指向堆内存中的A实例对象地址
2. `b1.a =a1`指向堆内存中的A实例对象地址

当 `a1=null` &&`b1.a=null` 时，A的实例对象才可被回收

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051217289.png" alt="image-20240705121741182" style="zoom:80%;" />

### 判断堆对象是否被引用

- 引用计数法
- 可达性分析法

#### 引用计数法

> 为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。为0时，可回收

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051237883.png" alt="image-20240705123739739" style="zoom:80%;" />

#### 可达性分析算法（java采用）

Java使用的是==可达性分析算法==来判断对象是否可以被回收。可达性分析将对象分为两类：

- 垃圾回收的根对象（GC Root）
- 普通对象

对象与对象之间存在引用关系

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051243701.png" alt="image-20240705124332587" style="zoom:80%;" />

##### GC Root

哪些对象可以被称之为GC Root对象

- 线程Thread对象，引用线程栈帧中的方法参数、局部变量等
- 系统类加载器加载的java.lang.Class对象,引用类中的静态变量
- 监视器对象，用来保存同步锁synchronized关键字持有的对象
- 本地方法调用时使用的全局对象

### 五种对象引用

- 软引用
-  弱引用
- 虚引用
- 终结器引用

#### 软引用（SoftReference）

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051312384.png" alt="image-20240705131251284" style="zoom:80%;" />

 

![image-20240705145416087](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051454191.png)

接着 `bytes = null`,结束`bytes`与byte对象的**强引用**关系，只保留`softReference`与byte对象的**软引用**，当堆内存不足时，将尝试回收软引用中的对象,接着采用**队列机制**尝试将盒子`softReference`也进行回收

> ReferenceQueue<>()创建队列

![image-20240705150355550](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051503662.png)

##### 案例-缓存

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051506746.png" alt="image-20240705150624624" style="zoom:80%;" />

```java
// 继承实现软引用
class StudentRef extends SoftReference<Student>
// 构造器传入对象
public StudentRef(Student em,ReferenceQueue<Student> q){
   super(em,q);
}
```

#### 弱引用(WeakReference)

> 与软引用区别：
>
> 弱引用：不管堆内存够不够，都会直接被回收
>
> 软引用：只有当堆内存不够使，才尝试进行回收

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051520271.png" alt="image-20240705152049142" style="zoom:80%;" />

```java
byte[] bytes = new byte[1024*1024*100];//100m
WeakReference<byte[]> weakReference = new WeakReference<byte[]>(bytes);
bytes = null; //取消强引用，bytes-->堆内存byte对象地址
sout(weakReference.get()); // 有数据
System.gc(); //请求虚拟机垃圾回收，不可达对象
sout(weakReference.get()); // null
```

#### 虚引用与终结器引用

![image-20240705152637051](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051526170.png)

### 垃圾回收算法

1. 找到内存中存活的对象
2. 释放不再存活的对象，优化空间

> Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要==停止所有的用户线程==。这个过程称之为Stop The World 简称`STW`，如果STW时间过长则会影响用户的使用

#### 评价标准

1. **吞吐量**：执行用户代码的时间/（执行用户代码的时间+GC时间）。吞吐量越高，垃圾回收效率越高
2. **最大暂停时间**：垃圾回收过程中`STW`时间的最大值
3. **堆使用效率**：不同垃圾回收算法，对堆内存的使用方式是不同的

> 上述三种评价标准不可兼得。
>
> 一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就退降低吞吐量
>
> **不同垃圾回收算法，适用于不同的场景**



#### 标记清除算法(Mark-Sweep)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051554199.png" alt="image-20240705155456067" style="zoom:80%;" />



<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051555781.png" alt="image-20240705155553634" style="zoom: 80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051556268.png" alt="image-20240705155626139" style="zoom:80%;" />

#### 复制算法

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051557659.png" alt="image-20240705155737535" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051558906.png" alt="image-20240705155805776" style="zoom:80%;" />

#### 标记整理算法(Mark-Compact)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051558006.png" alt="image-20240705155855854" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051559558.png" alt="image-20240705155915434" style="zoom:80%;" />

#### 分代GC算法（优秀）

> 将上述的垃圾回收算法组合进行使用。分代垃圾回收将整个内存区域划分为**年轻代（新生代）**和**老年代**
>
> 年轻代（新生代）中三部分默认比值为 **伊甸园区：s0（幸存区）：s1 = 8:1:1**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051603753.png" alt="image-20240705160334624" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051605881.png" alt="image-20240705160547746" style="zoom: 67%;" />

##### 执行流程

![image-20240705162832000](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051628144.png)

> **进行Minor GC 垃圾回收后，将From 和To 标签进行交换，且每次Minor GC 后都会为对象记录他的年龄，初始值为0，每次GC完加1**

![image-20240705163315705](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051633848.png)

> 老年代满时，首先尝试Minor GC，是因为，放入到老年代的对象可能没有达到年龄阈值15，而是因为新生代满了才不断往老年代中添加

### 垃圾回收器

![image-20240705163920619](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051639761.png)

![image-20240705164127635](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051641770.png)

![image-20240705164304894](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051643036.png)

#### 组合1

##### 年轻代-Serial

![image-20240705165638567](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051656703.png)

##### 老年代-SerialOld

![image-20240705165710198](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051657355.png)

#### 组合2

##### 年轻代-ParNew

![image-20240705165946911](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051659050.png)

##### 老年代-CMS

![image-20240705170128477](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051701625.png)

#### 组合3

##### 年轻代-Parallel Scavenge

![image-20240705170243022](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051702158.png)

##### 老年代-Parallel Old

![image-20240705170309387](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051703520.png)

#### G1垃圾回收器（建议）

> JDK9之后默认的垃圾回收器是G1（Garbage First）
>
> Paraller Scavenge 关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代可用空间的大小
>
> CMD 关注暂停时间，但是吞吐量会下降
>
> 而 G1 设计目标是将上述两种垃圾回收器的优点融合：
>
> 1. 支持巨大的堆空间回收，并有较高的吞吐量
> 2. 支持多CPU并行垃圾回收
> 3. 允许用户设置最大暂停时间

##### 内存结构

![image-20240705170937719](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051709858.png)

##### 年轻代回收（Young GC）

![image-20240705171111663](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051711761.png)

###### 执行流程

1. 新创建的对象会存放在Eden区。当G1判断年轻代不足（max默认60%），无法分配对象，需要垃圾回收时会执行 `Young GC`
2. 标记出`Eden`和`Survivor`区域中的存活对象
3. 根据配置的最大暂停时间**选择某些区域**将存活对象复制到一个新的`Survivor`区中（年龄+1），同时清空这些区域
4. 后续 `Young GC`时与之前相同，只不过`Survivor`区中存活对象会被搬运到另一个`Survivor`区
5. 当某个存活对象的年龄到达阈值（默认15），将被放入老年代
6. 部分对象如果大小超过`Region`的一半，会直接放入老年代，这类老年代被称为`Humongous`区。比如堆内存4G，每个`Region` 2M,只要一个大对象超过了1M，就被放入`Humongous`区，如果对象过大，会横跨多个`Region`
7. 多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时(-XX:InitiatingHeapOccupancyPercent默认45%)会触发混合回收`Mixed GC`。回收所有年轻代和部分老年代的对象以及大对象去。采用复制算法来完成

![image-20240705181617688](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051816796.png)

##### 混合回收（Mixed GC）

![image-20240705182912142](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051829301.png)

![image-20240705183029583](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051830723.png)

> 如果清理过程中，没有足够的空Region存放转移的对象，会出现Full GC。单线程标记-整理算法，此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间

##### Garbage First

![image-20240705183301703](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051833840.png)

#### 总结

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051836862.png" alt="image-20240705183659713" style="zoom: 50%;" />

## 总结

### 1.Java中有那几块内存需要进行垃圾回收？

对于线程不共享的部分，会随着线程的生命周期而回收，不需要进行垃圾回收

对于方法区，一般不需要回收，**JSP**等技术会通过回收类加载器去回收方法区中的类

对于堆，由垃圾回收器负责进行回收

![image-20240705184429745](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407051844878.png)

### 2.常见的引用类型

- 强引用：最常见的引用方式吗，由可达性分析算法来判断
- 软引用：对象在没有强引用的情况下，内存不足时会回收
- 弱引用：对象在没有强引用的情况下，会直接回收
- 虚引用：通过虚引用知道对象被回收了
- 终结器引用：对象回收时可以自救，不建议使用

### 3.常见的垃圾回收算法

- 标记-清除算法：标记之后再请清除，容易产生内存碎片
- 复制算法：从一块区域复制到另一块区域，容易造成只使用一部分内存
- 标记-整理算法：标记之后，将存活的对象推到一边，对象会移动，效率不高
- 分代GC：将内存区域划分为年轻代，幸存者区，老年代进行垃圾回收，可以使用多重回收算法

### 4.常见的垃圾回收器

Serial+SerialOld：单线程回收，主要适用于单核CPU场景

ParNew+CMS：暂停时间较短，适用于大型互联网应用中与用户交互的部分

Paraller Scavenge+ Paraller Old：吞吐量高，适用于后台大量数据操作

G1：适用于较大的堆，具有可控的暂停时间
