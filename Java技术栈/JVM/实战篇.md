# 内存调优

## 内存溢出和内存泄漏

- 内存泄漏（memory leak）：在Java中如果不再使用一个对象，但是该对象依然在GC Root的引用链上，这个对象就不会被垃圾回收器回收，这种情况就称之为**内存泄漏**。内存泄漏一般都是由堆内存泄漏导致。
- 内存溢出（memory overflow）：当发生持续的内存泄漏，就像滚雪球，不管多大的内存迟早会被消耗完，最终导致的结果就是**内存溢出**。**但是产生内存溢出的并不是只有内存泄漏这一种原因**

### 模拟内存溢出

> 由于**JDK 9** 以后是默认采用的**G1 垃圾回收器**，为了方便模拟，以下采用==JDK8==(年轻代：Paraller Scavenge复制算法，老年代：Mark Sweap 标志-清除/整理算法)演示

先启动项目，同时命令行 `java -jar arthas-boot.jar`启动Arthas，在arthas中输入运行的项目的编号 3,进入项目arthas，`dashboard -i 1000`每个1000ms刷新， 观察内存情况

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407052007541.png" alt="image-20240705200725446" style="zoom:67%;" />

需要在-**编辑配置-添加虚拟机选项设置堆内存(-Xms10g -Xmx10g)**

```java
public class Outer {
    private byte[] bytes = new byte[1024 * 1024]; // 外部类持有的数据
    private static String name = "测试";
    // 内部类
    class Inner {
        private String name;
        public Inner() {
            this.name = Outer.name;
        }
    }

    public static void main(String[] args) throws IOException {
        System.in.read();
        int count = 0;
        ArrayList<Inner> inners = new ArrayList<>();
        while (true) {
            System.out.println(++count);
            // 形成强引用
            inners.add(new Outer().new Inner());
        }
    }
}

```

**内存溢出现象**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407052041228.png" alt="image-20240705204157124" style="zoom:67%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407052042509.png" alt="image-20240705204220424" style="zoom:67%;" />

### 内存泄漏的场景

#### 场景一

![image-20240705210413102](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407052104175.png)

```java
// 设置虚拟机堆内存 -Xms1g -Xmx1g
private Map<Long,Object> userCache = new HashMap<>();
@GetMapping("/login")
public void login(Long id){
   userCache.put(id,new byte[1024*1024*300]);
}
@GetMapping("/logout")
public void logout(Long id){
   userCache.remove(id);
}
// 当多个用户只登录不退出时，存储的userCache将超出堆内存上限，内存溢出
```



#### 场景二

![image-20240705210446467](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407052104544.png)

```java
// 启动类添加 @EnableScheduling
@component
public class LeakTask{
   private int count = 0;
   private List<Object> list = new ArrayList<>();
   @Scheduled(fixedRate=100L)
   public void test(){
      System.out.println("定时任务调用"+ ++count);
      list.add(new Outer().newList());
   }
}
```

## 解决内存溢出的方法

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407052116010.png" alt="image-20240705211643914" style="zoom: 67%;" />

### 发现问题

#### Top命令（linux）

![image-20240705213357818](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407052133936.png)

#### VisualVM 工具

1. [下载地址](https://visualvm.github.io/)  双击`/bin/visualvm.exe` 启动

> **报错  cannot find jdk 1.8 or higher ！**
>
> 修改 `/etc/visualvm.conf`  制定jdk安装目录
>
> ```java
> visualvm_jdkhome="D:\JDK\JDK21.0.3"
> ```

![image-20240706130903818](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407061309934.png)

2. IDEA 下载插件 **VisualVM Lanucher**，在设置中指定visualvm安装路径![image-20240706132509490](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407061325549.png)
2. 启动**VisualVM**后，出现警告 **Cannot open requested application** ,无需理会

#### Arthas 工具

![image-20240706132903089](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407061329200.png)

##### 案例

使用阿里`Arthas tunnel` 管理所有需要监控的程序

![image-20240706141757275](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407061417354.png)

1. 引入依赖,配置文件

   ```xml
   <dependency>
       <groupId>com.taobao.arthas</groupId>
       <artifactId>arthas-spring-boot-starter</artifactId>
       <version>3.7.2</version>
   </dependency>
   ```

   ```yaml
   arthas:
   	tunner-server: ws://localhost:7777/ws
   	app-name: ${spring.application.name}
   	http-port: 8888
   	telnet-port: 9999
   ```
   
   

#### Prometheus + Grafana

![image-20240706231145040](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407062311165.png)

#### 堆内存状况对比

![image-20240707143141304](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071431440.png)

![image-20240707143315576](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071433700.png)

### 内存泄漏的原因

#### 代码中的内存泄漏

![image-20240707143645159](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071436252.png)

##### 1. 不正确的equals()和hashCode()

`Student.java`

```java
@Getter
@Setter
// 未正确重写 equals()，和hashCode()
public class Student {
    private Integer id;
    private String name;
    private byte[] bytes = new byte[1024];
}
```

`Demo01.java`

```java
public class demo01 {
    static long count = 0;
    static HashMap<Student, Long> map = new HashMap<>();
    public static void main(String[] args) throws InterruptedException {
        while (true){
             if(count++%100==0){
                 Thread.sleep(10);
             }
             Student student = new Student();
             student.setId(1);
             student.setName("张三");
             map.put(student,1L);
        }
    }
}
```

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071500009.png" alt="image-20240707150031897" style="zoom:50%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071500831.png" alt="image-20240707150052734" style="zoom:50%;" />

###### 解决方案

1. 在定义新实体时，始终重写equals()和hashCode()方法，lombok的`@Data`注解
2. 重写时一定要确定使用了唯一标识去区分不同的对象，比如用户的id等
3. HashMap使用时尽量使用编号id等数据作为key，不要将整个实体类对象作为key存放

##### 2. 内部类引用外部类

###### 问题

> 1. 非静态的内部类默认会持有外部类，尽管代码上不再使用外部类，所以如果有地方引用了这个非静态内部类，会导致外部类也被引用，垃圾回收时无法回收这个外部类
> 2. 匿名内部类对象如果在非静态方法中被创建，还持有调用者对象，垃圾回收时无法回收调用者

###### 情况一

虽然没用到 Outer对象，但Outer对象无法被释放

```java
public class Outer {
    private byte[] bytes = new byte[1024];
    private String name="测试";
    class Inner {
        private String name;

        public Inner() {
            this.name = Outer.this.name;
        }
    }
    public static void main(String[] args) throws IOException, InterruptedException {
        int count = 0;
        ArrayList<Inner> inners = new ArrayList<>();
        while (true) {
            if (count++ % 100 == 0) {
                Thread.sleep(10);
            }
            inners.add(new Outer().new Inner());
        }
    }
}
```

==修改完善==

```java
public class Outer {
    private byte[] bytes = new byte[1024];
    // 添加 static 
    private static String name="测试";
    static class Inner {
        private String name;

        public Inner() {
            this.name = Outer.name;
        }
    }
    public static void main(String[] args) throws IOException, InterruptedException {
        int count = 0;
        ArrayList<Inner> inners = new ArrayList<>();
        while (true) {
            if (count++ % 100 == 0) {
                Thread.sleep(10);
            }
            // 直接创建的Inner
            inners.add(new Inner());
        }
    }
}
```

###### 情况二

同样 Outer对象无法被释放，原因是在匿名内部类 `list`中 隐藏了 `this.this$0 = this$0`持有了Outer对象

```java
public class Outer {
    private byte[] bytes = new byte[1024 * 1024 * 100];
    public List<String> newList() {
        List<String> list = new ArrayList<String>() {{
            add("1");
            add("2");
        }};
        return list;
    }

    public static void main(String[] args) throws IOException {
        System.in.read();
        int count = 0;
        ArrayList<Object> objects = new ArrayList<>();
        while (true) {
            System.out.println(++count);
            objects.add(new Outer().newList());
        }
    }
}
```

==修改完善==

```java
public class Outer {
    private byte[] bytes = new byte[1024 * 1024 * 100];
    // 方法改为 static
    public static List<String> newList() {
        List<String> list = new ArrayList<String>() {{
            add("1");
            add("2");
        }};
        return list;
    }

    public static void main(String[] args) throws IOException {
        System.in.read();
        int count = 0;
        ArrayList<Object> objects = new ArrayList<>();
        while (true) {
            System.out.println(++count);
            objects.add(newList());
        }
    }
}
```

##### 3. ThreadLocal的使用

###### 问题

> 如果仅仅使用手动创建的线程，就算没有调用ThreadLocal的remoe方法清理数据，也不会产生内存泄漏，因为当线程被回收时，ThreadLocal也同样被回收。但是如果使用线程池就不一定了

`Demo01`

```java
public class Demo01{
   public static ThreadLocal<Object> threadLocal = new ThreadLocal<>();

   public static void main(String[] args){
      ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(Integer.MAX_VALUE,Integer.MAX_VALUE,0,TimeUnit.DAYS,new SynchronousQueue<>());
      int count = 0;
      while(true){
         System.out.println(++count);
         threadPoolExecutor.execute(()->{
            threadLocal.set(new byte[1024*1024]);
            // threadLocal.remove();
         });
         Thread.sleep(10);
      }
   }
}
```

###### 解决方案

线程方法执行完，一定要调用ThreadLocal的remove方法清理对象

##### 4. Stirng 的 intern()方法

###### 问题

> JDK6 中字符串常量池位于堆内存的Perm Gen永久代中，如果不同字符串的intern方法被大量调用，字符串常量池会不停的变大超过永久代内存上限之后就会产生内存溢出

###### 解决方案

1. 注意代码中的逻辑，尽量不要将随机生成的字符串加入字符串常量池
2. 增大永久代空间的大小，根据实际的测试/估算结果进行设置 -XX:MaxPermSize= 256M

##### 5. 通过静态字段保存对象

###### 问题

> 如果大量的数据在静态变量中被长期引用，数据就不会被释放，如果这些数据不再使用，就成为了内存泄漏

###### 解决方案

1. 尽量将对象长时间的保存在静态变量中，如果不再使用，必须将对象删除（比如在集合中）或者将静态变量设置为null
2. 使用单例模式时，尽量使用懒加载，而不是立即加载
3. Spring的Bean中不要长期存放大对象，如果是缓存用于提升性能，尽量设置过期时间定期失效

#### 并发请求问题

![image-20240707160009738](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071600910.png)

##### 模拟并发请求

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071602598.png" alt="image-20240707160212467" style="zoom:67%;" />

1. [Apache Jmeter下载 Binaries](https://jmeter.apache.org/download_jmeter.cgi) 打开 /bin/jmeter.bat 目录启动 Jmeter ，右键测试 添加线程组

   <img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071611782.png" alt="image-20240707161148672" style="zoom: 80%;" /><img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071612649.png" alt="image-20240707161221539" style="zoom:80%;" />

2. 右键线程组 添加http请求

   <img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071613506.png" alt="image-20240707161310398" style="zoom:80%;" /><img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071614378.png" alt="image-20240707161441260" style="zoom:80%;" />

3. 右键 线程组 添加聚合报告

   <img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071615954.png" alt="image-20240707161538840" style="zoom:80%;" />

4.  启动程序 设置堆内存 -Xmx1g

   ```java
   @GetMapping("/test")
   public void test1()throws InterruptedExceptino{
      byte[] bytes = new byte[1024*1024*100];//100m
      Thread.sleep(10*1000L);
   }
   ```

   

### 诊断

#### 内存快照

![image-20240707162329128](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071623303.png)

[MAT下载地址](https://eclipse.dev/mat/downloads.php)

#### MAT内存泄漏检测原理 - 支配树

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071633478.png" alt="image-20240707163315338" style="zoom: 67%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071634615.png" alt="image-20240707163403459" style="zoom:50%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071637177.png" alt="image-20240707163756003" style="zoom:50%;" />

#### 生成快照方式

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407071639464.png" alt="image-20240707163928320" style="zoom:50%;" />

方式一：PowerShell中 ` Get-Process java`查看java进程信息，根据**进程ID**使用 `jmap`命令获取内存快照

```bash
jmap -dump:live,format=b,file=E:/jmap.hprof 12880
```

方式二：终端启动**Arthas** ` java -jar arthas-boot.jar`，选择java进程，使用 `heapdump` 获取内存快照

```bash
## 还存活的对象
heapdump --live E:/arthas.hprof
```

使用**MAT**分析工具打开**hprof** 文件，启动方式选择 **Leak Suspects Report**

## 案例实战

### 快速入门

使用IDEA 自带的 **分析器**，在虚拟机添加选项 `-XX:+HeapDumpOnOutOfMemoryError`，当内存溢出时，将自动**生成快照** 于 当前项目根目录下的**. hprof文件**，使用 **分析器**打开快照，分析发生内存溢出的接口和方法

![image-20240707222650239](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407072226425.png)

![image-20240707222918029](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407072229166.png)

### 案例-查询大量数据

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407072020510.png" alt="image-20240707202054345" style="zoom:67%;" />

#### 解决思路

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407072032481.png" alt="image-20240707203208363" style="zoom: 67%;" />

1. 设置的虚拟机选项：

```bash
## 堆内存 最小值，最大值
-Xms512m -Xmx512m 
## 内存溢出时 生成内存快照
-XX:+HeapDumpOnOutOfMemoryError
## 内存快照存储地址，生成文件名
-XX:HeapDumpPath=E:/jvm.hprof
```

2. **模拟问题的发生**：使用JMeter对接口进行压力测试，发生内存溢出，生成内存快照
3. 使用**MAT** 打开内存快照 `jvm.hprof`，模式选择 **Leak Suspects Report**，生成内存检测报告
4. ==定位内存泄漏的方法==，在支配树中 选择 Retained Heap（深堆）倒序排序，查看有 `Thread`后缀标签的，点击展开，查找 `HandlerMethod`项，右键选择 **List object - wiht outgoing reference** ，查看当前对象引用的对象，查看 `description`栏，分析引发内存泄漏的是哪个**Controller**和**接口方法**
   1. <img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407072118792.png" alt="image-20240707211845673" style="zoom:67%;" />![image-20240707213357694](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407072134140.png)
5. ==定位内存泄漏对象==，在直方图中，Retained Heap（深堆）倒序排序，查找可能引发的内存泄漏的对象个数

#### 分析问题

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407072047518.png" alt="image-20240707204745369" style="zoom: 50%;" />

### 案例-ThreadLocal

> 当Contorller接口方法发生异常时，不会经过拦截器中的 postHandler()方法，所以不应该将ThreadLocal的remove放于postHandler()中，应该放在afterCompletion()中

![image-20240709101436361](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091014496.png)

### 案例-文章内容审核接口的内存溢出

#### 设计1

![image-20240709102126096](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091021266.png)

![image-20240709102143498](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091021621.png)

#### 设计2

![image-20240709103039707](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091030861.png)

![image-20240709103111671](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091031791.png)

#### 设计3

![image-20240709103013731](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091030889.png)

![image-20240709104016439](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091040578.png)

## 诊断和解决问题

![image-20240709104319554](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091043688.png)

### 在线定位问题

Arthas

![image-20240709104757476](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091047646.png)

## 总结

![image-20240709104842106](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091048239.png)

![image-20240709104854543](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091048671.png)

![image-20240709104905865](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407091049984.png)



# GC调优

