# Collection单列集合

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061734908.png" alt="img" style="zoom: 50%;" />

## List集合

> 有序（存取顺序），能重复，有索引

#### ArrayList

底层是数组结构

#### LinkedList

底层数据结构是双链表，查询慢，增删快，首位元素操作的速度极快



## Set集合

> 无序，不能重复，无索引

#### HashSet

无序，不重复，无索引

#### LinkedHashSet

==有序==，不重复，无索引

#### TreeSet

==可排序==，不重复，无索引

> HashSet(去重):
>
> 底层是哈希表，根据地址计算出的哈希值存储数组，当哈希值相等时，对比equals(两对象地址值，即==)，相等则不存，不相等，将新元素挂载老元素链表下
>
> 当链表长度＞8且数组长度＞64，则将超过长度的链表转换为红黑树
>
> **注意**:对于自定义类型对象，需要重写hashcode与equals，用属性值计算哈希值，用属性值做比较，而非地址值
>
> String，Integer等底层已重写



> LinkedHashSet(去重，有序)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061734909.jpeg" alt="img" style="zoom:50%;" />

> TreeSet（可排序）
>
> 底层基于红黑树，有默认排序规则，增删改查性能都比较好
>
> 如果是==自定义==类型，需要重写排序规则

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061734910.jpeg" alt="img" style="zoom:50%;" />

==方式一==：自然排序

JavaBean类实现Comparable接口，重写compareTo方法

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User implements Comparable<User> {
    private String name;
    private int age;

    /* 按照年龄升序 */
    @Override
    public int compareTo(User o) {
        return this.age-o.age;
    }
}
```

this:表示当前要添加的元素

o：表示已经在红黑树中存在的元素

返回值：

​	负数：认为要添加的元素小，排左边

​	整数：认为要添加的元素大，排右边

​	0：认为要添加的元素已经存在，舍弃

==方式二==：比较器排序

创建TreeSet对象的时候，传递比较器Comparator指定规则

```java
public class Main {
    public static void main(String[] args) {
        //lambda表达式写法
        TreeSet<String> ts = new TreeSet<>((o1,o2)-> {
            /*
             * o1表示当前要添加的元素
             * o2表示红黑树存在的元素
             *  */
            //按照长度排序
            int i = o1.length() - o2.length();
            //如果长度一样，默认排序
            i=i==0?o1.compareTo(o2):i;
            return i;
        });

        ts.add("c");
        ts.add("ab");
        ts.add("df");
        ts.add("qwer");
        System.out.println(ts);
    }
}
```

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061734911.jpeg" alt="img" style="zoom: 50%;" />



# Map双列集合

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061734912.jpeg" alt="img" style="zoom:50%;" />

## Map集合基本操作

1.put：添加元素

如果键不存在，则把键值对象放在map集合中，方法返回null

如果键存在，则会把原有的值覆盖，把被覆盖的值返回

2.remove：删除元素

根据键删除，值返回

3.containKey，containValue：

是否包含键，或者值

4.clear()：清空集合

5.isEmpty()：集合是否为空

6.size():集合长度

## Map的遍历方式

### 方式一：键找值

将所有的键，放在一个单列集合中,遍历单列集合，得到每一个键，获取对应的值

`Set<String> keys = map.keySet()`

```java
Map<String, String> map = new HashMap<>();
String put1 = map.put("key1", "value1");
String put2 = map.put("key2", "value2");
String put3 = map.put("key3", "value3");
//for增强遍历
for (String s : map.keySet()) {
    System.out.println(s + " " + map.get(s));
    
//Itreator迭代器遍历
Set<String> s = map.keySet();
Iterator<String> iterator = s.iterator();
while(iterator.hasNext()){
    String next = iterator.next();
    system.out.println(next+"-->"+map.get(next));
}

```

### 方式二：键值对

键值对对象：键=值：Entry

获取所有键值对对象

`Set<Map.Entry<String, String>> entries = map.entrySet();`

利用Entry的方法getKey()获取键和getValue获取值

```java
map.entrySet()
.forEach(entry -> System.out.println(entry.getKey() + " " + entry.getValue()));
```

### 方式三：lambda表达式

```java
map.forEach((key,value)-> System.out.println(key+"="+value));
```

## HashMap

> 底层是数组+链表+红黑树，哈希值根据map中的键计算

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061734913.jpeg" alt="img" style="zoom:50%;" />

==由键决定==，无序，不重复，无索引



### 练习：计算80名同学，统计投票A,B,C,D四个景点，求最大值

```java
public class Main {
    public static void main(String[] args) {
        //定义景点
        String [] arr = {"A","B","C","D"};
        Random random = new Random();
        //获取80次投票结果集合
        ArrayList<String> lists = new ArrayList<>();
        for (int i = 0; i < 80; i++) {
            int index = random.nextInt(arr.length);
            lists.add(arr[index]);
        }
        //将景点和次数统计到map集合中
        HashMap<String, Integer> map = new HashMap<>();
        for (String list : lists) {
            if (map.containsKey(list)) {
                //获取当前景点投票次数
                int count=map.get(list);
                count++;
                map.put(list, map.get(list) + 1);
            } else {
                map.put(list, 1);
            }
        }
        map.forEach((k, v) -> System.out.println("景点"+k +"次数:" + v));
        //求最大值
        int max = 0;
        for (Map.Entry<String, Integer> entries : map.entrySet()) {
            int count = entries.getValue();
            if (count > max) {
                max = count;
            }
        }
        System.out.println("最大值为："+max);
        //判断那个景点值与最大值相等
        for (Map.Entry<String, Integer> entries : map.entrySet()) {
            if(entries.getValue()==max){
                System.out.println("最大值为"+max+"的景点为:"+entries.getKey());
            }
        }
    }
}
```

## LinkedHashMap

==由键决定==，==有序==，不重复，无索引



## TreeMap

不重复，无索引，可排序

可排序：对==键==进行排序，默认按键从小到大