# 多线程

## 基本概念

==线程==：进程的单位

并发：在同一时刻，有多个指令在==单个==CPU上交替执行

==并行==：在同一时刻，有多个指令在==多个==CPU上同时执行

## 实现多线程

### 方式一：Thread

> 继承Thread类，重写run方法 、、--quote-text-color：#81888d
>
> 优势：可以直接使用Thread类中的方法

```java
MyThread mt = new MyThread();
mt.start();
```

### 方式二：Runnable

> 实现Runnable接口，重写run方法，通过Thread类构造启动
>
> 优势：扩展性强，可以继承其他父类

```java
MyRunnabler mr = new MyRunnable();
Thread thread = new Thread(mr);
thread.start();
```

### 方式三：Callable

> 实现Callable接口
>
> 优势：线程有返回值

`MyCallable.java`

```java
public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int i;
        for ( i = 0; i < 10; i++) {
            System.out.println("当前线程是:"+Thread.currentThread().getName());
        }
        return i;
    }
}
```

`Test.java`

```java
public class Test {
    private static final Logger log = Logger.getLogger(Test.class.getName());
    /*
     * 1.创建Callable接口的实现类，并实现call()方法，该方法将作为线程执行体，并且有返回值
     * 2.创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象call()方法的返回值
     * 3.使用FutureTask对象作为Thread对象的target创建并启动线程
     * 4.调用FutureTask对象的get()方法来获得子线程执行结束后的返回值
     */
    public static void main(String[] args) {
        MyCallable call = new MyCallable();
        FutureTask<Integer> ft = new FutureTask<>(call);
        Thread t = new Thread(ft,"我是ft线程");
        for (int i = 0; i < 3; i++) {
            System.out.println(Thread.currentThread().getName()+"当前线程");
            if(i==0){
                t.start();
            }
        }
        try{
            System.out.println("返回值："+ft.get());
        }catch (Exception e){
            log.info("异常信息："+e.getMessage());
        }
    }
}
```

==注意==：由于多线程抢占式cpu的机制，即使使用延时处理，但随机抢占cpu还是会导致同一个资源被同时争抢，所以需要锁，保证同一个资源同一时间只被一个线程占有

### 方式四：线程池

- 自定义线程池： ThreadPoolExecutor
- 线程池服务创建：ExecutorService

```java
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
   Runtime.getRuntime().availableProcessors(), // 核心线程数，可供 Java 虚拟机使用的处理器数
   Runtime.getRuntime().availableProcessors()*2, // 最大线程数
   1L,
   TimeUnit.SECONDS,
   new LinkedBlockingQueue<>(100));

for (int i = 0; i < 1000; i++) {
   Thread.sleep(10);
   threadPool.execute(() -> System.out.println(Thread.currentThread().getName()));
}
```



## 线程安全

### 1.synchronized对象（同步代码块）

> 三个进程同时抢票，通过synchronized锁，使每当有一个线程进入循环抢票时，锁被关闭，当此进程结束退出后，锁自动打开

`MyThread.java`

```java
public class MyThread extends Thread {
    //由于使用Thread继承，所以会有多个Thread对象，static保证多个对象共享同一个ticket
    static int ticket = 0;

    @Override
    public void run() {
        while (true) {
            //synchronized需要保证锁对象只有一个
            synchronized (MyThread.class) {
                if (ticket < 100) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                    ticket++;
                    System.out.println(getName() + "正在卖第" + ticket + "张票");
                }else{
                    break;
                }
            }

        }
    }
}
```

`Main.java`

```java
public class Main {
    public static void main(String[] args) {

        MyThread m1 = new MyThread();
        MyThread m2 = new MyThread();
        MyThread m3 = new MyThread();
        m1.setName("线程1");
        m2.setName("线程2");
        m3.setName("线程3");
        m1.start();
        m2.start();
        m3.start();
    }
}
```

### 2.synchronized方法（同步方法）

`MyRunnable.java`

```java
public class MyRunnable implements Runnable {
	int ticket = 0;
	@Override
	public void run() {
		while(true){
			if (method()) break;
		}
	}

	private synchronized boolean method() {
		if(ticket==100){
			return true;
		} else{
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			ticket++;
			System.out.println(Thread.currentThread().getName()+"正在卖第"+ticket+"张票！！！");
		}
		return false;
	}
}

```

`Main.java`

```java
public class Main {
   public static void main(String[] args) {
      MyRunnable mr = new MyRunnable();
      for (int i = 0; i < 3; i++) {
         new MyThread(mr,"线程" + i).start();
      }
      System.out.println("1");
   }
}
```

### 3.Lock锁实现同步

> 手动创建lock锁对象，进行上锁，解锁操作
>
> 解锁unlock需要保证执行，否则当ticket=100时，将不进行解锁操作。所以应该放在finally中

`MyThread.java`

```java
public class MyThread extends Thread {
    //static保证MyThread多个对象共享同一个ticket和lock
    static int ticket = 0;
    // 可重入锁
    static Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true) {
            lock.lock();
            try {
                if (ticket == 100) {
                    break;
                } else {
                    Thread.sleep(10);
                    ticket++;
                    System.out.println(Thread.currentThread().getName() + "正在卖第" + ticket + "张票");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }
    }
}
```

`Main.java`

```java
public class Main {
   public static void main(String[] args) {
      for (int i = 0; i < 3; i++) {
         new MyThread("线程" + i).start();
      }
   }
}
```

## 等待唤醒机制

### 方式一：等待唤醒机制

`Desk.java`

```java
public class Desk {
    // 0：没有面条 ，1 有面条
    // 使用int类型而非布尔，便于多线程扩展
    public static int foodFlag = 0;
    // 设置总需要制作，需要吃多少碗<面条>
    public static int count = 10;
    // 锁对象
    public static final Object lock = new Object();
}

```

`Cook.java`

```java
public class Cook extends Thread {
    @Override
    public void run() {
        /*
         * 1.循环
         * 2.同步代码块
         * 3.判断共享数据是否到了末尾
         *  */
        while (true) {
            synchronized (Desk.lock) {
                if (Desk.count == 0) {
                    break;
                } else {
                    // 判断桌子上是否有面条
                    if (Desk.foodFlag == 0) {
                        // 没有就等待，有就吃
                        try {
                            // 用锁对象调用wait，将锁对象和wait绑定
                            Desk.lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    } else {
                        Desk.count--;
                        System.out.println("吃货在吃面条，还能再吃" + Desk.count + "碗");
                        // 吃完之后，唤醒所有线程（厨师）继续做
                        Desk.lock.notifyAll();
                        // 修改桌子状态
                        Desk.foodFlag = 0;
                    }
                }
            }
        }
    }
}

```

`Foodie.java`

```java
public class Foodie extends Thread {
    @Override
    public void run() {
        /*
         * 1.循环
         * 2.同步代码块
         * 3.判断共享数据是否到了末尾
         *  */
        while (true) {
            synchronized (Desk.lock) {
                if (Desk.count == 0) {
                    break;
                } else {
                    // 判断桌子上是否有食物
                    // 有就等待
                    if (Desk.foodFlag == 1) {
                        try {
                            // 用锁对象调用wait，将锁对象和wait绑定
                            Desk.lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    } else {
                        //没有就制作
                        System.out.println("厨师做了一晚面条");
                        //修改桌子食物状态
                        Desk.foodFlag = 1;
                        // 唤醒所有线程（吃货）
                        Desk.lock.notifyAll();
                    }
                }
            }
        }
    }
}

```

`ThreadDemo`

```java
public class ThreadDemo {
    public static void main(String[] args) {
        Cook cook = new Cook();
        Foodie foodie = new Foodie();
        cook.setName("厨师");
        foodie.setName("吃货");
        cook.start();
        foodie.start();
    }
}

```

### 方式二：阻塞队列

> ArrayBlockingQueue   底层是数组，有界
>
> LinkedBlockingQueue 底层是链表，无界（int的最大值）

==注意==：1.需要使用同一个阻塞队列

  	 2.put和take底层实现有锁，不需要额外加锁

`Cook.java`

```java
public class Cook extends Thread {
    ArrayBlockingQueue<String> queue;
    public Cook(ArrayBlockingQueue<String> queue) {
        this.queue = queue;
    }
    @Override
    public void run() {
        while (true) {
            // 不断的放面条到阻塞队列中
            try {
                //put方法底层有锁
                queue.put("面条");
                System.out.println("厨师做了面条");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

        }
    }
}
```

 `Foodie.java`

```java
public class Foodie extends Thread {
    ArrayBlockingQueue<String> queue;
    public Foodie(ArrayBlockingQueue<String> queue) {
        this.queue = queue;
    }
    @Override
    public void run() {
        while (true) {
            // 不断的从阻塞队列获取面条
            try {
                // take底层有锁
                String food = queue.take();
                System.out.println(food);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

`ThreadDemo.java`

```java
public class ThreadDemo {
    public static void main(String[] args) {
        /*
         * 生产者和消费者必须使用同一个阻塞对垒
         * */
        ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<String>(10);
        Thread cook = new Thread(new Cook(queue), "厨师");
        Thread foodie = new Thread(new Foodie(queue), "顾客");
        cook.start();
        foodie.start();
    }
}
```

#  线程池

## 线程池的使用

- **newCachedThreadPool()** ：创建无上限线程池

- **newFixedThreadPool(int nThreads()** ：创建有上限线程池， newFixedThreadPool(5) 

- **newSingleThreadExecutor()** ：创建一个单线程化的线程池

- **newScheduledThreadPool(int corePoolSize)**： 创建一个支持定时及周期性任务执行的线程池

> 案例：
>
> 1-10随机排序，前5为恰好是1-5的概率
>
> 多线程执行优化速度 12s-->4s

`MultiTask.java`

```java
public class MultiTask {
    // 线程数为虚拟机支持的处理机数
    private static final int THREAD_COUNT = Runtime.getRuntime().availableProcessors();
    private static final ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);
    // 累计成功任务数
    private static final AtomicInteger count = new AtomicInteger(0);
    private static final List<Integer> sharedList = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
    // 每个线程执行的任务数
    private static final BigInteger NUMBER_PER = new BigInteger(String.valueOf(1000_000_00/THREAD_COUNT));

    static class Task implements Runnable {
        private final Random random = new Random();

        @Override
        public void run() {
            for (int i = 0; i < NUMBER_PER.longValue(); i++) {
                ArrayList<Integer> list = new ArrayList<>(sharedList);
                // 打乱集合 list，随机因子 random
                Collections.shuffle(list, random);
                boolean flag = false;
                // 判断前5位数 是否大于 5
                for (int j = 0; j < 5; j++) {
                    if (list.get(j) > 5) {
                        flag = true;
                        break;
                    }
                }
                if (!flag) {
                    // 累计数++
                    count.incrementAndGet();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        LocalTime start = LocalTime.now();
		  // 线程返回结果 集合
        List<Future<?>> futures = new ArrayList<>();
        for (int i = 0; i < THREAD_COUNT; i++) {
            Future<?> future = threadPool.submit(new Task());
            futures.add(future);
        }
		  // get(),只有当线程返回结果,也就是线程执行完毕，才可执行
        for (Future<?> future : futures) {
            future.get();
        }

        LocalTime end = LocalTime.now();
       
        System.out.println("执行成功次数=" + count.get());
        System.out.println("总执行次数=" + NUMBER_PER.longValue() * THREAD_COUNT);
        System.out.println("执行成功概率=" + new BigDecimal(count.get()).divide(new BigDecimal(NUMBER_PER.longValue() * THREAD_COUNT), 6, RoundingMode.HALF_UP));
        System.out.println("执行时间为:" + String.valueOf(Duration.between(start, end)).substring(2));

        threadPool.shutdown();
    }
}
```



## 线程池关闭

### shutdown

1. 不再接受新的任务提交
2. 在shutdowm()调用之前的任务会被执行下去，待执行的任务(等待队列)和正在执行的任务**都不会被取消，将继续执行**
3. 如果已经shutdown()了，再调用不会有其他影响

```java
private static void shutdown_test(){
ExecutorService threadPool = Executors.newSingleThreadExecutor();
   for(int i =1; i<=10; i++){
      System.out.println("第:"+i+"次提交");
      threadPool.execute(new Task(i));
      if(i==5){
         threadPool.shutdown();
      }
   }
}
```

​      

### shutdownNow

1. 不再接受新的任务提交
2. 尝试**停止所有正在执行的任务**
3. 待执行的任务会取消并**返回等待任务的列表**
4. 该方法返回时，这些等待的任务将从队列中清空

> 其中停止任务是通过 `interrupt`方法去终止正在执行的任务，因此无法响应 `interrupt`中断的任务可能不会被终止。所以，该方法是无法保证一定能终止任务的



### awaitTermination

> shutdown()和shutdownNow()两个方法都不会等待任务执行完毕
>
> awaitTermination带有超时参数：如果超时后任务仍然未执行完毕，也不再等待

1. 阻塞当前线程，等已提交和已执行的任务都执行完，解除阻塞
2. 当等待，超过设置的时间，检查线程池是否停止
   1. 如果执行完了，返回true
   2. 如果执行完之前超时了，返回false并解除阻塞

```java
// 返回等待时间内（4s），线程池中任务是否执行完毕
boolean isStop = threadPool.awaitTermination(4,TimeUnit.SECONDS);
```



## 线程池异常处理

1. 默认的submit ，异常被吞
2. submit返回值，并get()，可以捕获异常
3. 默认的execute，可以捕获异常

```java
@Slf4j
public class Demo04 {
    public static ExecutorService threadPool = Executors.newFixedThreadPool(2);

    public static void main(String[] args) {
        // defaultSubmit();
        // defaultSubmitAndGet();
        // defaultExecutor();
    }
    // 1. 默认调用submit，异常被吞
    private static void defaultSubmit() {
        try {
            // submit()会吞掉异常
            threadPool.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "\t" + "进入池中submit方法");
                for (int i = 1; i <= 10; i++) {
                    if (i == 3) {
                        int age = 100 / 0;
                    }
                    System.out.println("--come in executor:" + i);
                }
                System.out.println(Thread.currentThread().getName() + "\t" + "离开池中submit方法");
            });
        } catch (Exception e) {
            log.error(e.getMessage());
        } finally {
            threadPool.shutdown();
        }
    }


    //  2. submit执行后，如果get方法调用想要获得返回值，可以抛出异常
    //     get方法会阻塞，直到任务执行完毕，才会返回结果
    private static void defaultSubmitAndGet() {
        try {
            Future<?> result = threadPool.submit(() -> {
                System.out.println(Thread.currentThread().getName() + "\t" + "进入池中submit方法");
                int age = 20 / 0;
                System.out.println(Thread.currentThread().getName() + "\t" + "离开池中submit方法");
            });
            // 如果没有这一行异常会被吞
            result.get();
        } catch (Exception e) {
            log.error(e.getMessage());
        } finally {
            threadPool.shutdown();
        }
    }


    // 3. 默认调用executor，可以抛出异常
    private static void defaultExecutor() {
        try {
            threadPool.execute(() -> {
                System.out.println(Thread.currentThread().getName() + "\t" + "进入池中submit方法");
                int age = 20 / 0;
                System.out.println(Thread.currentThread().getName() + "\t" + "离开池中submit方法");
            });
        } catch (Exception e) {
            log.error(e.getMessage());
        } finally {
            threadPool.shutdown();
        }
    }
}
```



### 统一处理

为了提高线程池的通用性、复用性

在线程池中重写的aterExecute()方法，统一处理异常，即使默认的submit也可以进行异常的抛出

```java
   static ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
            Runtime.getRuntime().availableProcessors(),
            Runtime.getRuntime().availableProcessors() * 2,
            1L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(100)) {
        @Override
        protected void afterExecute(Runnable r, Throwable t) {
            // execute 运行
            if(t!=null){
                log.error(t.getMessage(),t);
            }
            // submit 运行
            if(t==null && r instanceof Future<?>){
                try{
                    Future<?> future = (Future<?>) r;
                    if(future.isDone()){
                        future.get();
                    }
                }catch (Exception e){
                    log.error(e.getMessage(),e);
                }
            }
        }
    };
```



## 百万下发批处理任务

### 准备线程池

> JUC : java.util.concurrent.ThreadPoolExecutor
>
> 
>
> Spring框架自带的线程池:
>
> Spring: org.springframework.scheduling.concurrent.ThreadPool==Task==Executor
>
> ThreadPoolTaskExecutor 是 Spring 提供的一个方便的线程池实现，用于异步执行任务或处理并发请求，在使用ThreadPoolTaskExecutor 作为Spring Bean 注册到容器后，Spring会负责在应用程序关闭时自动关闭所有注册的线程池，==所以不需要手动关闭==

`ThreadPoolProperties.java`

```java
@Data
@Component
@ConfigurationProperties(prefix="thread.pool")
public class ThreadPoolProperties{
   private int corePoolSize; // 核心线程池大小
   private int maxPoolSize; // 最大可创建的线程数
   private int queueCapacity; // 队列最大长度
   private int keepAliveSeconds; // 线程池维护线程所允许的空闲时间
}
```

`ThreadConfig.java`

```java
@Configuration
public class ThreadConfig{
   // 线程池配置
   @Resource
   private ThreadPoolProperties threadPoolProperties;

   @Bean
   public ThreadPoolTaskExecutor threadPoolTaskExecutor(){
      ThreadPoolTaskExecutor threadPool = new ThreadPoolTaskExecutor();
      // 设置 自定义线程池参数
      threadPool.setCorePoolSize(threadPoolProperties.getCorePoolSize());
      threadPool.setMaxPoolSize(threadPoolProperties.getMaxPoolSize());
      threadPool.setQueueCapacity(threadPoolProperties.getQueueCapacity());
      threadPool.setKeepAliveSeconds(threadPoolProperties.getKeepAliveSeconds());
      return threadPool;
   }
}
```

`application.yml`

```yml
# 核心线程数，可以用 Runtime.getRuntime().availableProcessors()获取虚拟机可支持的最大处理机数
thread:
	pool:
		corePoolSize: 8
		maxPoolSize: 16
		queueCapacity: 50
		keepAliveSeconds: 2
```

### 基本实现

`CouponService.java`

```java
@Slf4j
@Service
public class CouponServiceImpl implements CouponService {
    static final int COUPON_NUMBER = 50;
    @Resource
    private ThreadPoolTaskExecutor threadPool;

    /**
     * 下发50张优惠券
     */
    @Override
    public void batchCaskAction() {
        // 1. 模拟要下发的50张优惠券
        ArrayList<String> coupons = new ArrayList<>(COUPON_NUMBER);
        for (int i = 0; i < COUPON_NUMBER; i++) {
            coupons.add("优惠券--" + i);
        }
        // 2. 创建计数器，构造器参数为任务数量
        CountDownLatch countDownLatch = new CountDownLatch(coupons.size());

        long startTime = LocalTime.now().toNanoOfDay();
        try {
            // 3. 将优惠券集合逐条发送进线程池高并发处理
            coupons.forEach(coupon -> {
                threadPool.execute(() -> {
                    try {
                        // 4. 交给线程池处理的下发业务逻辑
                        System.out.println("发送成功:" + coupon);
                    } finally {
                        // 5. 发送一个少一个，计数器减一
                        countDownLatch.countDown();
                    }
                });
            });
            // 6. 阻塞，当前所有线程完成，计数器为0，方法才能继续向下走
            countDownLatch.await();
        } catch (Exception e) {
            log.error(e.getMessage());
        }
        long endTime = LocalTime.now().toNanoOfDay();
        System.out.printf("线程[%s]共耗时%s毫秒%n", Thread.currentThread().getName(), (endTime - startTime) / 1000000);

    }
}
```

## 异步编排和并行优化

```java
// 其中一个并行线程执行任务
CompletableFuture<Void> customerInfoFuture = CompletableFuture.runAsync(()->{
   customMinInfo.setCname(this.getCustomerName());
},threadPoolExecutor);
...
// 汇总三个线程并行执行任务，等待，最长耗时完成
CompletableFuture.allOf(customerInfoFuture,..,..).join();
```



