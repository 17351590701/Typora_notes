# CompletableFuture

==Future接口==（Future实现类）定义了操作**异步任务执行一些方法**，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务是否完毕等。可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂

## FutureTask

**特点**：

- 多线程
- 有返回：构造方法需要注入Callable
- 异步任务：为主线程开一个分支任务

**优点**：future+线程池异步多线程任务配合，能显著提高程序的执行效率

**缺点**：

- get() 阻塞，直到future返回结果
- isDone() 轮询 判断是否返回了结果，耗费更多cpu资源

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407132118877.png" alt="image-20240713211847834" style="zoom:67%;" />

```java
public class FutureTaskDemo {
    @SneakyThrows // 编译器忽略异常
    public static void main(String[] args){
        FutureTask<String> future = new FutureTask<>(new MyThread());
        Thread thread = new Thread(future, "t1");
        thread.start();
        while(true){
           if(futrue.isDone()){
              System.out.println(future.get());// get() 阻塞main线程
              break;
           }else{
              try{
                 TimeUnit.MILLISECONDS.sleep(500);
              }catch(InterruptedException e){
                 System.out.println("正在处理中，不要催");
              }
           }
        }
        System.out.println("main线程结束"); 
    }
}
class MyThread implements Callable<String>{
    @Override
    public String call() throws Exception {
        System.out.println("-------come in call");
        TimeUnit.SECOND.sleep(5);
        return "hello callable";
    }
}
```

## CompletableFuture（优化）

优点：

- 异步任务结束时，会自动回调某个对象的方法
- 主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行
- 异步任务出错时，会自动回调某个对象的方法

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407132215227.png" alt="image-20240713221559184" style="zoom:67%;" />

### 静态方法创建异步任务

尽量不要使用new来创建，因为它是不完善的。使用静态方法：

- 自动提交任务到线程池
- 简化异步编程
- 避免线程泄漏
- 利用默认线程池

![image-20240713224021433](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407132240488.png)

默认有线程池，也可以自己创建

==runAsync==：无返回值

```java
@Slf4j
public class CompletableFutureDemo {
   @SneakyThrows
   public static void main(String[] args) {
      ExecutorService threadPool = Executors.newFixedThreadPool(3);
      CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {
         //不传入线程池：ForkJoinPool.commonPool-worker-1 传入线程池：pool-1-thread-1
         System.out.println(Thread.currentThread().getName());
         try{
            TimeUnit.SECONDS.sleep(1);
         }catch (InterruptedException e){
            log.error(e.getMessage());
         }
      },threadPool);// 传入线程池
      // runnbale 无返回值 null
      System.out.println(completableFuture.get());
   }
}
```

==supplyAsync==：有返回值

```java
@Slf4j
public class CompletableFutureDemo {
    @SneakyThrows
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                log.error(e.getMessage());
            }
            return "hello supplyAsync";
        });
        System.out.println(completableFuture.get());
    }
}
```

### 减少阻塞和轮询

可以传入回调对象，当异步任务完成或发生异常时，自动调用回调对象的回调方法

> ==注意：==如果使用提供的**默认线程池**，主线程不要立刻结束，否则completableFuture线提供的默认线程池会跟随主线程立刻关闭，无法处理完上述任务

```java
@Slf4j
public class CompletableFutureDemo {
   @SneakyThrows
   public static void main(String[] args) {
      // ExecutorService executorService = Executors.newFixedThreadPool(3);
      CompletableFuture.supplyAsync(()->{
         System.out.println(Thread.currentThread().getName()+"-------come in");
         int result = ThreadLocalRandom.current().nextInt(10);
         try{
            TimeUnit.SECONDS.sleep(1);
         }catch (InterruptedException e){
            log.error(e.getMessage());
         }
         System.out.println("-----1秒钟后出结果："+result);
         return result;
      }).whenComplete((v,e)->{
         // 没有出现异常
         if(e==null){
            System.out.println("-----计算结果为："+v);
         }
      }).exceptionally(e->{
         //出现异常后处理
         log.error(e.getMessage());
         System.out.println("-----计算出现异常");
         return null;
      });
      System.out.println("-----main线程执行完毕");
      //延迟关闭主线程，等待异步完成
      try {
         TimeUnit.SECONDS.sleep(3);
      } catch (InterruptedException e) {
         log.error(e.getMessage());
      }
   }
}
```

### join()和get()对比

get()和join()几乎相同，区别在于，get()需要显示抛出异常，而join()可在编译时忽略抛出异常

## 案例-电商比价需求

需求：

1. 同一款产品，同时搜索出同款产品在各大电商平台的售价
2. 同一款产品，同时搜索出本产品在同一个电商平台下，不同卖家售价是多少

==需求实现==：

1. 卖家 店名，返回 输入商品随机价格

```java
@Getter
@RequiredArgsConstructor
class NetMall {
   private final String netMallName;
   @SneakyThrows
   public double calPrice(String productName) {
      try {
         TimeUnit.SECONDS.sleep(1);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
      return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0);
   }
}
```

2. 异步方法，同时获取3家店铺商品价格

```java
public static List<String> getPriceByCompletableFuture(List<NetMall> list, String productName) {
   return list
      .stream()
      .map(n -> CompletableFuture.supplyAsync(() ->
                                              String.format(productName + "in %s price is %.2f",
                                                            n.getNetMallName(),
                                                            n.calPrice(productName))))
      .toList()
      .stream()
      .map(CompletableFuture::join)
      .collect(Collectors.toList());
}
```

3. 测试

```java
public static void main(String[] args) {
   LocalTime start = LocalTime.now();
   List<String> list = getPriceByCompletableFuture(CompletableFutureMallDemo.list, "mysql");
   LocalTime end = LocalTime.now();
   for (String s : list) {
      log.info("商品：{}", s);
   }
   log.info("耗时：{} 毫秒", Duration.between(start, end).toMillis());
}
```

## 常用API

==函数式接口==

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407141317439.png" alt="image-20240714131706315" style="zoom:67%;" />

1. 获取结果和触发计算
   - T get（）：不见不散
   - T get（long timeout，TimeUnit unit）：过期不候
   - T join（）
   - T getNow（T valueIfAbsent）：没有计算完成的情况下，可以提供一个默认值
   - booean complete（T value）：返回是否打断了get/join方法，立即返回默认值

2. 对计算结果进行处理
   - thenApply（v->{}）：计算结果存在依赖关系，这两个线程串行化，有异常，直接叫停
   - handle（（v-e）->{}）：有异常，跳过当前，可以往下一步走，根据带的异常参数可以进一步处理

3. 对计算结果进行消费，无返回结果
   - thenRun（Runnable runnable）：任务A执行完执行B，并且B**不需要**A的结果
   - thenAccept（Consumer action）：任务A执行完执行B，B需要A的结果，且B**无返回值**
   - thenApply（Function fn）：任务A执行完执行B，B需要A的结果，且B**有返回值**

   - **后缀Async**的api与线程池关系：![image-20240714143834417](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407141440517.png)

4. 对计算速度进行选用

   - applyToEither：两个future结果，返回较快的那个的值

     ```java
     CompletableFuture<String> result = playA.applyToEither(playB,f->{
        return f + "is winner";
     })
     ```

5. 对计算结果进行合并

   - thenCombine：两个future，等待两个返回结果，并对其操作

     ```java
     CompletableFuture<Integer> result = future1.thenCombine(future2,(f1,f2)->{
        System.out.println("-----开始两个结果合并");
        return f1+f2;
     })
     ```

     

# Java 锁

## 乐观锁、悲观锁

### 悲观锁

认为自己在使用数据的时候，一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。

sychronized关键字和Lock的实现类都是悲观锁

### 乐观锁

认为自己在使用数据时，不会有别的线程来修改数据或资源，所以不会添加所

判断规则：

1. 版本号机制Version
2. 最常采用的是==CAS算法==（比较并交换），Java原子类中的递增操作就是CAS自旋实现的

## 锁的是什么

> 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法；能用对象锁，就不要用类锁

- 对于**普通同步方法**，锁的是当前实例对象，通常值`this`，进入同步代码前要获得当前实例的锁，**非同步方法**，由于不需要获取锁，所以正常运行
- 对于**静态同步方法**，锁的是当前的类Class，进入同步代码前获取当前类的锁
- 对于**同步方法块**：锁的是`synchronized`括号内的对象

==类锁和对象锁执行不互斥==

案例演示：

```java
// 资源类
class Phone{
   public static synchronized void sendEmail(){
      try{
         TimeUnit.SECOND.sleep(3);
      }catch(InterruptedException e){
         e.printStackTrace();
      }
      System.out.println("---------sendEmail")
   }
   public synchronized void sendSMS(){
      System.out.println("---------sendSMS")
   }
   publc void hello(){
      System.out.println("---------hello")
   }
}
// main方法
public class Demo {
   public static void main(String[] args) {
      Phone phone1= new Phone();
      new Thread(Phone::sendEmail,"A").start();
      new Thread(phone1::sendSMS,"B").start();
   }
}
```

## 公平锁、非公平锁

![image-20240714161702749](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407141617873.png)

### 为什么默认非公平锁

1. 恢复挂起的线程到真正锁的获取有时间差，使用非公平锁能更充分的利用CPU时间片，减少CPU空闲状态时间
2. 减少线程切换的开销，采用非公平锁时，当一个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率变得非常大，所以就减少了线程开销

## 可重入锁（递归锁）

指**同一个线程**在外层方法获取锁的时候，再次进入该线程的内层方法会**自动获取锁**（前提，锁对象时同一个），不会因为之前已经获取了锁因没释放而阻塞

ReentrantLock和synchronized都是可重入锁，一定程度避免死锁

## 死锁及排查

![image-20240714164536844](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407141645945.png)

### 排查

方式一：

```bash
jps -l # 获取当前程序的编号
jstack {id} # 查看栈信息
```

方式二：

`win+R` 输入 jconsole，线程--检测死锁

# LockSupport与线程中断

## 线程中断机制

### 什么是中断机制

==首先==

一个线程不应该由其他线程来强制中断或停止，而是应该由**线程自己自行停止**，所以，Thread.stop，Thread.suspend，Thread.resume都已经被废弃

==其次==

Java提供了一种用于停止线程的**协商机制**——中断，也即中断标识协商机制，Java中并没有给中断增加任何语法，中断过程完全由程序员自己实现，若要中断一个线程，你需要手动调用线程的`interrupt`方法，该方法也仅仅是将线程对象的中断标识设为`true`

### 中断API

![image-20240714171020307](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407141710438.png)

### 考点--案例

#### 如何中断运行中的线程？

##### 通过volaitle变量实现

- 可见性：当一个线程修改了一个由volatile修饰的共享变量后，其他线程能够立即看到这个修改  

```java
public class InterruptDemo {
    static volatile boolean isStop = false;

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            while (true) {
                if (isStop) {
                    System.out.println(Thread.currentThread().getName() + "\tisStop值被修改为true,程序停止");
                    break;
                }
                System.out.println("-------hello volatile");
            }
        }, "t1").start();

        TimeUnit.MILLISECONDS.sleep(20);

        new Thread(() -> {
            isStop = true;
        }, "t2").start();
    }

}
```

##### 通过AtomicBoolean

```java
public class InterruptDemo {
    static AtomicBoolean atomicBoolean = new AtomicBoolean(false);
   
    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            while (true) {
                if (atomicBoolean.get()) {
                    System.out.println(Thread.currentThread().getName() + "\tisStop值被修改为true,程序停止");
                    break;
                }
                System.out.println("-------hello AtomicBoolean");
            }
        }, "t1").start();

        TimeUnit.MILLISECONDS.sleep(20);

        new Thread(() -> {
            atomicBoolean.set(true);
        }, "t2").start();
    }
}
```

##### 通过Thread自带中断API

```java
public class InterruptDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            while (true) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println(Thread.currentThread().getName() + "\tisStop值被修改为true,程序停止");
                    break;
                }
                System.out.println("-------hello Interrupted");
            }
        }, "t1");
        t1.start();
       
        TimeUnit.MILLISECONDS.sleep(20);
       
        new Thread(t1::interrupt, "t2").start();
    }
```

#### 当前线程的中断标识为true，是否线程立刻停止？

![image-20240714191425777](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407141914914.png)

==重要：第二种情况==

> 解决：sleep方法抛出InterruptedException后，中断标识被清空置为false，我们在catch没有通过调用thread.interrupt()方法再次将中断标识置为true，这就导致无限循环了。所以在sleep方法抛出异常时，需要**再次将interrupt表示为置为true**

```java
public class InterruptDemo03 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            while (true) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println(Thread.currentThread().getName() + "\tisStop值被修改为true,程序停止");
                    break;
                }
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                }
                System.out.println("-------hello Interrupted");
            }
        }, "t1");
        t1.start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(t1::interrupt, "t2").start();
    }
}
```

#### 静态方法 Tread.interrupted()

![image-20240714193427083](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407141934194.png)

```java
public class InterruptDemo04 {
    public static void main(String[] args) throws InterruptedException {
        System.out.println(Thread.interrupted()); // false
        Thread.currentThread().interrupt(); // 中断标识置为 true
        System.out.println(Thread.interrupted()); // true
        System.out.println(Thread.interrupted()); //false
    }
}
```

##### 区别

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407141937690.png" alt="image-20240714193755557" style="zoom:67%;" />

## LockSupport是什么

## 等待唤醒机制

### 3种等待和唤醒方法

#### wait和notify

Object类中的wait和notify必须要放在同步块或者同步方法中，且成对出现使用，先wait后notify

```java
public class LockSupportDemo {
    public static void main(String[] args) throws InterruptedException {
        Object objectLock = new Object();
        new Thread(() -> {
            synchronized (objectLock) {
                System.out.println(Thread.currentThread().getName() + "\t" + "-------come in");

                try {
                    objectLock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println(Thread.currentThread().getName() + "\t" + "-------被唤醒");
            }
        }, "t1").start();
        // 1秒后唤醒
        TimeUnit.SECONDS.sleep(1);

        new Thread(() -> {
            synchronized (objectLock) {
                objectLock.notify();
                System.out.println(Thread.currentThread().getName() + "\t" + "-------发出通知");
            }
        }, "t2").start();
    }
}
```

#### await和signal

Condition接口中的await和signal必须要在 lock与unlock方法之间，需要先await后signal

```java
public class LockSupportDemo {
   public static void main(String[] args) throws InterruptedException {
      Lock lock = new ReentrantLock();
      Condition condition = lock.newCondition();

      new Thread(() -> {
         lock.lock();
         try {
            System.out.println(Thread.currentThread().getName() + "\t" + "-------come in");
            condition.await();
            System.out.println(Thread.currentThread().getName() + "\t" + "-------被唤醒");
         } catch (InterruptedException e) {
            e.printStackTrace();
         } finally {
            lock.unlock();
         }

      }, "t1").start();
      //1秒后唤醒
      TimeUnit.SECONDS.sleep(1);

      new Thread(() -> {
         lock.lock();
         try {
            condition.signal();
            System.out.println(Thread.currentThread().getName() + "\t" + "-------发出通知");
         } catch (Exception e) {
            throw new RuntimeException(e);
         } finally {
            lock.unlock();
         }
      }, "t2").start();
   }
}
```

#### park和unpark

> 上述两种方法存在限制条件：线程要获得并持有锁，必须在锁块（synchronized或lock）中，必须要先等待后唤醒，线程才能被正常唤醒

- 无锁块要求
- 无等待、唤醒顺序要求
- park、unpark需要成对，且park添加的凭证最多只能持有一个

```java
public class LockSupportDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t" + "-------come in");
            LockSupport.park();
            System.out.println(Thread.currentThread().getName() + "\t" + "-------被唤醒");
        }, "t1");
        t1.start();
        // 1秒后唤醒 
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            LockSupport.unpark(t1);
            System.out.println(Thread.currentThread().getName() + "\t" + "-------发出通知");
        },"t2").start();
    }
}
```

# Java内存模型之JMM

![image-20240714202952218](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142029451.png)

## 三大特性

可见性、原子性、有序性

## 多线程对变量的读写过程

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142129898.png" alt="image-20240714212959713" style="zoom: 50%;" />

![image-20240714213148988](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142131126.png)

## 多线程先行发生原则之happens-before

### 总原则

![image-20240714213658562](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142136688.png)

## 八条原则

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142143147.png" alt="image-20240714214321954" style="zoom: 50%;" />

# Volatile与JMM

## 被volatile修饰的变量

### 特点

- 可见性
- 有序性

### 内存语义

![image-20240714214629564](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142146717.png)

## 内存屏障（重点）

### 是什么

![image-20240714220458962](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142204118.png)

![image-20240714220515611](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142205791.png)

### 内存屏障分类

- 读屏障：在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据
- 写屏障：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中

![image-20240714221359721](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407142213891.png)

### Volatile特性

#### 保证可见性

保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见 

```java
@Data //.cm-s-inner .cm-meta
public class Demo02 {
   // volatile 修饰 保证t1线程能读取到主线程修改的flag值false
   static volatile boolean flag = true;

   @Sneakthrow
   public static void main(String[] args) {
      new Thread(() -> {
         while (flag) {

         }
      },"t1").start();
      try {
         Thread.sleep(1000);
      } catch (InterruptedException e) {
         throw new RuntimeException(e);
      }
      flag = false;
      System.out.println("flag=" + flag);
   }
}
```

#### 没有原子性

 ![image-20240715215407977](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152154196.png)

#### 指令禁重排

重排序：编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序，不存在数据依赖关系，可以重排序。**存在数据依赖关系，禁止重排序**

案例：**不存在**数据依赖关系

![image-20240715220003720](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152200893.png)

##### volatile有关禁止指令重排的行为

![image-20240715220116542](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152201711.png)

##### volatile与内存屏障

![image-20240715220323671](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152203809.png)

# CAS

## 原子类

java.util.concurrent.atomic

AtomicInteger、AtomicBoolean、AtomicLong...等等

## 没有CAS之前

读多写少的情况下

```java
public class Demo{
   volatile int number = 0;
   // 可见读
   public int getNumber(){
      return number;
   }
   // 加锁写
   public synchronized void setNumber(){
      number++;
   }
}
```

## 使用CAS之后

```java
public class Demo{
   AtimoicInteger number = new AtomicInteger(0);
   public int getNumber(){
      return number.get();
   }
   public void setNumber(){
      number.addAndGet(1);
   }
}
```

## CAS是什么

==乐观锁==

![image-20240715222740116](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152227343.png)

```java
public class Demo{
   AtomicInteger number = new AtomicInteger(0);
   public static void main(Sting[] args){
      // 预期值如果为1，就将number改变为3
      number.compareAndExchange(1,3);
   }
}
```

## CAS底层原理与Unsafe类

Unsafe类是CAS的核心类，CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性

![image-20240715224525792](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152245983.png)

![image-20240715224439498](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152244655.png)

### 原码分析getAndIncrement()

**getAndIncrement()  ==》 getAndAddInt(this,valueoffset,1) ==》compareAndSwapInt**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152250455.png" alt="image-20240715225053337" style="zoom:70%;float:left" />

![image-20240715225153309](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152251487.png)

![image-20240715224827318](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152248517.png)

## 原子引用

**AtomicReference<?>**

```java
@Data // 主要是重写toSting()方法，是atomicReference打印的不是user地址而是具体值
@AllArgsConstructor
class User{
    String userName;
    int age;
}
public class Demo01 {
static AtomicReference<User> atomicReference = new AtomicReference<>();
    public static void main(String[] args) {
        User zhangsan = new User("张三", 18);
        User lisi = new User("李四",19);
        atomicReference.set(zhangsan);
        // true     User(userName=李四, age=19)
        System.out.println(atomicReference.compareAndSet(zhangsan,lisi)+"\t"+atomicReference.get().toString());
        // false	User(userName=李四, age=19)
        System.out.println(atomicReference.compareAndSet(zhangsan,lisi)+"\t"+atomicReference.get().toString());

    }
}
```

## ==CAS与自旋锁（重要）==

![image-20240715232500913](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152325088.png)

## 实现一个自旋锁

题目：实现一个自旋锁，复习CAS思想

自旋锁好处：循环比较获取没有类似wait的阻塞

通过CAS操作完成自旋锁，A线程先进来调用mylcok方法自己持有锁5秒，B随后进来发现当前有线程持有锁，所以只能通过自旋等待，知道A释放锁后B随后抢到

```java
public class SpinLockDemo {
    AtomicReference<Thread> atomicReference = new AtomicReference<>();

    // 上锁方法
    public void lock() {
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName() + " 获取锁");
        // 将不停判断锁是否被占用，如果被占用则一直循环
        while (!atomicReference.compareAndSet(null, thread)) {

        }
    }

    // 解锁方法
    public void unlock() {
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread, null);
        System.out.println(thread.getName() + " 释放锁");
    }

    @SneakyThrows
    public static void main(String[] args) {
        SpinLockDemo spinLockDemo = new SpinLockDemo();
        new Thread(() -> {
            spinLockDemo.lock();
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            spinLockDemo.unlock();
        }, "A").start();
        // 暂停500毫秒，线程A先于B启动
        Thread.sleep(500);
        new Thread(() -> {
            spinLockDemo.lock();
            spinLockDemo.unlock();
        }, "B").start();
    }
}
```

## CAS缺点

- 循环时间长，开销大![image-20240715234038786](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152340938.png)

- ABA问题![image-20240715234218659](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407152342818.png)

### ABA问题

#### 版本号时间戳原子引用

**AtomicStampedReference**，（引用，流水版本号）的方式，即使开始与结束的引用相同，但由于版本号的改变，而解决ABA问题

==单线程环境==

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
class Book {
    private int id;
    private String bookName;
}

public class AtomicStampedDemo {
    public static void main(String[] args) {
        Book javaBook = new Book(1, "javaBook");
        // A
        AtomicStampedReference<Book> stampedReference = new AtomicStampedReference<>(javaBook, 1);
        System.out.println(stampedReference.getReference() + "\t" + stampedReference.getStamp());
        Book mysqlBook = new Book(2, "mysqlBook");
        // B 如果期望值是“javaBook”，就替换成“mysqlBook”，并把版本号+1
        boolean b = stampedReference.compareAndSet(javaBook, mysqlBook, stampedReference.getStamp(), stampedReference.getStamp() + 1);
        System.out.println(b + "\t" + stampedReference.getReference() + "\t" + stampedReference.getStamp());
        // A ,ABA问题，由于流水版本号上体现，被解决
        b = stampedReference.compareAndSet(mysqlBook, javaBook, stampedReference.getStamp(), stampedReference.getStamp() + 1);
        System.out.println(b + "\t" + stampedReference.getReference() + "\t" + stampedReference.getStamp());
    }
}
```

输出结果：

Book(id=1, bookName=javaBook)	1
true	Book(id=2, bookName=mysqlBook)	2
true	Book(id=2, bookName=mysqlBook)	3

==多线程环境==

```java

```

