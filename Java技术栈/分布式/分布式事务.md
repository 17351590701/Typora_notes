# 基本理论

## 基础概念

- 本地事务：数据库事务
	-  A（Atomic）：原子性
	- C（Consistency）：一致性
	- I（Isolation）：隔离性
	- D（Durability）：持久性
- 分布式事务：跨JVM进程
	- 典型微服务
	- 单体系统访问多个数据库实例
	- 多个服务访问同一个数据库实例

## 基础理论

### 理解CAP理论

==C-Consistency==
	一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意节点读取数据都是最新的状态。

分布式系统一致性的特点：

1. 由于存在数据同步的过程，写操作的响应会有一定的延迟

2. 为了保证数据的一致性会对资源暂时锁定，待数据同步完成释放锁定资源
2. 如果请求数据同步失败的节点则会返回错误信息，一定不会返回旧数据

==A-Availability==

​	可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误

==P-Partition tolerance==

​	通常分布式系统的各个节点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致节点间的通信失败，此时仍可对外提供服务，这叫分区容忍性

### CAP组合方式

在所有分布式事务场景中不会同时具备CAP三个特性，因为在具备了P的前提下C和A是不能共存的

- CP
- AP

### BASE理论

- 基本可用

- 软状态

- 最终一致性

## 2PC（两阶段提交）

### 什么是2PC

**2PC即两阶段提交协议**，是将整个事务流程分为两个阶段，准备阶段（Prepare phase），提交阶段（Commit phase），2是指两个阶段，P是指准备阶段，C是指提交阶段。

Oracle、Mysql都支持2PC协议

1. 准备阶段（Prepare phase）：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交

   > Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件

2. 提交阶段（Commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理中使用的锁资源。**注意：必须在最后阶段释放锁资源**

### 解决方案

#### XA方案

传统的，基于关系型数据库实现

![image-20240731111010541](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407311110657.png)

![image-20240731111030129](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407311110205.png)

#### Seata方案

[Seata参考文献](https://blog.csdn.net/pi_tiger/article/details/131110412)

![image-20240731111509451](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407311115518.png)

![image-20240731111821710](C:/Users/35747/AppData/Roaming/Typora/typora-user-images/image-20240731111821710.png)

# SEATA

[官网文档](https://seata.apache.org/zh-cn/docs/user/quickstart/)

## Seata事务模式

![image-20240801100244394](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202408011003103.png)

Seata定义了全局事务的框架

全局事务定义若干分支事务的整体协调：

1. TM向TC 发起、提交、回滚去全局事务
2. TM把代表当前全局事务的XID绑定到各个分支事务上
3. RM向TC注册，把分支事务关联到XID代表的全局事务中
4. RM把分支事务的执行结果上报给TC
5. TC发送分支提交或分支回滚命令给RM

![image-20240731231834697](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407312318809.png)

Seata全局的事务处理过程、分为两个阶段：

- 执行阶段：执行分支事务，并保证执行结果满足是可回滚（ROllback）的和可持久（Durable）
- 完成阶段：根据执行阶段结果形成的决议，应用通过TM发出的全局事务提交或回滚的请求给TC，TC命令RM驱动分支事务进行Commit或Rollback

### AT模式

- 执行阶段：
  - 可回滚：根据SQL解析结果，记录回滚日志
  - 持久化：回滚日志和业务SQL在同一个本地事务中提交到数据库
- 完成阶段：
  - 分支提交：==自动==异步删除回滚日志记录
  - 分支回滚：==自动==依据回滚日志（undo_log）进行反向补偿更新

![image-20240731232250933](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407312330220.png)

### XA模式

在Seata定义的分布式事务内，利用事务资源对XA协议的支持，以XA协议的机制来管理分支事务的一种事务模式

![image-20240731233307139](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407312333267.png)

- 执行阶段：
  - 可回滚：业务SQL操作就在XA分支中进行，资源对XA协议的支持来保证可回滚
  - 持久化：XA分支完成后，执行XA prepare，同样，由资源对XA协议的支持来保证持久化（即，之后任何意外都不会造成无法回滚的情况）
- 完成阶段：
  - 分支提交：执行XA分支的commit
  - 分支回滚：执行XA分支的rollback

#### 为什么要在Seata中支持XA

Seata中的3大事务模式：AT、TCC、Saga都是补偿型的

补偿型事务处理机制构建在事务中间件之上，事务资源本身对分布式事务是无感知的

虽然保证了最终一致性，但无法做到真正的全局统一，存在中间状态（中途可能读到脏数据）

#### XA的价值

- 全局一致性
- 业务无侵入
- 数据库的支持广泛
- 多语言支持容易
- 传统基于XA应用的迁移


## Seata的安装和部署

1. 以下为==seata-1.7.0==（2.0未成功）版本设置，[下载事务协调器（Seata服务端）](https://github.com/apache/incubator-seata/releases)

2. 创建数据库，`seata`数据库运行目录F:\seata-server-2.0.0\seata\script\server\db下的`mysql.sql`文件创建seata数据库

3. 修改配置文件，打开F:\seata-server-2.0.0\seata\script\config-center的`config.txt`文件修改

   ```shell
   #默认为file，修改为db
   store.mode=db
   store.lock.mode=db
   store.session.mode=db
   
   #指定seata数据库,mysql8.0以上Driver需要cj
   store.db.driverClassName=com.mysql.cj.jdbc.Driver
   #主要需要添加&useSSL=false
   store.db.url=jdbc:mysql://127.0.0.1:3306/seata？useUnicode=true&rewriteBatchedStatements=true&useSSL=false
   store.db.user=root
   store.db.password=123456
   
   #事务分组,如果修改，后续需要一致
   #service.vgroupMapping.mygroup=default
   service.vgroupMapping.default_tx_group=default
   service.default.grouplist=127.0.0.1:8091
   service.enableDegrade=false
   ```

4. 将seata注册到Nacos

   1. nacos新建命名空间

   2. 将`config.txt`信息注册到Nacos，进入seata目录，找到目录F:\seata-server-2.0.0\seata\script\config-center\nacos下的`nacos-config.sh`，进入`git bash`窗口，运行以下命令

      ```bash
      sh nacos-config.sh -h nacos服务地址 -p 端口 -g SEATA_GROUP（默认） -t 命名空间id -u 用户名 -w 密码
      
      ##案例
      sh nacos-config.sh -h 127.0.0.1 -p 8848 -g SEATA_GROUP -t 5f1da9de-cd0a-42a7-b9e8-9420a2798735 -u nacos -w nacos
      ```

   3. 查看nacos命名空间SEATA配置列表，103条

5. 修改seata配置文件，进入目录seata/conf，有两个配置文件，把application.yml 随意修改一个名字，然后把 application.example.yml修改成application.yml 作为主要配置文件

   1. 将**原application.yml**的console和security配置复制到新application.yml中，注意security需要放在seata：下，注意缩进

   2. 修改seata部分

      ```yml
      seata:
        config:
          # support: nacos 、 consul 、 apollo 、 zk  、 etcd3
          type: nacos
          nacos:
            server-addr: 127.0.0.1:8848
            namespace: 3ae09240-7a62-41b5-8308-bd5a54cda9d1
            group: SEATA_GROUP
            username: nacos
            password: nacos      
            context-path:
            # 默认，下边nacos远程新建配置文件名需一致
            data-id: seataServer.properties
      ```

   3. 修改seata下的registry部分

      ```yml
      seata:
      	registry:
          type: nacos
          preferred-networks: 30.240.*
          nacos:
            application: seata-server
            server-addr: 127.0.0.1:8848
            group: SEATA_GROUP
            namespace: 3ae09240-7a62-41b5-8308-bd5a54cda9d1
            cluster: default
            username: nacos
            password: nacos
      ```

   4. 修改seata下的store

      ```yml
      seata:
      # 都修改为 db
      	store:
          mode: db
          session:
            mode: db
          lock:
            mode: db
            #修改为自己的配置
          db:
            datasource: druid
            db-type: mysql
            driver-class-name: com.mysql.cj.jdbc.Driver
            url: jdbc:mysql://127.0.0.1:3306/seata?rewriteBatchedStatements=true&useSSL=false
            user: root
            password: 123456
      ```

6. 启动服务，目录/seata/bin/`seata-server.bat`，点击启动，可以在SEATA命名空间中的服务列表中看见seata-server服务，服务注册成。

7. 远程配置服务，SEATA命名空间内创建配置文件：

   1. DataID: seataServer.properties

   2. GROUP: SEATA_GROUP

   3. 配置内容：

      - 格式为：properties

      - 内容为：按需修改config.txt文件后，直接粘贴到这，方便配置上传


## AT模式

AT模式是Seata的默认模式，是2PC的演变。在AT模式下，Seata框架会自动生成事务的二阶段提交和回滚操作。

- 一阶段：Seata会拦截“业务SQL”，首先解析SQL语义，找到要更新的业务数据，在数据被更新前，保存下“undo”，然后执行“业务SQL”更新数据，更新之后再次保存数据“redo”，最后生成行锁，这些操作都在**本地数据库事务内完成**，保证一阶段原子性
- 二阶段：负责整体的回滚和提交，如果一阶段中有本地事务没有通过，那么就执行全局回滚，否则执行全局提交。回滚用到的就是一阶段记录的“undo_log”，通过回滚记录生成反向更新SQL并执行，完成分支的回滚。事务完成后释放所有资源和删除所有日志

![image-20240731162026134](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407311620232.png)

 

1. 注意==启动==本地的seata/bin`seata-server.bat`服务

2. 项目中在auth、user、order模块引入seata依赖

   ```xml
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
    </dependency>
   ```

3. 配置每个模块的application.yml文件
	```yaml
   seata:
     config:
       type: nacos
       nacos:
         server-addr: 127.0.0.1:8848
         namespace: 5f1da9de-cd0a-42a7-b9e8-9420a2798735  # SEATA命名空间
         username: nacos
         password: nacos
         group: SEATA_GROUP
     tx-service-group: default_tx_group # 默认事务组名称，要和服务端对应
     service:
       vgroup-mapping:
         default_tx_group: default #key是事务组名称，value要和服务端的机房名称保持一致
       grouplist:
         default: 127.0.0.1:8091
	```

4. 项目业务数据库中添加`undo_log`表，用于数据回滚 ==重要==

   ```sql
   -- for AT mode you must to init this sql for you business database. the seata server not need it.
   CREATE TABLE IF NOT EXISTS `undo_log`
   (
      `branch_id`     BIGINT       NOT NULL COMMENT 'branch transaction id',
      `xid`           VARCHAR(128) NOT NULL COMMENT 'global transaction id',
      `context`       VARCHAR(128) NOT NULL COMMENT 'undo_log context,such as serialization',
      `rollback_info` LONGBLOB     NOT NULL COMMENT 'rollback info',
      `log_status`    INT(11)      NOT NULL COMMENT '0:normal status,1:defense status',
      `log_created`   DATETIME(6)  NOT NULL COMMENT 'create datetime',
      `log_modified`  DATETIME(6)  NOT NULL COMMENT 'modify datetime',
      UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)
   ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4 COMMENT ='AT transaction mode undo table';
   ALTER TABLE `undo_log` ADD INDEX `ix_log_created` (`log_created`);
   ```

5. 测试 user 模块添加用户的同时，进行feign远程调用order模块的新增订单方法，在事务发起端的方法上添加注解`@GlobalTransactional`，被调用的不需要添加

   ```java
   @Override
   @Transactional // 本地事务
   @GlobalTransactional // 分布式事务
   public boolean saveit(User user) {
      userMapper.insert(user);
      Order order = new Order();
      order.setOrderName("订单" + user.getUsername());
      order.setOrderDescrition("订单描述" + user.getUsername());
      // 远程调用
      return orderFeignClient.add(order);
   }
   ```

   被调用的方法

   ```java
   @Override
   public boolean saveit(Order order) {
      String orderName = order.getOrderName();
      String orderDescription = order.getOrderDescrition();
      // 模拟远程失败异常
      int i = 1/0; 
      int insert = orderMapper.save(orderName, orderDescription);
      return insert > 0;
   }
   ```

6. 测试成功，达成分布式事务全局回滚

## XA、TCC、Saga模式

### XA模式

#### XA协议
XA规范使用两阶段提交（2PC)来保证所有资源同时提交或回滚任何特定事务
DTP模型定义如下角色：

- AP：即应用程序，可以劣迹为使用DTP分布式事务的程序
- RM：资源管理器，可以理解为事务的参与者，一般情况指一个数据库实例（Mysql），通过资源管理器对该数据库进行控制，资源管理器控制着分支事务
- TM：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务
- DTP模式定义TM和RM之间通讯的接口规范叫XA，简单理解为数据库提供的2PC接口协议，基于数据库XA协议来实现的2PC又称为XA方案

![image-20240731230720016](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407312307187.png)
**缺点**：如果参与全局事务的某一个资源失联了（收不到分支事务结束的命令)，那么它锁定的数据，将被一直锁定，甚至产生死锁。seata针对改进优化

#### XA模式应用

XA模式通过数据库的事务机制来保证事务的原子性和一致性，而不需要额外的`undo_log`，具有全局的强一致性

![image-20240801101931235](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202408011019376.png)

上层编程模式与AT模式完全相同，只需要修改数据源代理，即可实现XA模式与AT模式之间的切换

`OrderXADatasourceConfiguration.java`

```java
@Configuration
public class OrderXADatasourceConfiguration{
   @Bean
   @ConfiurationProperties(prefix="spring.datasource")
   public DruidDataSource druidDataSource(){
      return new DruidDataSource();	
   }
   
   @Bean("dataSourceProxy")
   public DataSource dataSource(DruidDataSouce druidDataSource){
      //return new DataSourceProxy(druidDataSource) // AT模式
      return new DataSourceProxyXA(druidDataSource); //XA模式
   }
   
   @Bean("jdbcTemplate")
   public JdbcTemplate jdbcTemplate(DataSource dataSourceProxy){
      return new JdbcTemplate(dataSourceProxy);
   }
}
```

### TCC模式

1. Try：对业务资源的检查并预留
2. Confirm：对业务处理进行提交，即commit操作，只要Try成功，那么该步骤一定成功
3. Cancel：对业务进行取消，即回滚，会对Try预留资源进行释放

TCC是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务有着非常大的侵入性，设计相对复杂，但TCC优点是完全不依赖数据库，能够实现跨数据库，跨应用资源管理。

![image-20240801102800027](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202408011028186.png)

特点：

- 侵入式较强，需要自己实现相关事务逻辑控制
- 整个过程基本没有锁，性能较强

### Saga模式

Seata提供的长事务解决方案。在Saga模式中，业务流程中的每个参与者都提交本地事务，当出现某一个参与者失败，则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务（执行处理时候出错了，给一个修复的机会）都由业务开发实现。

![image-20240801104509743](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202408011045851.png)

**为什么需要Saga？**

在特殊环境下，比如老系统、封闭的系统（无法修改、同时没有任何分布式事务引入），那么AT、XA、TCC模型将全部不能使用，为了解决这样的问题，才引用了Saga模型。

![image-20240801104640132](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202408011046261.png)

## Seata源码

[AT模式的读、写隔离](https://seata.apache.org/zh-cn/docs/dev/mode/at-mode)

