## 算法

### 1. 链表反转-迭代

```java
   public ListNode reverseList(ListNode head) {
        ListNode pre = null; //记录当前节点，作为下一节点的下一节点
        ListNode curr = head; //记录当前节点
        while(curr!=null){
            ListNode next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }
```



### 2. 链表反转-递归

迭代找到最后一个节点，期间，将head（当前节点）的下个节点的next（head.next.next）变为当前节点

```java
 public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
    	  //newHead为最后一个节点,此时head为倒数第二个节点
        ListNode newHead = reverseList(head.next); 
        head.next.next = head; 
        head.next = null; 
        return newHead;
    }
```



### 3. 统计素数个数-暴力算法

素数：0/1以外只能被1和本身整除

```java
public static int countPrimes(int num) {
        int count = 0;
   	  // 依次判断每个数是否是素数
        for (int i = 2; i <= num; i++) {
            if (isPrime(i)) {
                count++;
            }
        }
        return count;
    }
	 //判断素数方法
    private static boolean isPrime(int num) {
        if (num < 2) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(num); i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
    }
```



### 4.  统计素数个数-埃氏筛选

原理是从2开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的==等差数列==。即先把2留下，再把2的倍数筛掉，把3留下...以此类推

如果现在这个序列中最大数小于等于最后一个标出的素数的平方，那么剩下的序列中所有的数都是质数

```java
public static int countPrime(int max) {
   boolean[] isPrime = new boolean[max + 1];
   // 初始化全部为 true，假定所有数都是素数
   for (int i = 2; i <= max; i++) {
      isPrime[i] = true;
   }
   // 对每个数判断是否为素数，如果不是则标记为 false
   for (int i = 2; i <= Math.sqrt(max); i++) {
      if (isPrime[i]) {
         // 从 i*i 开始，以 i 为步长一直循环下去，直到超过 max
         for (int j = i * i; j <= max; j += i) {
            isPrime[j] = false;
         }
      }
   }
   // 统计素数的数量
   int count = 0;
   for (boolean prime : isPrime) {
      if (prime) {
         count++;
      }
   }
   return count;
}
```



### 5. 删除排序数组中的重复项

==双指针==

注意：有序数组

```java
public int removeDuplicates(int[] nums) {
   if(nums == null || nums.length == 0) return 0;
   int p = 0;
   int q = 1;
   while(q < nums.length){
      if(nums[p] != nums[q]){
         nums[p + 1] = nums[q];
         p++;
      }
      q++;
   }
   return p + 1;
}
```

### 6. 寻找数组的中心下标

==前缀和==

数组 **中心下标** 是数组的一个下标 `redis.conf`，其左侧所有元素相加的和等于右侧所有元素相加的和

```java
public static int pivotIndex(int[] nums) {
   int prefix = 0;
   int total = 0;
   // 计算总和
   for (int num : nums) {
      total += num;
   }
   // 遍历数组，查找平衡索引
   for (int i = 0; i < nums.length; i++) {
      prefix += nums[i];
      // 当前位置的前缀和等于后缀和时，返回该位置
      // 注意：对于最后一个元素，后缀和为0
      if (prefix == total - prefix + nums[i]) {
         return i;
      }
   }
   // 如果没有找到平衡索引，返回-1
   return -1;
}
```



### 7. x的平方根-二分查找

```java
public static BigDecimal binarySqrt(BigDecimal num) {  
    // 计算时保留50位精度  
    MathContext MATH_CONTEXT = new MathContext(50);  
    BigDecimal left = BigDecimal.ZERO;  
    BigDecimal right = num.max(BigDecimal.ONE); // 防止当num<1时，right=num导致的错误  
    BigDecimal mid;  
    do {  
        mid = left.add(right).divide(BigDecimal.valueOf(2), MATH_CONTEXT);  
        if (mid.pow(2, MATH_CONTEXT).compareTo(num) > 0) {  
            right = mid;  
        } else {  
            left = mid;  
        }    } while (right.subtract(left).compareTo(new BigDecimal("0.00000000000000000001")) > 0);  
  
    return mid;  
}
```

### 8.x的平方根-牛顿迭代

$$
牛顿迭代公式:  x_{n+1}=x_n-\frac{f(x_n)}{f`(x_n)}
$$

$$
转化过程：f`(x_n)=\frac{f(x_n)}{|x_n-x_{n+1}|}
$$

$$
由题可列方程：f(x)=x^2-α=0
$$

$$
下次估计值：x_{n+1}=x_n-\frac{f(x_n)}{f^`(x_n)}=x_n-\frac{x_n^2-\alpha}{2x_n}=\frac{1}{2}(x_n+\frac{\alpha}{x_n})
$$

lastX为上一次估计值，x为当前估计值，计算两值的差与精度比值

```java
public static BigDecimal newtonSqrt(BigDecimal num) {  
   MathContext MATH_CONTEXT = new MathContext(50);  
   BigDecimal x = num; // 初始估计值  
   BigDecimal lastX;  
   do {  
      lastX = x;  
      x = x.add(num.divide(x, MATH_CONTEXT)).divide(BigDecimal.valueOf(2), MATH_CONTEXT);  
   } while (x.subtract(lastX).abs().compareTo(new BigDecimal("0.00000000000000000001")) > 0);  
   return x;  
}
```
### 9. 数组中三个数的最大乘积

```java
public static int MaxProduct(int[] nums) {
   Arrays.sort(nums);
   int len = nums.length;
   return nums[len - 1] * nums[len - 2] * nums[len - 3];
}
```

### 10. 两数之和-无序数组

哈希表存储数字，减少时间复杂度

```java
public static int[] twoSum(int[] nums, int target) {
   Map<Integer, Integer> map = new HashMap<>();
   for (int i = 0; i < nums.length; ++i) {
      if (map.containsKey(target - nums[i])) {
         return new int[]{map.get(target - nums[i]), i};
      }
      map.put(nums[i], i);
   }
   return new int[0];
}
```

### 11. 两数之和-有序数组

双指针/二分查找

```java
private static int[] twoSumSort(int[] nums, int target) {
   int left = 0, right = nums.length - 1;
   while (left <= right) {
      if (target < nums[left] + nums[right]) {
         right--;
      } else if (target > nums[left] + nums[right]) {
         left++;
      } else {
         return new int[]{left, right};
      }
   }
   return new int[]{};
}
```

### 12. 斐波那契数列

$$
f(0)=f(1)=1
$$

$$
f(n)=f(n-1)+f(n-2)
$$



```java
for(int i = 0 ;i< nums.length;i++){
   list.add(...)//三种方法
}
// 迭代
public static int fibonacciIterative(int n) {
   if (n <= 1) {
      return n;
   }
   int a = 0, b = 1;
   for (int i = 2; i <= n; i++) {
      int c = a + b;
      a = b;
      b = c;
   }
   return b;
}

//递归
private static int fib(int num) {
   if (num <= 1) {
      return num;
   }
   return fib(num - 1) + fib(num - 2);
}
```

### 13. 排列硬币-三种解法

排列硬币问题可以理解为一个经典的动态规划问题，主要目标是找出组成某个金额所需的最少硬币数量

```java
//动态规划，自底向上，从最小面额开始
private static int coinMin(int[] coins, int target) {
   int[] dp = new int[target + 1];
   Arrays.fill(dp, target + 1);
   dp[0] = 0;

   for (int i = 1; i <= target; i++) {
      for (int coin : coins) {
         if (coin <= i) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
         }
      }
   }
   return dp[target] > target ? -1 : dp[target];
}
```

### 14. 环形链表

[leetcode](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/) 不允许修改链表

```java
public ListNode detectCycle(ListNode head) {
   ListNode fast = head, slow = head;
   while (true) {
      if (fast == null || fast.next == null) return null;
      fast = fast.next.next;
      slow = slow.next;
      if (fast == slow) break;
   }
   fast = head;
   while (slow != fast) {
      slow = slow.next;
      fast = fast.next;
   }
   return fast;
}
```

### 15. 合并两个有序数组

[leetcode](https://leetcode.cn/problems/merge-sorted-array/solutions/666608/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/)

逆向双指针：由于nums1数组后部分是空的，利用此，可以减少临时变量的产生，从后往前依次将较大的值放入

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 >= 0 || p2 >= 0) {
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] > nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
```



### 16. 子数组最大平均数

[leetcode](https://leetcode.cn/problems/maximum-average-subarray-i/description/)

滑动窗口：平均数最大且长度为k的**连续子数组**

```java
public double findMaxAverage(int[] nums, int k) {
   int sum = 0;
   int n = nums.length;
   // 前k个的和
   for (int i = 0; i < k; i++) {
      sum += nums[i];
   }
   int maxSum = sum;
   for (int i = k; i < n; i++) {
      //删除第一个，从后添加一个，求和
      sum = sum - nums[i - k] + nums[i];
      maxSum = Math.max(maxSum, sum);
   }
   return (double) maxSum / k;
}
```



### 17. 二叉树最小深度-深度优先

[leetcode](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

递归

![练习记录.excalidraw](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202408041524780.svg)

> 1. 如果左孩子和右孩子有为空的情况，直接返回m1+m2+1
>    - 只要有任意孩子为空，那必然最小深度就是孩子深度（m1+m2）加1（自身节点）
>    - 如果两孩子都为空，则（m1+m2=0）+1（自身节点）=1
> 2. 如果都不为空，返回较小深度+1

```java
public int minDepth(TreeNode root) {
   if(root == null) return 0;
   int m1 = minDepth(root.left);
   int m2 = minDepth(root.right);
   return root.left == null || root.right == null ? m1 + m2 + 1 : Math.min(m1,m2) + 1;
}
```



### 18. 二叉树最小深度-广度优先

广度优先遍历，保证了最先搜索到叶子结点的，必然是最小的深度

```java
public int minDepth(TreeNode root) {
   if (root == null) {
      return 0;
   }
   Queue<QueueNode> queue = new LinkedList<QueueNode>();
   queue.offer(new QueueNode(root, 1));
   while (!queue.isEmpty()) {
      QueueNode nodeDepth = queue.poll();
      TreeNode node = nodeDepth.node;
      int depth = nodeDepth.depth;
      if (node.left == null && node.right == null) {
         return depth;
      }
      if (node.left != null) {
         queue.offer(new QueueNode(node.left, depth + 1));
      }
      if (node.right != null) {
         queue.offer(new QueueNode(node.right, depth + 1));
      }
   }
   return 0;
}
```



### 19. 最长连续递增序列-贪心算法

[leetcode](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/)

```java
public int findLengthOfLCIS(int[] nums) {
   // 子序列长度
   int ans = 0;
   int n = nums.length;
   int start = 0;
   for (int i = 0; i < n; i++) {
      if (i > 0 && nums[i] <= nums[i - 1]) {
         start = i;
      }
      ans = Math.max(ans, i - start + 1);
   }
   return ans;
}
```



### 20. 柠檬水找零-贪心算法

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

```java
public boolean lemonadeChange(int[] bills) {
   int five = 0, ten = 0;
   for (int bill : bills) {
      if (bill == 5) {
         five++;
      } else if (bill == 10) {
         if (five == 0) {
            return false;
         }
         five--;
         ten++;
      } else {
         if (five > 0 && ten > 0) {
            five--;
            ten--;
         } else if (five >= 3) {
            five -= 3;
         } else {
            return false;
         }
      }
   }
   return true;
}
```



### 21. 三角形的最大周长-贪心算法
如果nums(i-2)＋nums(i-1)还不能大于nums(i)，那必然不可取nums(i)了，因为已经没有两边之和更大的能大于nums(i)的了，所以直接窗口滑动计算

```java
private static int largestPerimeter(int[] nums) {
   // 排序，从后往前，判断能否构成三角形
   Arrays.sort(nums);
   for (int i = nums.length - 1; i >= 2; i--) {
      if (nums[i] < nums[i - 1] + nums[i - 2]) {
         return nums[i] + nums[i - 1] + nums[i - 2];
      }
   }
   return 0;
}
```


### 22. 二叉树遍历
==递归==（前序、中序、后序遍历），前序遍历（中--左--右）

```java
public List<Integer> preorderTraversal(TreeNode root){
List<Integer> res = new ArrayList<Integer>();
preorder(root,res);
return res;
}
public void preorder(TreeNode,List<Integer> res){
if(root==null){
return;
}
// 先添加中间节点
res.add(root.val);
preorder(root.left,res);
preorder(root.right,res);
}
```

==迭代==：显示的维护一个栈

### 23. 省份数量
[leetcode](https://leetcode.cn/problems/number-of-provinces/description/)

- [ ] 预测赢家
- [ ] 字符串搜索-BF和RK
- [ ] 字符串搜索-BM
- [ ] 字符串搜索-KMP算法
- [ ] 打家劫舍-动态规划
- [ ] Dota2参议院-贪心视频
- [ ] 优势洗牌(田忌赛马)

## 数据结构

- [ ] clip
- [ ] 数组&链表
- [ ] 栈
- [ ] 队列
- [ ] 数论&枚举&递归&分治&回溯
- [ ] 排序及其源码实现
- [ ] 贪心&动态规划
- [ ] 树论基础&二叉树
- [ ] 二叉搜索树&红黑树
- [ ] BTree
- [ ] Trie树&赫夫曼树
- [ ] 堆树
- [ ] 图论基础
- [ ] 最短路径
- [ ] 最短路径
- [ ] 高效查找算法
- [ ] HashSet&TreeSet
- [ ] 索引技术：中文分词算法
- [ ] 索引技术：Lucene

## 设计模式

- [ ] 单例设计模式
- [ ] 工厂方法模式
- [ ] 抽象工厂模式
- [ ] 建造者模式
- [ ] 原型模式
- [ ] 享元模式
- [ ] 门面模式
- [ ] 适配器模式
- [ ] 装饰器模式
- [ ] 策略模式
- [ ] 模板方法模式
- [ ] 观察者模式
- [ ] 责任链模式
- [ ] Spring源码
- [ ] SpringIoc源码
- [ ] Spring Aop源码
- [ ] Spring 声明式事务源码
- [ ] SpringMVC源码
- [ ] SpringMVC运行原理
- [ ] Mybatis源码
- [ ] Mybatis加载过程
- [ ] MyBatis运行过程
- [ ] Spring整合Mybatis源码
- [ ] 集合框架底层源码
- [ ] ArrayList集合源码分析
- [ ] LinkedList集合源码分析
- [ ] Jdk1.8中HashSet(HashMap)源码分析
- [ ] TreeSet(TreeMap)底层源码分析

## JVM底层原理

- [ ] VM类加载机制详解
- [ ] 从JDK源码级别深度剖析类加载过程
- [ ] 启动类、扩展类、应用程序类加载器源码深度剖析
- [ ] 类加载双亲委派机制及任何打破详解
- [ ] 手写自定义类加载器
- [ ] Tomcat类加载机制源码剖析
- [ ] JVM内存模型
- [ ] 对内存分代机制及对象声明周期详解
- [ ] 线程栈及栈帧内部结构详解
- [ ] 方法区（元空间）及常量池详解
- [ ] 程序计数器详解
- [ ] 本地方法栈详解