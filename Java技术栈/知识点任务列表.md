## 算法

### 1. 链表反转-迭代

```java
   public ListNode reverseList(ListNode head) {
        ListNode pre = null; //记录当前节点，作为下一节点的下一节点
        ListNode curr = head; //记录当前节点
        while(curr!=null){
            ListNode next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }
```



### 2. 链表反转-递归

迭代找到最后一个节点，期间，将head（当前节点）的下个节点的next（head.next.next）变为当前节点

```java
 public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
    	  //newHead为最后一个节点,此时head为倒数第二个节点
        ListNode newHead = reverseList(head.next); 
        head.next.next = head; 
        head.next = null; 
        return newHead;
    }
```



### 3. 统计素数个数-暴力算法

素数：0/1以外只能被1和本身整除

```java
public static int countPrimes(int num) {
        int count = 0;
   	  // 依次判断每个数是否是素数
        for (int i = 2; i <= num; i++) {
            if (isPrime(i)) {
                count++;
            }
        }
        return count;
    }
	 //判断素数方法
    private static boolean isPrime(int num) {
        if (num < 2) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(num); i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
    }
```



### 4.  统计素数个数-埃氏筛选

原理是从2开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的==等差数列==。即先把2留下，再把2的倍数筛掉，把3留下...以此类推

如果现在这个序列中最大数小于等于最后一个标出的素数的平方，那么剩下的序列中所有的数都是质数

```java
public static int countPrime(int max) {
   boolean[] isPrime = new boolean[max + 1];
   // 初始化全部为 true，假定所有数都是素数
   for (int i = 2; i <= max; i++) {
      isPrime[i] = true;
   }
   // 对每个数判断是否为素数，如果不是则标记为 false
   for (int i = 2; i <= Math.sqrt(max); i++) {
      if (isPrime[i]) {
         // 从 i*i 开始，以 i 为步长一直循环下去，直到超过 max
         for (int j = i * i; j <= max; j += i) {
            isPrime[j] = false;
         }
      }
   }
   // 统计素数的数量
   int count = 0;
   for (boolean prime : isPrime) {
      if (prime) {
         count++;
      }
   }
   return count;
}
```



### 5. 删除排序数组中的重复项

==双指针==

注意：有序数组

```java
public int removeDuplicates(int[] nums) {
   if(nums == null || nums.length == 0) return 0;
   int p = 0;
   int q = 1;
   while(q < nums.length){
      if(nums[p] != nums[q]){
         nums[p + 1] = nums[q];
         p++;
      }
      q++;
   }
   return p + 1;
}
```

### 6. 寻找数组的中心下标

==前缀和==

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和

```java
public static int pivotIndex(int[] nums) {
   int prefix = 0;
   int total = 0;
   // 计算总和
   for (int num : nums) {
      total += num;
   }
   // 遍历数组，查找平衡索引
   for (int i = 0; i < nums.length; i++) {
      prefix += nums[i];
      // 当前位置的前缀和等于后缀和时，返回该位置
      // 注意：对于最后一个元素，后缀和为0
      if (prefix == total - prefix + nums[i]) {
         return i;
      }
   }
   // 如果没有找到平衡索引，返回-1
   return -1;
}
```



### 7. x的平方根-二分查找

```java
public static BigDecimal binarySqrt(BigDecimal num) {  
    // 计算时保留50位精度  
    MathContext MATH_CONTEXT = new MathContext(50);  
    BigDecimal left = BigDecimal.ZERO;  
    BigDecimal right = num.max(BigDecimal.ONE); // 防止当num<1时，right=num导致的错误  
    BigDecimal mid;  
    do {  
        mid = left.add(right).divide(BigDecimal.valueOf(2), MATH_CONTEXT);  
        if (mid.pow(2, MATH_CONTEXT).compareTo(num) > 0) {  
            right = mid;  
        } else {  
            left = mid;  
        }    } while (right.subtract(left).compareTo(new BigDecimal("0.00000000000000000001")) > 0);  
  
    return mid;  
}
```

### 8.x的平方根-牛顿迭代

$$
牛顿迭代公式:  x_{n+1}=x_n-\frac{f(x_n)}{f`(x_n)}
$$

$$
转化过程：f`(x_n)=\frac{f(x_n)}{|x_n-x_{n+1}|}
$$

$$
由题可列方程：f(x)=x^2-α=0
$$

$$
下次估计值：x_{n+1}=x_n-\frac{f(x_n)}{f^`(x_n)}=x_n-\frac{x_n^2-\alpha}{2x_n}=\frac{1}{2}(x_n+\frac{\alpha}{x_n})
$$

lastX为上一次估计值，x为当前估计值，计算两值的差与精度比值

```java
public static BigDecimal newtonSqrt(BigDecimal num) {  
   MathContext MATH_CONTEXT = new MathContext(50);  
   BigDecimal x = num; // 初始估计值  
   BigDecimal lastX;  
   do {  
      lastX = x;  
      x = x.add(num.divide(x, MATH_CONTEXT)).divide(BigDecimal.valueOf(2), MATH_CONTEXT);  
   } while (x.subtract(lastX).abs().compareTo(new BigDecimal("0.00000000000000000001")) > 0);  
   return x;  
}
```
### 9. 数组中三个数的最大乘积

```java
public static int MaxProduct(int[] nums) {
   Arrays.sort(nums);
   int len = nums.length;
   return nums[len - 1] * nums[len - 2] * nums[len - 3];
}
```

### 10. 两数之和-无序数组

哈希表存储数字，减少时间复杂度

```java
public static int[] twoSum(int[] nums, int target) {
   Map<Integer, Integer> map = new HashMap<>();
   for (int i = 0; i < nums.length; ++i) {
      if (map.containsKey(target - nums[i])) {
         return new int[]{map.get(target - nums[i]), i};
      }
      map.put(nums[i], i);
   }
   return new int[0];
}
```

### 11. 两数之和-有序数组

双指针/二分查找

```java
private static int[] twoSumSort(int[] nums, int target) {
   int left = 0, right = nums.length - 1;
   while (left <= right) {
      if (target < nums[left] + nums[right]) {
         right--;
      } else if (target > nums[left] + nums[right]) {
         left++;
      } else {
         return new int[]{left, right};
      }
   }
   return new int[]{};
}
```

### 12. 斐波那契数列

$$
f(0)=f(1)=1
$$

$$
f(n)=f(n-1)+f(n-2)
$$



```java
for(int i = 0 ;i< nums.length;i++){
   list.add(...)//三种方法
}
// 迭代
public static int fibonacciIterative(int n) {
   if (n <= 1) {
      return n;
   }
   int a = 0, b = 1;
   for (int i = 2; i <= n; i++) {
      int c = a + b;
      a = b;
      b = c;
   }
   return b;
}

//递归
private static int fib(int num) {
   if (num <= 1) {
      return num;
   }
   return fib(num - 1) + fib(num - 2);
}
```

### 13. 排列硬币-三种解法

排列硬币问题可以理解为一个经典的动态规划问题，主要目标是找出组成某个金额所需的最少硬币数量

```java
//动态规划，自底向上，从最小面额开始
private static int coinMin(int[] coins, int target) {
   int[] dp = new int[target + 1];
   Arrays.fill(dp, target + 1);
   dp[0] = 0;

   for (int i = 1; i <= target; i++) {
      for (int coin : coins) {
         if (coin <= i) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
         }
      }
   }
   return dp[target] > target ? -1 : dp[target];
}
```



- [ ] 环形链表
- [ ] 合并两个有序数组
- [ ] 子数组最大平均数
- [ ] 二叉树最小深度-深度优先
- [ ] 二叉树最小深度-广度优先
- [ ] 最长连续递增序列-贪心算法
- [ ] 柠檬水找零-贪心算法
- [ ] 三角形的最大周长-贪心算法
- [ ] 二叉树遍历
- [ ] 省份数量
- [ ] 预测赢家
- [ ] 字符串搜索-BF和RK
- [ ] 字符串搜索-BM
- [ ] 字符串搜索-KMP算法
- [ ] 打家劫舍-动态规划
- [ ] Dota2参议院-贪心视频
- [ ] 优势洗牌(田忌赛马)

## 数据结构

- [ ] clip
- [ ] 数组&链表
- [ ] 栈
- [ ] 队列
- [ ] 数论&枚举&递归&分治&回溯
- [ ] 排序及其源码实现
- [ ] 贪心&动态规划
- [ ] 树论基础&二叉树
- [ ] 二叉搜索树&红黑树
- [ ] BTree
- [ ] Trie树&赫夫曼树
- [ ] 堆树
- [ ] 图论基础
- [ ] 最短路径
- [ ] 最短路径
- [ ] 高效查找算法
- [ ] HashSet&TreeSet
- [ ] 索引技术：中文分词算法
- [ ] 索引技术：Lucene

## 设计模式

- [ ] 单例设计模式
- [ ] 工厂方法模式
- [ ] 抽象工厂模式
- [ ] 建造者模式
- [ ] 原型模式
- [ ] 享元模式
- [ ] 门面模式
- [ ] 适配器模式
- [ ] 装饰器模式
- [ ] 策略模式
- [ ] 模板方法模式
- [ ] 观察者模式
- [ ] 责任链模式
- [ ] Spring源码
- [ ] SpringIoc源码
- [ ] Spring Aop源码
- [ ] Spring 声明式事务源码
- [ ] SpringMVC源码
- [ ] SpringMVC运行原理
- [ ] Mybatis源码
- [ ] Mybatis加载过程
- [ ] MyBatis运行过程
- [ ] Spring整合Mybatis源码
- [ ] 集合框架底层源码
- [ ] ArrayList集合源码分析
- [ ] LinkedList集合源码分析
- [ ] Jdk1.8中HashSet(HashMap)源码分析
- [ ] TreeSet(TreeMap)底层源码分析

## JVM底层原理

- [ ] VM类加载机制详解
- [ ] 从JDK源码级别深度剖析类加载过程
- [ ] 启动类、扩展类、应用程序类加载器源码深度剖析
- [ ] 类加载双亲委派机制及任何打破详解
- [ ] 手写自定义类加载器
- [ ] Tomcat类加载机制源码剖析
- [ ] JVM内存模型
- [ ] 对内存分代机制及对象声明周期详解
- [ ] 线程栈及栈帧内部结构详解
- [ ] 方法区（元空间）及常量池详解
- [ ] 程序计数器详解
- [ ] 本地方法栈详解