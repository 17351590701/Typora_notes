

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061738152.png" alt="image-20240518084640325" style="zoom:67%;" />



==总结==

> 1、过滤器和拦截器**触发时机不一样**，**过滤器是**在请**求进入容器后**，但请求**进入servlet之前**进**行预处理**的。请求结束返回也是，是在servlet处理完后，返回给前端之前。
>
> 2、**拦截器**可以获取IOC容器中的各个bean，而过滤器就不行，因为拦**截器是spring提供并管理的**，spring的功能可以被拦截器使用，在拦截器里注入一个service，可以调用业务逻辑。而过滤器是JavaEE标准，只需依赖servlet api ，不需要依赖spring。
>
> 3、**过滤器的实现**基于**回调函数**。而**拦截器**（代理模式）的实现**基于反射**
>
> 4、**Filter**是依**赖于Servlet容**器，**属于Servlet规范的一部分**，只在web应用中使用，而**拦截器则是独立存**在的，可以在任何情况下使用。
>
> 5、**Filte**r的执行由**Servlet容器回调完成**，而**拦截器**通常通**过动态代理（反射）**的方式来执行。
>
> 6、**Filter的生命周**期**由Servlet容器管理**，而**拦截器则**可以通过I**oC容器来管理**，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。
>
> 过滤器和拦截器非常相似，但是它们有很大的区别
> 最简单明了的区别就是**过滤器可以修改request，而拦截器不能**
> **过滤器需要在servlet容器中实现，拦截器可以适用于javaEE，javaSE等各种环境**
> **拦截器可以调用IOC容器中的各种依赖，而过滤器不能**
> **过滤器只能在请求的前后使用，而拦截器可以详细到每个方法**



## 过滤器

### 方式一

> 通过@Component注册拦截器Bean或者直接在配置类中new 对象的方式
>
> 在配置类中配置过滤路径等

拦截器

```java
@Slf4j
@Component
public class TestFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        log.info("过滤前");
        filterChain.doFilter(servletRequest,servletResponse);
        log.info("过滤后");
    }
}
```

配置类

```java
@Configuration
public class FilterConfig {
    @Resource
    private TestFilter testFilter;

    @Bean
    public FilterRegistrationBean filterRegistrationBean() {
        FilterRegistrationBean filter = new FilterRegistrationBean();
        filter.setFilter(testFilter);
        filter.addUrlPatterns("/*");
        return filter;
    }
}
```



### 方式二

> 通过@WebFilter注解指定过滤路径，在启动类添加 `@ServletComponentScan` 注解

过滤器

```java
@Slf4j
@WebFilter(urlPatterns = "/*",filterName = "testFilter")
public class TestFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        log.info("过滤前");
        filterChain.doFilter(servletRequest,servletResponse);
        log.info("过滤后");
    }
}
```





## 拦截器

拦截器

```java
@Slf4j
public class TestInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        log.info("拦截器执行前");
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        log.info("拦截器执行后");
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        log.info("视图渲染后");
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

配置类

> 为保证在拦截器中注册Service等操作成功。需要通过手动创建拦截器bean而非new 对象的方法

```java
@Configuration
public class SpringMvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(testInterceptor())
                .addPathPatterns("/**");
    }

    @Bean
    public TestInterceptor testInterceptor() {
        return new TestInterceptor();
    }
}
```

