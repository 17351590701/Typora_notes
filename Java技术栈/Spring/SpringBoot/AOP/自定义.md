## 自定义注解+AOP

==AOP+反射+自定义注解==

1. 引入aop依赖 

   ```xml
       <!--aspect-jweaver依赖，支持切入点表达式，aop注解等-->
           <dependency>
               <groupId>org.aspectj</groupId>
               <artifactId>aspectjweaver</artifactId>
               <version>1.9.22</version>
           </dependency>
   ```

2. 启动类或配置类上添加注解

   ```java
   @EnableAspectJAuProxy //开启AOP自动代理，启用AspectJ风格的AOP
   ```

2. 自定义注解

   ```java
   @Target(ElementType.METHOD) // 注解生效目标（方法）
   @Retention(RetentionPolicy.RUNTIME) // 保留到运行时
   public @interface ZyrTest {
       String value() default "";
   }
   ```

3. aop切面类

   ```java
   @Aspect
   @Component
   @Slf4j
   public class ZyrTestAspect {
       // @Around("execution(* com..CouponController.batchCaskAction(..))") 
       // 生效在所有该注解上
       @Around("@annotation(com.heima.mianshi.annotations.ZyrTest)")
       public Object zyrTest(ProceedingJoinPoint pjp) throws Throwable {
           System.out.println("环绕通知前置通知：AAA");
           // 记录方法开始执行的时间
           LocalDateTime startTime = LocalDateTime.now();
           // 执行目标方法
           Object result = pjp.proceed();
           // 记录方法执行结束的时间
           LocalDateTime endTime = LocalDateTime.now();
           // 获取方法签名，以便获取方法本身的信息
           MethodSignature signature = (MethodSignature) pjp.getSignature();
           // 通过方法签名获取具体的方法对象
           Method method = signature.getMethod();
           // 获取方法上标注的zyrTest注解对象
           ZyrTest annotation = method.getAnnotation(ZyrTest.class);
           if (annotation != null) {
               // 注解属性 value 的值
               // String value = annotation.value();
               // 初始化字符串缓冲区，用于拼接参数信息
               StringBuffer sb = new StringBuffer();
               // 获取方法的参数数组
               Object[] args = pjp.getArgs();
               // 使用DefaultParameterNameDiscoverer获取方法参数名称
               DefaultParameterNameDiscoverer discoverer = new DefaultParameterNameDiscoverer();
               String[] parameterNames = discoverer.getParameterNames(method);
               // 遍历参数名称和参数值，拼接到字符串缓冲区
               for (int i = 0; i < parameterNames.length; i++) {
                   sb.append(parameterNames[i]).append(":").append(args[i]).append(";");
               }
               // 使用ObjectMapper将结果对象转换为JSON字符串
               String jsonResult = null;
               if (result != null) {
                   jsonResult = new ObjectMapper().writeValueAsString(result);
               } else {
                   jsonResult = "null";
               }
               log.info("""
                               \
                               方法分析上报中\
   
                               类名方法名:{}\
   
                               执行耗时:{}\
   
                               输入参数:{}\
   
                               返回结果:{}\
   
                               over""", pjp.getTarget().getClass().getName() + "." + method.getName(),
                       endTime.getNano() - startTime.getNano(),
                       sb,
                       jsonResult);
           }
           System.out.println("环绕通知后置通知：BBB");
           // 返回目标方法的执行结果
           return result;
       }
   }
   
   ```

4. 使用注解

   ```java
   public class CouponController{
      @ZyrTest(value = "测试注解")
      @GetMapping("/batch")
      public void batchByIds(@RequestParam("param") String param){
         System.out.println("测试AOP业务");
      }
   }
   ```

5. 返回结果![image-20240711200450818](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407112004919.png)

## 限流组件
### 方式一：AOP

一段时间内进行**流量限流**（访问方法次数），支持**可配置，可拔插，可通用，高可用（高并发）**

==Redis+Lua脚本+AOP+反射+自定义注解==

1. 引入aop依赖和redis依赖

   ```xml
   <!--aspect-jweaver依赖，支持切入点表达式，aop注解等-->
   <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.22</version>
   </dependency>
   <!--redis-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
      <version>2.7.12</version>
   </dependency>
   ```

2. 启动类或配置类上添加注解

   ```java
   @EnableAspectJAuProxy //开启AOP自动代理，启用AspectJ风格的AOP
   ```

3. `application.yml`配置，连接redis

   ```yml
   spring:
   	data:
   		redis:
   			database: 0
   			host: 127.0.0.1
   			port: 6379
   			password: 
   			lettuce:
   				pool:
           			max-active: 8 	 # 最大连接数，负值表示没有限制，默认8
           			max-idle: 8 	 # 最大空闲连接，默认8
           			min-idle: 0  	 # 最小空闲连接，默认0
           			max-wait: -1ms  # 最大阻塞等待时间，负值表示没限制，默认-1
   ```

4. `RedisConfig.java`配置，此组件直接使用的 `StringRedisTemplate`

   ```java
   @Configuration
   public class RedisConfig{
       @Bean
       public RedisTemplate<String,Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory){
           RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();
           redisTemplate.setConnectionFactory(lettuceConnectionFactory);
           //设置key序列化方式string
           redisTemplate.setKeySerializer(new StringRedisSerializer());
           redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
           redisTemplate.setHashKeySerializer(new StringRedisSerializer());
           redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
           redisTemplate.afterPropertiesSet();
           return redisTemplate;
       }
   }
   ```

5. 自定义注解

   ```java
   @Target(ElementType.METHOD) // 注解生效目标（方法）
   @Retention(RetentionPolicy.RUNTIME) // 保留到运行时
   @Documented // 在Javadoc 中显示它
   public @interface RedisLimitAnnotation {
       // 资源的key，唯一标记
       String key() default ""; 
       // 最多访问次数限制
       long permitsPerSecond() default 3; 
       //过期时间,默认30s内超过3次访问就提醒
       long expire() default 30;
       //超流提醒消息
       String msg() default "default message:系统繁忙，请稍后再试"; 
   }
   ```

6. `RedisLimitAop.java`切面类

   ```java
   @Slf4j
   @Aspect
   @Component
   public class RedisLimitAop{
      Object result = null;
      // redis 字符类操纵模版   
      @Resource 
      private StringRedisTemplate stringRedisTemplate;
   
      private DefaultRedisScript<Long> redisLuaScript;
      // 依赖注入后，初始化方法执行前，Lua脚本配置，以便调用
      @PostConstruct
      public void init(){
         redisLuaScript = new DefalutRedisScript<>();
         redisLuaScript.setResultType(Long.class);
         // lua 脚本资源 /resource/rateLimiter.lua
         redisLuaScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("rateLimiter.lua")));
      }
   
      // 环绕通知
      @Around("@annotation(com..annotations.RedisLimitAnnotation)")
      public Object around(ProceedingJoinPoint pjp){
         // 获取RedisLimitAnnotation注解
         MethodSignature signature = (MethodSignature) pjp.getSignature();
         Method method = signature.getMethod();
         RedisLimitAnnotation redisLimitAnnotation = method.getAnnotation(RedisLimitAnnotation.class);
   
         if(redisLimitAnnotation!=null){
            // 获取方法，注解等信息
            String key = redisLimitAnnotation.key();
            String className = method.getDecalaringClass().getName();
            String methodName = method.getName();
   
            String limitKey = key + "\t" +className + "\t" + methodName;
            log.info(limitKey);
   
            if(key == null){
               throw new RedisLimitException("it's danger,limitKey cannnot be null");
            }
   
            long limit = redisLimitAnnotation.permitsPerSecond();
            long expire = redisLimitAnnotation.expire();
            List<String> keys = new ArrayList<>();
            keys.add(key);
   
            // 记录 访问次数
            Long count = stringRedisTemplate.execute(
               redisLuaScript,
               keys,
               String.valueOf(limit),
               String.valueOf(expire));
            
            System.out.prinfln("Access try count is" + count + "\t key="+ key);
            // 当访问次数归0，即应无法再访问
            if(count!=null && count == 0){
               System.out.println("启动限流功能key:"+ key);
               return redisLimitAnnotation.msg();
            }
         }
         
         try{
            result = pjp.proceed(); // 放行
         }catch(Throwable e){
            throw new RuntimeException(e);
         }
         
         return result;
      }
   }
   ```

7. `rateLimiter` 编写`lua`脚本

   ```lua
   -- 获取KEY，针对那个接口进行限流，lua脚本中的数组索引默认是从1开始的，而不是0
   local key = KEYS[1]
   -- 获取注解上标注的限流次数
   local limit = tonumber(ARGV[1])
   
   local curentLimit = tonumber(redis.call('get',key) or "0")
   
   -- 超过限流次数直接返回 0，否则走else
   if curentLimit + 1 > limit
   then return 0
   -- 首次直接进入
   else
      -- 自增长 1 , 原子性
      redis.call('INCRBY',key,1)
      -- 设置过期时间
      redis.call('EXPIRE',key,ARGV[2])
      return curentLimit + 1
   end
   
   -- @RedisLimitAnnotation(key = "redisLimit",permitsPerSecond = 2,expire = 1，msg = "系统繁忙，请稍后再试")
   ```

8. `RedisLimitController.java`使用

   ```java
   @GetMapping("/redis/limit/test")
   @RedisLimitAnnotation(key = "redisLimit",permitsPerSecond = 3,expire = 10,msg ="系统繁忙")
   public String redisLimit(){
      return "正常访问业务";
   }
   ```

### 方式二：拦截器
1. 自定义注解

   ```java
   // 类级别和方法级别  
   @Target({ElementType.METHOD,ElementType.TYPE})  
   @Retention(RetentionPolicy.RUNTIME)  
   public @interface RepeatSubmit {  
       long seconds() default 5;  
   }
   ```

2. 拦截器

   > 拦截所有请求，遍历所有注解@RepeatSubmit的方法或者类
   >
   > 使用Redis的setnx 设置ip+uri 判断5s内是否请求过

   ```java
   @Slf4j
   @Component
   public class RepeatSubmitInterceptor implements HandlerInterceptor {
      @Resource
      private StringRedisTemplate stringRedisTemplate;
      // 控制层接口请求方法前
      @Override
      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
         if(handler instanceof HandlerMethod) {
            HandlerMethod method = (HandlerMethod) handler;
            // 寻找方法上的注解
            RepeatSubmit repeatByMethod = AnnotationUtils.findAnnotation(method.getMethod(), RepeatSubmit.class);
            // 寻找类上的注解
            RepeatSubmit repeatByCls = AnnotationUtils.findAnnotation(method.getMethod().getClass(), RepeatSubmit.class);
            // 没有找到该注解
            if (ObjectUtil.isNull(repeatByCls) && ObjectUtil.isNull(repeatByMethod)) {
               return true;
            }
            // 否则 判断uri是否在redis中存在
            // 获取请求的ip
            String ip = request.getRemoteAddr();
            String uri = request.getRequestURI();
            Boolean bool = stringRedisTemplate.opsForValue().setIfAbsent(ip+uri, "", ObjectUtil.isNotNull(repeatByMethod) ? repeatByMethod.seconds() : repeatByCls.seconds(), TimeUnit.SECONDS);
            if (Boolean.TRUE.equals(bool)) {
               throw new RuntimeException("您5s内已请求过");
            }
         }
         return true;
      }
   }
   ```

3. 拦截器配置

   ```java
   @Configuration
   public class InterceptorConfig implements WebMvcConfigurer {
       @Resource
       private RepeatSubmitInterceptor repeatSubmitInterceptor;
       @Override
       public void addInterceptors(InterceptorRegistry registry) {
           registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns("/**");
       }
   }
   ```

   
## Redis缓存查询组件

==redis+aop+反射+El表达式==

**Spring EL 表达式:占位替换传值**

```java
String var = "#userid";
// 初始化表达式解析器
ExpressionParser parser = new SpelExpressionParser();
// 解析表达式字符串
Expression expression = parser.parseExpression(var);//#userid
// 创建评估上下文
EvaluationContext context = new StandardEvaluationContext();
// 在上下文中设置变量
context.setVariable("userid","1234");
// 输出表达式的值
System.out.println(expression.getValue(context).toString());
```

1. 引入aop依赖和redis依赖

   ```xml
   <!--aspect-jweaver依赖，支持切入点表达式，aop注解等-->
   <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.22</version>
   </dependency>
   <!--redis-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
      <version>2.7.12</version>
   </dependency>
   ```

2. 启动类或配置类上添加注解

   ```java
   @EnableAspectJAuProxy //开启AOP自动代理，启用AspectJ风格的AOP
   ```

3. `application.yml`配置，连接redis

   ```yml
   spring:
   	data:
   		redis:
   			database: 0
   			host: 127.0.0.1
   			port: 6379
   			password: 
   		lettuce:
   			pool:
   				max-active: 8
   				max-wait: -1ms
   				max-idle: 8
   				min-idle: 0
   ```

4. 注解`RedisCache`

   ```java
   @Target(ElementType.METHOD)
   @Retention(RetentionPolicy.RUNTIME)
   public @interface RedisCache{
      //约等于键的前缀prefix
      String keyPrefix();
      //Spring EL表达式，解析占位符对应的匹配value值
      String matchValue();
   }
   ```

5. 切面类 `RedisCacheAspect.java`

   ```java
   @Aspect
   @Component
   public class RedisCacheAspect{
      @Resource 
      private RedisTemplate redisTemplate;
   
      @Pointcut("@annotation(com..RedisCache)")
      public void cachePointCut(){}
   
      @Around("cachePointCut()")
      public Object doCache(ProceedingJoinPoint pjp){
         Object result = null;
         try{
            //1. 获取方法签名
            MethodSignatrue signatrue=(MethodSignature) pjp.getSignature();
            Method method = signature.getMethod();
            
            //2. 获取注解和属性
            RedisCache redisCache = method.getAnnotation(RedisCache.class);
            String keyPrefix = redisCache.keyPrefix();
            String matchValueSpringEl = redisCache.matchValue();
            
            //3. SpringEL 解析器 和 评估上下文
            ExpressionParser parser = new SpelExpressionParser();
            // 待解析，取决于上下文context
            Expression expression = parser.parseExpression(matchValueSpringEl);
            EvaluationContext context = new StandardEvaluationContext();
            
            //4, 获取方法里面的形参个数
            Object[] args = pjp.getArgs();
            DefaultParameterNmaeDiscoverer discoverer = new DefaultParameterNmaeDiscoverer();
            String[] parameterNames = discoverer.getParameterNames(method);
            
            for(int i = 0; i< parameterNames.length; i++){
               System.out.println("获得方法里参数名和值："+parameterNames[i]+"\t"+args[i].toString());
               // 在上下文中设置变量 （参数名，参数值）（id，123）
               context.setVariable(parameterName[i],args[i].toString());
            }
            
            //5. 从context上下文中获取 expressoin 待解析的表达式字符串，拼接 user:123
            String key = keyPrefix +":" expression.getValue(context).toString();
            System.out.println("-----------拼接redis的最终key形式:"+key)
               
            //6. 先在redis中查询   
            result = redisTemplate.opsForValue().get(key);
            if(result != null){
               System.out.println("---------redis里面有，直接返回，不查mysql："+result);
               return result;
            }
            
            //7. redis中没有，通过mysql查找或后续业务处理
            result = pjp.proceed(); // 主业务逻辑查询mysql，放行
            
            //8. mysql结束，将数据回写到redis中，进行缓存
            if(result != null){
               System.out.println("------------redis无，将数据缓存入redis:"+result);
               redisTemplate.opsForValue.set(key,result);
            }
         }catch(Throwable throwable){
            throwable.printStackTrace();
         }
   
         return result;
      }
   }
   ```

6. Service层 `RedisCacheService.java`

   ```java
   // EL表达式 “#”后面的内容会被替代，即会替代为真实值，在redis中查询
   @RedisCache(keyPrefix = "user",matchValue = "#id")
   public User getUserById(Integer id){
      return userMapper.selectById(id);
   }
   ```


## 直播弹幕

1. redis依赖

   ```xml
   <!--redis-->
   <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
      <version>2.7.12</version>
   </dependency>
   ```

2. `application.yml`配置，连接redis

   ```yml
   spring:
   	data:
   		redis:
   			database: 0
   			host: 127.0.0.1
   			port: 6379
   			password: 
   			lettuce:
   				pool:
           			max-active: 8 	 # 最大连接数，负值表示没有限制，默认8
           			max-idle: 8 	 # 最大空闲连接，默认8
           			min-idle: 0  	 # 最小空闲连接，默认0
           			max-wait: -1ms  # 最大阻塞等待时间，负值表示没限制，默认-1
   ```

3. `RedisConfig.java`配置，或者直接使用 `StringRedisTemplate`

   ```java
   @Configuration
   public class RedisConfig{
       @Bean
       public RedisTemplate<String,Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory){
           RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();
           redisTemplate.setConnectionFactory(lettuceConnectionFactory);
           //设置key序列化方式string
           redisTemplate.setKeySerializer(new StringRedisSerializer());
           redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
           redisTemplate.setHashKeySerializer(new StringRedisSerializer());
           redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
           redisTemplate.afterPropertiesSet();
           return redisTemplate;
       }
   }
   ```

   

弹幕实体 `Content.java`

```java
@Data
public class Content implements Serializable{
   @Serial
   private static final long serialVersionUID = 4620100454885919297L;
   private Long id; 
   private Integer userId;
   private String content;
}
```

常量工具类 `Constans.java`

```java
public class Constants{
	//room:100 即 room:100 是redis key
   public static final String ROOM_KEY = "room:";
   // 观众进入直播间时间戳，读取弹幕数据  user:room:time:12 12就是UserId观众ID
   public static final String ROOM_USER_TIME_KEY = "user:room:time:";
}
```

Service -`TaskService.java`，不需要controller等等，项目启动后，将持续打印

```java
@Slf4j
@Service
public class TaskService{
    @Resource
    private RedisTemplate redisTemplate;

    // 模拟直播间的数据
    @PostConstruct
    public void init(){
        log.info("启动初始化，直播间弹幕case开始......");

        // 启动线程，模拟直播间观众发言
        new Thread(()->{
            // 原子性
            AtomicInteger atomicInteger = new AtomicInteger();
            while(true){
                // 模拟各种发言，5秒一批数据.100条结束
                if(atomicInteger.get()==100){
                    break;
                }
                //模拟直播房间号100 的弹幕数据，拼接redis的key--》 room：100
                String key = Constants.ROOM_KEY+100;
                Random random = new Random();

                for(int i=1;i<=5;i++){
                    Content content = new Content();
                    content.setId(IdUtil.createSnowflake(1,1).nextId());

                    int id = random.nextInt(1000)+1; //随机1~1000
                    content.setUserId(id);

                    int temp = random.nextInt(100)+1;//随机1~100
                    content.setContent("发表言论："+temp+"\t"+ RandomUtil.randomString(temp));

                    long time = System.currentTimeMillis()/1000; //时间戳

                    // 对应 redis命令 zadd room:100 time content
                    // ZADD key score1 memeber1 [score2 member2] [score3 member3]
                    // 向有序集合添加一个或多个成员，或者更新已存在成员的分数
                    this.redisTemplate.opsForZSet().add(key,content,time);
                    log.info("模拟直播间100号的发言弹幕数据：{}",content);
                }
                // TODO 在分布式系统中，建议用 xxl-job来实现定时
                try{
                    TimeUnit.SECONDS.sleep(5);
                }catch(InterruptedException e){
                    e.printStackTrace();
                }

                //模拟观众各种发言，5秒一批数据，到100自动退出
                atomicInteger.getAndIncrement();

                System.out.println("---------------每间隔5秒，拉取一次最新聊天记录");
            }
        },"init_Live_Data").start();
    }
}
```

controller- `LiveController.java`

```java
@Slf4j
@RestController
public class LiveController{
   @Resource
   priavte RedisTemplate redisTemplate;

   //某个用户（userId=12）第一次进入房间，放回最新的前5条数据
   @GetMapping(value="/goRoom")
   public List<Content> goRoom(Integer roomId,Integer userId){

      List<Content> list = new ArrayList<>();
      String key = Constants.ROOM_KEY+roomId;
      // 进入房间，返回最新的前5条数据,对应redis ZREVRANGE room:100 0 4 WITHSCORES
      Set<ZSetOperations.TypedTuple<Content>> range = this.redisTemplate.opsForZSet().reverseRangeWithScores(key, 0, 4);
      for (ZSetOperations.TypedTuple<Content> obj: range){
         list.add(obj.getValue());
         log.info("首次访问房间获取最新前5条弹幕content={},score={}",obj.getValue(),obj.getScore());
      }
      // user：room：time：12    12就是userId的观众ID
      String userKey = Constants.ROOM_USER_TIME_KEY+userId;
      Long now = System.currentTimeMillis()/1000;
      // 把当前的时间戳T，保持到redis，供下次拉取使用，看过的不在推送
      this.redisTemplate.opsForValue().set(userKey,now);
      return list;
   }

   // 登录房间后持续观看，定时任务或者xxl-job 客户端间隔5秒拉取数据
   @GetMapping("/commentList")
   public List<Content> commentList(Integer roomId, Integer userId) {
      List<Content> list = new ArrayList<>();
      String key = Constants.ROOM_KEY + roomId;
      String userKey = Constants.ROOM_USER_TIME_KEY + userId;
      long now = System.currentTimeMillis() / 1000;
      // 获取上次读取时间
      long ago = Long.parseLong(this.redisTemplate.opsForValue().get(userKey).toString());
      log.info("查找时间范围：{} {}", ago, now);
      Set<ZSetOperations.TypedTuple<Content>> range = this.redisTemplate.opsForZSet().rangeByScoreWithScores(key, ago, now);
      for (ZSetOperations.TypedTuple<Content> obj : range) {
         list.add(obj.getValue());
         log.info("持续观看直播content={},score={}", obj.getValue(), obj.getScore());
      }
      now = System.currentTimeMillis() / 1000;
      // 把当前的时间戳T，保持到redis，供下次拉取使用，看过的不在推送
      this.redisTemplate.opsForValue().set(userKey, now);
      return list;
   }
}
```

