## Aop实现

> aop：不影响源程序的情况下，添加需要实现的操作

1. 在springboot中的pom.xml加入坐标

```xml
    <!--aspect-jweaver依赖，支持切入点表达式，aop注解等-->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.22</version>
        </dependency>
```

2. 在主启动入口添加注解

```java
@EnableAspectJAutoProxy
```

3. 新建aop组件，添加注释

```java
@Component  // 标明组件注册到IOC容器中
@Aspect  // 表名为Aop
public class UserAop{
   
}
```

4. 建立切入点@Pointcut

```java
// 切入点为UserController下的selectAll查询所有方法
@Pointcut(value = "execution(* org..UserController.selectAll(..))")
public void aopTest() {}//空方法
```

5. 建立通知方法

返回值需要为Object

```java
// 环绕通知，计算查询时间
@Around(value = "aopTest()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
Object[] args = pjp.getArgs();//获取传递进方法的参数，可以在此修改后，再运行proceed方法

// Signature是一个接口，它提供了对被通知方法的描述。
// 在Spring框架的AOP API中，Signature接口是获取被拦截方法的信息（如方法名称、返回类型等）的一种方式。
Signature signature = pjp.getSignature();
String className = signature.getDeclaringTypeName();
String methodName = signature.getName();

System.out.println("开始查询");
Long start = System.currentTimeMillis();
Object ret = pjp.proceed(args);// 程序运行
Long end= System.currentTimeMillis();
System.out.println("查询完成");

System.out.println("方法执行："+className+"."+methodName+"--->"+(end-start)+"ms");
return  ret;
}
```



```java
// 在执行方法前
// 获取传递进方法的参数，以数组方式打印
@Before("beforeSelectId()")
public void before(JoinPoint jp) {
Object[] args=jp.getArgs();
System.out.println(Arrays.toString(args));
System.out.println("before advice...");
}
```



```java
// 通知：去除传递进方法的参数两侧字符串空格
// 输入的百度网盘资源的密码
//@Around()
public Object trimStr(ProceedingJoinPoint pjp) throws Throwable {
Object[] args = pjp.getArgs();
for (int i = 0; i < args.length; i++) {
    //判断参数是否是字符串
    if(args[i].getClass().equals(String.class)){
        args[i] = args[i].toString().trim();
    }
}
return pjp.proceed(args);
}
```

获取参数

arg是一个对象，如SysUserGood{id=?,userId=?,goodId=?}

```java
    @Around(value="join()")
    public Object joinAround(ProceedingJoinPoint pjp) throws Throwable {
        Object res = pjp.proceed();
        Object[] args = pjp.getArgs();
        System.out.println("加入购物车");
        for (Object arg : args) {
            if(arg instanceof SysUserGood sysUserGood){
                System.out.println(sysUserGood.getUserId());
                System.out.println(sysUserGood.getGoodId());
            }else{
                System.out.println("无法识别的参数类型: " + arg.getClass().getName());
            }
        }
        return res;
    }
```

![img](https://cdn.nlark.com/yuque/0/2024/png/40495198/1714006084242-c8675517-ba3e-4f52-a4b0-dfa534efacb0.png)

## 通知执行顺序

#### 正常情况

![image-20240711171704152](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407111717229.png)

#### 异常情况

当业务 PayServiceImpl抛出异常时，==@Around 环绕通知的后置通知会失效==

![image-20240711171842061](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407111718106.png)