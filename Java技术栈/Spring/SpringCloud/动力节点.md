==资料下载==：[动力节点 power-mall](https://pan.baidu.com/s/1eIpQ72vevPWtn9br5jeqVQ?pwd=dljd#list/path=%2F&parentPath=%2Fsharelink3355579678-1021028189138492)

# Maven多模块管理

==父工程==必须遵守以下2点：

1. 删除src目录
2. 将packaging标签设置为pom `<packaging>pom</packaging>`

父工程`dependencies`标签中的依赖会被后代无条件全部继承

```xml
<dependencies>
   <dependency>
   	<groupId>con.mysql</groupId>
      <artifactId>myslq-connection-j</artifactId>
      <version>8.0.32</version>
   </dependency>
</dependencies>
```

父工程`dependencyManagement`标签中声明的依赖，后代无法直接继承，需要声明才可继承,可在父工程中指定版本

```xml
<properties>
	<mysql.version>8.0.32</mysql.version>
</properties>
<dependencyManagement>
	<dependencies>
   <dependency>
   	<groupId>com.mysql</groupId>
      <artifactId>myslq-connection-j</artifactId>
      <version>${mysql.version}</version>
   </dependency>
</dependencies>
</dependencyManagement>
```

## 项目结构的搭建

新建java项目，Maven构建，新增模块

- 总父工程 power-mall ，删除 src 目录，<packaging>标签 改为pom
  - 基础设置服务模块（cloud-iaas）删除src，pom打包
    - 认证授权模块（auth-server）
    - 网关服务模块（gateway-server）
  - 项目业务模块（power-business）删除src，pom打包
    - 系统管理模块（manager-service）
    - 产品管理模块（product-service）
    - 门店管理模块（store-service）
    - 会员管理模块（member-service）
    - 购物车管理模块（cart-service）
    - 订单管理模块（order-service）
    - 搜索管理模块（search-service）
  - 项目公共模块（power-common）删除src，pom打包
    - 公共基础模块（common-base）
    - 公共核心/业务模块（common-core/business）

## 编写总父工程pom

[spring.io官网](https://spring.io/projects/spring-cloud)

springcloud与springboot版本对照表 [Alibaba版本对照](https://spring-cloud-alibaba-group.github.io/zh-cn/docs/2023.0.0.0-RC1/overview/version-explain#2023x-%E5%88%86%E6%94%AF)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407172203948.png" alt="image-20240717220354862" style="zoom:67%;float:left" />

本次搭建版本为 

- springboot 3.2.7
- springcloud 2023.0.1
- springcloudAlibaba 2023.0.1.0

`pom.xml`

```xml

```

F:/Typora文件/Java技术栈/其他/swagger使用.md#常用注解)

## 网关服务的作用

![image-20240718095646708](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407180956868.png)

### 引入依赖

`pom.xml`

> ==注意==：网关模块需要排除SpringSecurity依赖

```xml
    <dependencies>
        <!--nacos服务发现依赖-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
        <!--nacos配置中心-->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>
        <!--gateway网关依赖-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--spring-cloud负载均衡-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-loadbalancer</artifactId>
        </dependency>
        <!--redis依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>com.zyr</groupId>
            <artifactId>common-base</artifactId>
            <version>1.0-SNAPSHOT</version>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-security</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-core</artifactId>
        </dependency>
    </dependencies>
```

> 导入依赖时，如果出现**错误** 未解析的依赖项： org.springframework:spring-webflux:jar:6.1.10
>
> 尝试快照**强制导入**

### 配置bootstrap.yml

> bootstrap.yml在Spring Boot应用程序启动的非常早期阶段就被加载，甚至在application.yml之前，bootstrap.yml通常用于配置那些**在应用程序启动前就需要的信息**

在resource文件夹下新建bootstrap.yml文件

[nacos服务](http://localhost:8848/nacos)中新建**命名空间<powermall>** ，复制**命名空间ID**到文件的`namespace`

`bootstrap.yml`

```yml
spring:
  application:
    name: gateway-server
  cloud:
    nacos:
      server-addr: 127.0.0.1:8848
      username: nacos
      password: nacos
      discovery:
        namespace: bb5acc71-bcce-4f65-a19f-c158d1b9f309
        service: ${spring.application.name}
      config:
        namespace: ${spring.cloud.nacos.discovery.namespace}
        group: DEFAULT_GROUP
        prefix: ${spring.application.name}
        file-extension: yml
        shared-configs: # nacos共享配置文件
          - application.${spring.cloud.nacos.config.file-extension}
white:
  allowUrl:
    - /auth/login
```

### nacos配置中心

将部分配置，通过**nacos配置中心**管理

==注意：新建配置项时，要选择对应的命名空间==

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407181359243.png" alt="image-20240718135954142" style="zoom:67%;float:left" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407181051199.png" alt="image-20240718105100028" />

### 注册gateway服务

```java
@SpringBootApplication
@EnableDiscoveryClient // 将当前应用注册到服务发现nacos （springboot3 可省略）
public class GatewayServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayServerApplication.class, args);
    }
}
```

# 分布式项目实操

约定验证令牌（TOKEN）存放在请求头中的Authorization bearer token

> ==将Token存储于Redis==：
>
> 当用户退出登录时，只要Token未过期，就可能被非法获取，并通过其登录
>
> 所以将Token存储一份于redis，当用户退出登录时，清除redis中的token，当进行token验证时，除了token合法性，还需要判断redis中是否存在
>
> **前端向后端传递token**：token放置于Request的Header，键为Authorization，值为Bearer+token
>
> **后端存储token到redis**：键为LOGIN_TOKEN：token，值为Authorization的Principle用户信息凭证

![右键浏览器打开](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407282115496.svg)

![image-20240728225048615](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202407282250726.png)



## Common-core模块

用于将token转化为Authorization存储在SecurityContextHodler

`ResourceServerConfig.java`

> Common-core下的SecurityFitlerChain，区别与Auth-server模块的SercurityFilterChain，该过滤器链，主要用于为各个依赖该模块的微服务进行 token->Authorization认证

```java
@Slf4j
@Configuration
@EnableMethodSecurity
public class ResourceServerConfig {
    @Resource
    private TokenTranslationFilter tokenTranslationFilter;

    @Bean
    public SecurityFilterChain resourceFilterChain(HttpSecurity http) throws Exception {
        http.addFilterBefore(tokenTranslationFilter, UsernamePasswordAuthenticationFilter.class);
        // 由于使用token认证，关闭一跨域请求伪造，csrf防御，session管理
        http.csrf(AbstractHttpConfigurer::disable)
                .cors(AbstractHttpConfigurer::disable)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        //
        // 配置处理携带token但权限不足的请求
        http.exceptionHandling(e -> {
            e.authenticationEntryPoint(authenticationEntryPoint()) // 处理没有携带token的请求
                    .accessDeniedHandler(accessDeniedHandler()); // 处理携带token，但是权限不足的请求
        });
        // 资源放行路径
        http.authorizeHttpRequests(auth -> auth
                // 资源放行路径
                .requestMatchers("/test").permitAll()
                .anyRequest().authenticated());
        // ######################## 过滤器 #############
        http.addFilterBefore(tokenTranslationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    /**
     * 未认证处理
     * @return
     */
    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return (request, response, authException) -> {
            String localizedMessage = "未认证，需要登录";// authException.getLocalizedMessage();
            HashMap<String, Object> result = new HashMap<>();
            result.put("code", -1);
            result.put("msg", localizedMessage);
            // 利用fastjson工具，将对象转换成json字符串
            String json = JSON.toJSONString(result);
            // 返回json数据到前端
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().println(json);
        };
    }

    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return (request, response, accessDeniedException) -> {
            String res = JSONObject.toJSONString(Result.error(700, "无权限访问，请联系管理员"), SerializerFeature.DisableCircularReferenceDetect);
            response.setContentType("application/json;charset=utf-8");
            ServletOutputStream out = response.getOutputStream();
            out.write(res.getBytes(StandardCharsets.UTF_8));
            out.flush();
            out.close();
        };
    }
}
```

`TokenTranslationFilter.java`

> common-core模块，所有微服务均引用，将TokenTranslationFtiler填加在SecuriltyFilterChain中，该过滤器需要在UsernamePasswordAuthorizationFilfer前，用于将token解析为Authorization放在SecurityContextHolder上下文中，用于认证授权，同时进行token续签
>
> `http.addFilterBefore(tokenTranslation,UsernamePasswordAuthorizationFilter.class)`

```java
@Slf4j
@Component
public class TokenTranslationFilter extends OncePerRequestFilter {
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    /**
     * token转换过滤器
     *  前提：
     *  只负责处理携带token的请求，然后将认证的用户信息转换出来
     *  没有携带token的请求，交给security资源配置类中的处理器进行处理
     *  1.获取token
     *  2.判断token是否有值
     *      有：
     *          token转换为用户信息
     *          将用户信息转换为security框架认识的用户信息对象
     *          再将认识的用户信息对象存放到当前资源服务的容器中
     * @param request
     * @param response
     * @param filterChain
     * @throws ServletException
     * @throws IOException
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 从请求头中获取Authorization的值，格式为:bearer token
        String authorizationValue = request.getHeader(AuthConstants.AUTHORIZATION);
        // 判断是否有值
        if (StringUtils.hasText(authorizationValue)) {
            // 获取token
            String token = authorizationValue.replaceFirst(AuthConstants.BEARER, "");
            // 判断token是否有值
            if (StringUtils.hasText(token)) {
                // 解决token续签的问题
                // 从redis中获取token的存活时长
                Long expire = stringRedisTemplate.getExpire(AuthConstants.LOGIN_TOKEN_PREFIX + token);
                // 判断是否超过系统指定的阈值
                if (expire < JwtConstants.TOKEN_EXPIRE_THRESHOLD_TIME) {
                    // 给当前用户的token续签（本质就是增加token在redis中的存活时长）
                    stringRedisTemplate.expire(AuthConstants.LOGIN_TOKEN_PREFIX+token,JwtConstants.JWT_EXPIRATION, TimeUnit.SECONDS);
                }


                // 从redis中获取json格式字符串的认证用户信息
                String userJsonStr = stringRedisTemplate.opsForValue().get(AuthConstants.LOGIN_TOKEN_PREFIX + token);
                // 将json格式字符串的认证用户信息转换为认证用户对象
                SecurityUser securityUser = JSONObject.parseObject(userJsonStr, SecurityUser.class);
                // 处理权限
                Set<SimpleGrantedAuthority> collect = securityUser.getPermissions().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());
                // 创建UsernamePasswordAuthenticationToken对象
                UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(securityUser,null,collect);

                // 将认证用户对象存放到当前模块的上下方中
                SecurityContextHolder.getContext().setAuthentication(authenticationToken);
            }
        }
        filterChain.doFilter(request,response);
    }
}
```

`FeignInteceptor.java`

> 用于在微服务间调用传递token，便于common-core下的TokenTranslationFilter解析为Authorizatoin放在SecurityContextHolder下用于认证授权

```java
@Slf4j
@Component
public class FeignInterceptor implements RequestInterceptor {

    /**
     * 浏览器-->服务-->服务
     * @param requestTemplate
     */
    @Override
    public void apply(RequestTemplate requestTemplate) {
        // 获取当前请求的上下文对象
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        // 判断是否有值
        if (ObjectUtil.isNotNull(requestAttributes)) {
            // 获取请求对象
            HttpServletRequest request = requestAttributes.getRequest();
            // 判断是否有值
            if (ObjectUtil.isNotNull(request)) {
                // 获取当前请求头中的token值，传递到一下一个请求对象的请求头中
                String authorization = request.getHeader(AuthConstants.AUTHORIZATION);
                requestTemplate.header(AuthConstants.AUTHORIZATION,authorization);
                return;
            }
        }
        /**
         * 服务-->服务
         */
        requestTemplate.header(AuthConstants.AUTHORIZATION,AuthConstants.BEARER+"ea2e88e9-907e-44f4-8111-ffc91057e095");

    }
}
```

## Gate-server模块

请求统一路由转发，并验证token

> 在网关模块的全局过滤器中，判断请求路径是否是白名单，以及token的有效性合法性，是否存在于redis中，同时设置Order

```java
@Slf4j
@Component
public class AuthFilter implements GlobalFilter, Ordered {
    @Resource
    WhiteUrlConfig whiteUrlConfig;
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    /**
     * 校验token
     * 1.获取请求
     * 2.判断白名单路径
     *      ·放行
     *      ·不放行，身份认证
     * @param exchange
     * @param chain
     * @return
     */
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().toString();
        if(whiteUrlConfig.getAllowUrl().contains(path)){
            // 在白名单内，放行
            return chain.filter(exchange);
        }
        // 从约定位置获取 Authorization，值格式: bearer token
        String authorizationValue = request.getHeaders().getFirst(AuthConstants.AUTHORIZATION);
        if(StringUtils.hasText(authorizationValue)){
            //从Authorization获取token,消除前缀 bearer
            String tokenValue = authorizationValue.replaceFirst(AuthConstants.BEARER,"");
            // 验证token加密比对
            if (!JwtUtils.verify(tokenValue)) {
                log.info("非法的token");
            }
            // 如果token有值，并且redis中存在
            if (StringUtils.hasText(tokenValue) && Boolean.TRUE.equals(stringRedisTemplate.hasKey(AuthConstants.LOGIN_TOKEN_PREFIX + tokenValue))) {
                //身份验证通过，放行
                return chain.filter(exchange);
            }
        }
        // 流程如果走到这，说明身份验证失败,返回响应结果
        log.error("拦截非法请求:时间:{}，请求API路径:{}", Instant.now(),path);
        ServerHttpResponse response = exchange.getResponse();
        response.getHeaders().set(HttpConstants.CONTENT_TYPE,HttpConstants.application_json);
        // 响应消息
        Result<Object> result = Result.error(BusinessEnum.UN_AUTHORIZATION);
        // 创建ObjectMapper对象,用于JSON序列化和反序列化
        ObjectMapper objectMapper = new ObjectMapper();
        byte[] bytes;
        try {
            // 转化为JSON字节码
            bytes = objectMapper.writeValueAsBytes(result);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        // 缓冲封装
        DataBuffer dataBUffer = response.bufferFactory().wrap(bytes);
        return response.writeWith(Mono.just(dataBUffer));
    }

    /**
     * 保证最先经过的过滤器
     * @return
     */
    @Override
    public int getOrder() {
        return -5;
    }
}
```

`bootstrap.yml`

> 设置路由，用于前端统一请求网关端口，网关根据请求路径规则，分配到不同的微服务实例，lb：(loadbalancer)用于负载均衡
>
> 动态路由似乎不好使？

```yml
spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true #动态路由
      routes: # 结合手动定义路由规则
        - id: auth-server # 自定义id唯一
          uri: lb://auth-server # 请求的nacos中注册的微服务名称
          predicates:
            - Path=/auth/** # 映射的匹配路径
        - id: user-server
          uri: lb://user-server
          predicates:
            - Path=/users/**
```



## Auth-server模块

用于生成Token，返回给前端

`UserServiceImpl.java`

> **登录**：用于接受前端传递的LogVo（封装的username,password），将其放在UsernamePasswordAuthenticationToken中，封装为Authorization用于authenticationManager.authenticate方法比对，比对从数据库中查询的用户名和密码是否相同，如果相同，返回封装好的Authorization(Principle 用户信息凭证)，并存放在SecurityContextHolder上下文
>
> **登出：**用于接受前端的Request，获取Header中的Authorization ，值为Bearer+token

```java
@Slf4j
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
   @Resource
   private AuthenticationManager authenticationManager;
   @Resource
   private StringRedisTemplate stringRedisTemplate;

   // 登录方法
   @Override
   public Result<T> login(LoginVo loginVo) {
      UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(loginVo.getUsername(), loginVo.getPassword());
      Authentication authentication = authenticationManager.authenticate(authToken);
      // 设置认证过后的authentication到securityContextHolder上下文
      SecurityContextHolder.getContext().setAuthentication(authentication);
      if (authentication.isAuthenticated()) {
         Object principal = authentication.getPrincipal();
         SecurityUser securityUser = (SecurityUser) principal;
         HashMap<String, String> map = new HashMap<>();
         map.put("id", securityUser.getUser().getId().toString());
         map.put("username", securityUser.getUser().getUsername());
         String token = JwtUtils.generateToken(map);
         String jsonPrincipal = JSONObject.toJSONString(principal);
         // 前缀+token 作为 key , principle作为value，过期时间30min
         stringRedisTemplate.opsForValue().set(AuthConstants.LOGIN_TOKEN_PREFIX + token, jsonPrincipal, Duration.ofSeconds(JwtConstants.JWT_EXPIRATION));
         // 返回token给前端
         return Result.success(token);
      } else {
         return Result.error(BusinessEnum.OPERATION_FAIL);
      }
   }
   // 登出方法
   @Override
   public Result<T> logout(HttpServletRequest request) {
      String header = request.getHeader(AuthConstants.AUTHORIZATION);
      if (header != null && header.startsWith(AuthConstants.BEARER)) {
         // 删除redis中的token
         Boolean delete = stringRedisTemplate.delete(AuthConstants.LOGIN_TOKEN_PREFIX + header.replace(AuthConstants.BEARER, ""));
         if (Boolean.TRUE.equals(delete)){
            return Result.success();
         }
      }
      return Result.error(500,"登出失败");
   }
}
```

`UserDetailsServiceImpl.java`

> 实现UserDetailsServceI接口， ==重要== loadUserByUsername()方法，用于从数据库中加载该用户名的数据，用于AuthenorizationManager.authorication()方法比对用户名和密码，同时将权限赋值给SecurityUser 实现了 UserDetails

```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Resource
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userMapper.selectOne(new LambdaQueryWrapper<User>().eq(User::getUsername, username));
        if (ObjectUtil.isNull(user)) {
            throw new CustomizeException("该用户不存在");
        } else {
            List<String> list = new ArrayList<>();
            String permissions = user.getPermissions();
            if (permissions.contains(",")) {
                list.addAll(Arrays.asList(permissions.split(",")));
            } else {
                list.add(permissions);
            }
            return new SecurityUser(user, list);
        }
    }
}

```

`SecurityUser.java`

> 用于封装 数据库的 user表实体，实现UserDetails接口，用于统一loadUserByUsername方法返回值

```java
@Getter
@Setter
public class SecurityUser implements UserDetails {
    @Serial
    private static final long serialVersionUID = 3054755309786351190L;
    private User user;
    //存储权限信息
    private List<String> permissions;
    public SecurityUser(User user,List<String> permissions){
        this.user = user;
        this.permissions = permissions;
    }
    //存储SpringSecurity所需要的权限信息的集合
    @JSONField(serialize = false)
    private List<GrantedAuthority> authorities;

    @Override
    public  Collection<? extends GrantedAuthority> getAuthorities() {
        if(authorities!=null){
            return authorities;
        }
        authorities = permissions.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
        return authorities;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }
   
	// 重新的方法....，赋值为true
}

```

## User-server模块

使用==FeignClient==

`OrderFeignClient.java`

```java
//要调用的远程服务名称（nacos），以及失败后的回滚
@FeignClient(name = "order-server",fallback = OrderFeignClientFallback.class)
public interface OrderFeignClient {
    @GetMapping("/orders/getOrders/{userId}")
    List<Order> getListByUserId(@PathVariable("userId") long userId);
}
```

失败回滚策略

```java
@Slf4j
@Component
public class OrderFeignClientFallback implements OrderFeignClient {
    @Override
    public List<Order> getListByUserId(long userId) {
        log.error("远程调用order.getListAndOrder接口失败");
        return null;
    }
}
```

调用的Order-server模块的接口

```java
@RestController
@RequestMapping("/orders")
public class OrderController {
    @Resource
    private OrderService orderService;
    @GetMapping("/getOrders/{userId}")
    public List<Order> getListByUserId(@PathVariable("userId") long userId){
        return orderService.getListByUserId(userId);
    }
}
```

## Common-base模块

用于存储所有的数据库实体

一些数据常量（在接口中声明）

一些utils工具

返回模版(LoginVo,Result...)

## 错误合集

==错误合集==

1. 微服务项目下，需要确保所有微服务的包名相同，如`java.com.zyr...`，尤其是公共模块，由于没有启动类，如果不在同一包下，那导入公共模块的模块，就无法使用公共模块下的Bean等
2. @GetMapping是URL传参，后端无法使用@RequestBody来接受响应体
