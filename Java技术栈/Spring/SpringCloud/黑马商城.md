# 认识微服务

## 单体架构

**单体架构:**将业务的所有功能集中在一个项目中开发，打成一个包部署

**优点:**

- 架构简单
- 部署成本低

**缺点:**

- 团队协作成本高
- 系统发布效率低
- 系统可用性差（tomcat资源不足，造成延迟卡顿崩溃）

**总结：**适合开发功能相对简单，规模较小的项目

## 微服务

**微服务**架构：是服务化思想指导下的一套最佳实践架构方案。服务化，就是把单体架构中的功能模块拆分成多个独立项目

- 粒度小
- 团队自治
- 服务自治

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061740968.png" alt="image-20240605190009778" style="zoom:67%;" />

## SpringCloud

SpringCloud是目前国内使用最广泛的微服务框架。官网：https://spring.io/projects/spring-cloud

SpringCloud集成了各种微服务功能组件，例如SpringCloudAlibaba,并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验：

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061740969.png" alt="image-20240605190401253" style="zoom:67%;" />



## 导入黑马商城

[黑马商城](https://pan.baidu.com/s/1JX0fhmV82mgPeBBbAMNV0w?pwd=7988#list/path=%2Fsharelink3232509500-557912393106311%2F0%E3%80%812024%E6%9C%80%E6%96%B0SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%9E%E6%88%98%2FSpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E8%B5%84%E6%96%99%2Fday03-%E5%BE%AE%E6%9C%8D%E5%8A%A101%2F%E8%B5%84%E6%96%99&parentPath=%2Fsharelink3232509500-557912393106311)

1. docker创建自定义**网络** hm-net `docker network create hm-net`
2. docker拉取**mysql**最新镜像 `docker pull mysql`
3. 创建mysql**本地目录（映射）**，并导入conf(hm.cnf)、init(hmall.sql)资源，创建data文件夹。创建运行mysql容器，并将本地目录与容器目录映射

   ```shell
    docker run -d 
    --name mysql # 容器名
    -p 3306:3306 # 宿主机端口：容器内端口
    -e TZ=Asia/Shanghai 
    -e MYSQL_ROOT_PASSWORD=123456 
    -v /F/Docker/volumes/mysql/data:/var/lib/mysql 
    -v /F/Docker/volumes/mysql/conf:/etc/mysql/conf.d 
    -v /F/Docker/volumes/mysql/init:/docker-entrypoint-initdb.d 
    --network hm-net # 连接网络
    mysql # 镜像名 repository:tag
   ```

4. 在navicat中新建连接 **端口**(docker宿主机端口):3306 ,**主机**(local:host): localhost ,**密码**（docker.mysql）：123456

5. 打开java黑马商城项目hmall，在项目结构中配置**JDK**为corretto-11(JDK11)

6. 在**启动项**中有效配置文件(active profile)配置 `local`,将优先启动application-local.yml的==设置==

   ```yml
   # dev java容器连接mysql容器，由于创建了本地目录映射，所以数据库数据一致
   hm: 
   	db: 
   		host: mysql
   		pw: 123456
   # local docker本地数据库连接 
   hm:
   	db:
   		host: localhost
   		pw: 123456
   ```

7. 在hmall-nginx目录下**cmd**运行`start nginx.exe`运行前端项目 访问 `localhost:18080`页面

# 微服务拆分

## 拆分原则

- 高内聚：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高
- 低耦合：每个微服务的功能要相对对立，尽量减少对其他微服务的依赖
- 纵向拆分：按照业务模块来拆分
- 横向拆分：抽取公共服务，提高复用性

## 拆分服务

工程结构

- 独立Project
- Maven聚合

> 需求：
>
> - 将hm-service中与商品管理相关功能拆分到一个微服务module中，命名为item-service
> - 将hm-service中与购物车有关的功能拆分到一个微服务module中，命名为cart-service

## 远程调用

注册 Bean ==RestTemplate== 

采用lombok注解==@RequiredArgsConstructor== （必备的构造函数）

```java
private final RestTemplate restTemplate; //final为必须，会自动构造函数注入

public void handlerCart(){
    ...
    ResponseEntity<List<ItemDTO>>response = restTemplate.exchange(
        "http://localhost:8081/items?ids={ids}",
        HttpMethod.GET,
        null,
        new ParameterizedTyprReference<List<ItemDTO>>(){
            Map.of("ids",CollUtil.join(itemIds,","))
        }
    )
        //获取响应体   
        List<ItemDTO> item = response.getBody();
    ...
}
```

# 服务治理

> - 由于远程调用时，请求端口等已经写死
> - 然后进行负载均衡后，一个服务可能有多个实例，有多个端口
> - 无法做到多实例服务自由访问，且某服务宕机后切换其他服务实例

## 注册中心原理

### 服务治理中的三个角色

- 服务提供者：暴露服务接口，供其他服务调用
- 服务消费者：调用其他服务提供的接口
- 注册中心：记录并监控微服务实例状态，推送服务变更信息

![image-20240607171147606](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406071711733.png)

### 消费者如何知道提供者地址

服务提供者会在启动时注册自己的信息到注册中心，消费者可以从注册中心订阅和拉取服务信息

### 消费者如何得知服务状态变更

服务提供者通过心跳机制向注册中心报告自己的健康状态，当心跳异常时注册中心会将异常服务提出，并通知订阅了该服务的消费者

### 消费者如何选择实例

通过负载均衡算法，从多个实例中采用一个

## Nacos注册中心

1. 下载nacos.sql文件，导入到Docker容器的MySql中（配置映射后，可直接在navicat中导入）https://pan.baidu.com/s/1i6sZbO57dS4IkV3HyXDe9A?pwd=6zbd

2. docker拉取镜像 `docker pull nacos/nacos-server`

3. 创建运行容器，并连接到与MySql==同一网桥==

   > 当连接到同一网桥时，MYSQL_SERVICE_HOST可以使用通过访问mysql容器名连接
   >
   > 其中 MYSQL_SERVICE_DB_NAME=nacos 指定其为mysql的nacos数据库

   ```shell
   docker run -d `
   --name nacos `
   -p 8848:8848 `
   -p 9848:9848 `
   -p 9849:9849 `
   --network hm-net `
   -e PREFER_HOST_MODE=hostname `
   -e MODE=standalone `
   -e SPRING_DATASOURCE_PLATFORM=mysql `
   -e MYSQL_SERVICE_HOST=mysql `
   -e MYSQL_SERVICE_PORT=3306 `
   -e MYSQL_SERVICE_USER=root `
   -e MYSQL_SERVICE_PASSWORD=123456 `
   -e MYSQL_SERVICE_DB_NAME=nacos `
   -e MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8"&"connectTimeout=1000"&"socketTimeout=3000"&"autoReconnect=true"&"useSSL=false"&"allowPublicKeyRetrieval=true"&"serverTimezone=Asia/Shanghai `
   nacos/nacos-server
   ```

   

## 服务注册

> ==注意：==
>
> 如果没有实现nacos注册，应关注springboot和spring-cloud-alibaba-dependencies版本问题
>
> - **2023.x 分支**: 支持 Spring Cloud(alibaba) 2023 & Spring Boot 3.2.x, JDK 17 or 更高版本.
> - **2022.x 分支**: 支持 Spring Cloud(alibaba) 2022 & Spring Boot 3.0.x, JDK 17 or 更高版本.
> - **2021.x 分支**: 支持 Spring Cloud(alibaba) 2021 & Spring Boot 2.6.x. JDK 1.8 or更高版本.

在item-service模块

1. **父工程**引入

   ```xml
   <!--采用springboot3.2.5版本-->
   <properties>
       <spring-cloud.version>2023.0.1</spring-cloud.version>
       <spring-cloud-alibaba.version>2023.0.1.0</spring-cloud-alibaba.version>
   </properties>
   <dependencyManagement>
       <dependencies>
           <!--spring-cloud-->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-dependencies</artifactId>
               <version>${spring-cloud.version}</version>
               <type>pom</type>
               <scope>import</scope>
           </dependency>
           <!--spring-cloud-alibaba-->
           <dependency>
               <groupId>com.alibaba.cloud</groupId>
               <artifactId>spring-cloud-alibaba-dependencies</artifactId>
               <version>${spring-cloud-alibaba.version}</version>
               <type>pom</type>
               <scope>import</scope>
           </dependency>
       </dependencies>
   </dependencyManagement>
   ```

   

2. **item-service**引入**服务发现**依赖：

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

3. **item-service**模块配置Nacos地址

   ```yml
   spring:
   	application:
   		name: item-service #服务名称
       cloud: 
       	nacos: 
       		server-addr: localhost:8848 #nacos地址
   ```

4. 在 http://localhost:8848/nacos 查看服务<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406072226569.png" alt="image-20240607222659422" style="zoom:67%;" />

## 服务发现

**消费者**需要连接nacos以拉取和订阅服务，因此服务发现的前两步与服务注册时一样，后面再加上**服务调用**即可：

1. 消费者也需要引入**服务发现**依赖

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

2. 配置nacos地址

   ```yml
   spring:
   	application:
   		name: item-service #服务名称
       cloud: 
       	nacos: 
       		server-addr: localhost:8848 #nacos地址
   ```

3. 服务发现

   > 负载均衡算法挑选一个服务实例（主机：端口），进行请求访问

   ```java
   //lombok注解 @RequiredArgsConstructor 构造注入
   private final DiscoveryClient discoveryClient;
   
   private void handleCartTiems(List<CartVO> vos){
       //1.根据服务名称，拉取服务的实例列表
       List<ServiceInstance> instances = discoveryClient.getInstances("item-service");
       //2.负载均衡，随机挑选一个实例
       ServiceInstance instance = instance.get(RandomUtil.randomInt(instance.size()));
       //3.利用RestTemplate发送http请求
       ResponseEntity<List<ItemDTO>> response = restTemplate.exchange(
       	instance.getUri()+"/item?ids={ids}", //请求路径
           HttpMethod.GET,
           null, //请求实体
           new ParameterizedTypeReference<List<ItemDTO>>(){},//返回值类型
           Map.of("ids",CollUtil.join(itemIds,",")) //请求参数
       );
   }
   ```
   

## OpenFeign

> OpenFeign是一个声明式的http客户端，是SpringCloud在Eureka公司开源的Feign基础上改造而来。作用是基于SpringMVC的常见注解，简化以RestTemplate的方式作为==Http请求发送==，且支持负载均衡

### 快速入门

通过使用OpenFeign简化上述handCartTiems方法中的获取实例并请求访问

1. 引入依赖，包括**OpenFeign**和负载均衡组件**SpringCloudLoadBalancer**

   ```xml
   <!--OpenFeign-->
       <dependency>
       	<groudId>org.springframework.cloud</groudId>
           <artifactId>spring-cloud-start-openfeign</artifactId>
       </dependency>
   <!--负载均衡-->
   	<dependency>
   		<groudId>org.springframework.cloud</groudId>
           <artifactId>spring-cloud-start-loadbalancer</artifactId>
   	</dependency>
   ```

2. 通过**启动类**添加 `@EnableFeignClients` 注解，启用 OpenFeign功能

3. **编写**FeignClient

   ```java
   @FeignClient(value="item-service") //要请求的服务名称
   public interface ItemClient{
       // 请求服务的路径以及携带参数，通过负载均衡算法挑选实例（主机：端口）访问
       @GetMapping("/items") 
       List<ItemDTO> queryItemByIds(@RequestParam("ids") Collection<Long> ids) ;
   }
   ```

4. **使用**FeignClient ，实现远程调用

   ```java
   // 推荐构造注入（final 结合@RequiredArgsConstructor） 或者 @Resource注入
   private ItemClient itemClient; 
   List<ItemDTO> items = itemClient.queryItemByIds(List.of(1,2,3));
   ```

5. 通过FeignClient的`fallback`属性，如果遇到网络问题、超时或远程服务不可用等情况，指定的类将被用来提供**回退**逻辑

   ```java
   //FeignClient 指定 回滚实现类
   @FeignClient(value="member-service",fallback=OrderMemberFeignSentinel.class)
   public interface OrderMemberFeign{
      @GetMapping("/p/address/getMemberAddrById")
      public Result<MemberAddr> getMemberAddrById(@RequestParam Long addrId);
   }
   
   // 回滚策略 实现 feignclient
   @Component
   @Slf4j
   public class OrderMemberFeignSentinel implements OrderMemberFeign{
      @Override
      public Result<MemberAddr> getMemberAddrById(@RequestParam Long addrId){
         log.error("远程调用接口失败");
         return null;
      }
   }
   ```

   



### 连接池

OpenFeign对Http请求做了优雅的伪装，不过其底层发起http请求，依赖于其他的框架。这些框架可以自己选择，来提高性能

- HttpURLConnection：默认实现，不支持连接池
- Apache HttpClient： 支持连接池
- OKHttp： 支持连接池

#### OpenFeign整合OKHttp

1. 引入依赖

   ```xml
   <!--ok-http-->
   <dependency>
   	<groupId>io.github.openfeign</groupId>
       <artifactId>feign-okhttp</artifactId>
   </dependency>
   ```

2. 开启连接池功能

   ```yml
   feign: 
   	okhttp:
   		enable: true #开启 OKHttp 连接池支持
   ```

   

### 最佳实践

> 为了降低重复，降低耦合性，避免每个服务都要重写其他服务的FeignClient来请求访问

#### 方案一：

**cart-service**和**order-service**都需要调用请求**item-service**，可以将公共的`itemClient`抽取出来，将item-service变为纯pom文件，客户端由item-service维护

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406081546825.png" alt="image-20240608154607627" style="zoom:67%;" />

#### 方案二：

将所有模块的FeignClient都抽取到一个api模块，统一管理

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406081548342.png" alt="image-20240608154858240" style="zoom: 80%;" />

#### 扫描包问题

==找不到FeignClient== 当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。

**hm-cart**模块引入**hm-api**模块，启动类不会扫描到hm-api模块com.hmall.api.clients包下的FeignClient

解决方案：cart模块启动类添加

##### 方式一：指定FeignClient所在包

```java
@EnableFeignClients(basePachages="com.hmall.api.clients")
```

##### 方式二：指定FeignClient字节码

```java
@EnableFeignClients(clients = {UserClient.class})
```

### 日志

> OpenFeign只会在FeignClient所在包的日志级别为**DEBUG**时，才会输出日志。而且其日志级别只有4级：
>
> - NONE：不记录日志信息（默认）
> - BASIC：仅记录请求的方法，URL以及响应状态码和执行时间
> - HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息
> - FULL：记录所有请求和响应的明细，包括头信息，请求体，元数据

```yml
#定义了 com.hmall包下所有类日志级别为debug
logging:
  level:
    com.hmall: debug
```

要自定义日志级别需要声明一个类型为Logger.Level的Bean，在其中定义日志级别：

```java
//不要添加@Configuration注解
public class DefaultFeignConfig{
    @Bean
    public Logger.Level feignLoggerLevel(){
        return Logger.Level.FULL;
    }
}
```

但此时这个Bean并未生效，要想**配置单个**FeignClient的日志，可以在@FeignClient注解中声明：

```java
@FeignClient(value="item-service",configuration=DefaultFeignConfig.class)
public interface ItemClient{
    @GetMapping("/items") 
    List<ItemDTO> queryItemByIds(@RequestParam("ids") Collection<Long> ids) ;
}
```

如果想要==全局配置==，让所有FeignClient都按照这个日志配置，则需要再@EnableFeignClient注解中声明

```java
//添加在启动类上
@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)
```

# 网关

> 服务拆分后
>
> - 服务地址过多，且可能变化，前端不知道该请求谁
> - 每个服务可能都需要登录用户信息,如果各自去做登录校验,麻烦且有秘钥泄露风险

**网关：**就是网络的关口，负责请求的路由、转发、身份校验。

- 对前端路由请求进行转发
- 对用户身份校验

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406081645915.png" alt="image-20240608164509800" style="zoom: 80%;" />

## 网关路由

### 快速入门

1. 创建新模块hm-gateway

2. 引入网关依赖

   ```xml
   <!--网关-->
   <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway</artifactId>
   </dependency>
   <!--服务发现-->
   <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   <!--负载均衡-->
   <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-loadbalancer</artifactId>
   </dependency>
   ```

   

3. 编写启动类 GateApplication

4. 配置==路由规则==

   ```yml
   # 前端请求8080到网关，由网关进行路由转发
   server:
   	port: 8080
   spring:
   	application:
   		name: gateway
   	cloud:
   		nacos:
   			server-addr: localhost:8848
   		gateway:
   			discovery:
   				 locator:
   					enable: true # 动态路由 (方便)
   		# 结合静态路由（指定规则）
   			routes:
   				- id: item-service 	#路由规则id，自定义,唯一
   				  uri: lb://item-service   #路由目标微服务，lb代表负载均衡
   				  predicates:   #路由断言，判断请求是否符合规则，进行路由跳转
   				  	- Path=/items/**,/xx/** #以请求路径做判断(Controller)
   				- id: xx
   				  uri: lb://xx-service
   				  predicates:
   				  	- Path=/xx/**
   	
   ```
   
   

### 路由属性

网关路由对应的Java类型是RouteDefinition.其中常见的属性有：

- id：路由唯一标识
- uri：路由目标地址
- predicates：路由断言
- filters：路由过滤器，对请求和响应体做处理

#### 路由断言

Spring提供了12种基本的**RoutePredicateFactory**实现

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406081708401.png" alt="image-20240608170816251" style="zoom:67%;" />

#### 路由过滤器

网关中提供33种路由过滤器<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406081709239.png" alt="image-20240608170919085" style="zoom:67%;" />

## 网关登录校验

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406081825588.png" alt="image-20240608182545438" style="zoom:80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406081823636.png" alt="image-20240608182352483" style="zoom:67%;" />

### 自定义过滤器

> ==注意：==需要在过滤器NettyRoutingFilter(order为最大值)转发之前(PRE)进行校验

- GatewayFilter：路由过滤器，作用于任意指定的路由；默认不生效，要配置到路由后生效
- GlobalFilter：全局过滤器，作用范围是所有路由；声明后自动生效

#### GoobalFilter

```java
@Component
public class MyGlobalFilter implements GlobalFilter,Ordered{
    /**
    * SserverWebExchange 包含整个过滤链内共享数据。例如 request,response等
    * GatewayFilterChain 当前过滤器链执行完后，调用下一个过滤器
    */
    @Override
    public Mono<Void> filter(ServerWebExchange exchange,GatewayFilterChain chain){
        // TODO 模拟登录校验逻辑
        ServerHttpRequest request = exchange.getRequest();
        HttpHeaders headers = request.getHeaders();
        // 放行
        return chain.filter(exchange);
    }
    
    // 设置过滤器优先级，值越小，优先级越高
    @Override
    public int getOrder(){
        return 0;
    }
}
```

### 实现登录校验

```yml
# 属性： jwt设置，password为秘钥文件设置的密码
hm:
  jwt:
    location: classpath:hmall.jks
    alias: hmall
    password: hmall123
    tokenTTL: 30m
  # 属性： 白名单路径
  auth:
    excludePaths:
      - /search/**
      - /users/login
      - /items/**
      - /hi
```

`AuthGlobalFilter.java`

```java
@Component
@RequiredArgsConstruct
public class AuthGlobalFilter implements GlobalFilter,Ordered{
    // 存放白名单的类
    private final AuthProperties authProperties;
    private final JwtTool jwtTool;
    // 用于判断 白名单中的 /search/** 这样的语法
    private final AntPathMatcher antPathMatcher = new AntPathMatcher();
    /*
    * 登录过滤器校验
    */
    @Override
    public Mono<Void> filter(ServerWebExchange exchange,GatewayFilterChain chain){
        //1.获取用户信息，request
        ServerHttpRequest request = exchange.getRequest();
        //2.判断是否需要校验
        if(isExclude(request.getPath().toString())){
            //放行
            return chain.filter(exchange);
        }
        //3.获取token,请求头是Map可以get
        String token = null;
        List<String> headers = request.getHeaders().get("authorization")
            if(headers!=null&&!headers.isEmpty()){
                token = headers.get(0);
            }
        //4.校验解析token
        Long userId = null;
        try{
            userId = jwtTool.parseToken(token);
        }catch(UnauthorizedException e){
            // 拦截，设置响应状态码为 401 未授权
            ServerHttpResponse response = exchange.getResponse();
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            // 终止，后续拦截器不再执行，请求不再转发
            return response.setComplete();
        }
        // TODO 5. 传递用户信息
        System.out.println("userId="+userId);
        // 6.放行
        return chain.filter(exchange);
    }

    /* 
    * 设置过滤器优先级，值越小，优先级越高 
    */
    @Override
    public int getOrder(){
        return 0;
    }

    /*
    * 判断路径是否存在白名单内
    */
    public boolean isExclude(String path){
        for(String pathPattern:authProperties.getExcludePaths()){
            if(authPathMatcher.match(pathPattern,path)){
                return true;
            }
        }
        return false;
    }
}
```

## 网关传递用户

> 网关过滤器将用户信息保存到指定请求头中
>
> 微服务使用拦截器，获取请求头信息并将用户信息保存到ThreadLocal，避免每个微服务请求都要重新去获取一次用户信息

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091614069.png" alt="image-20240609161414909" style="zoom:80%;" />

### 网关登录校验过滤器，将用户写入请求头

`AuthGlobalFilter.java`

> SserverWebExchange 包含整个过滤链内共享数据。例如 request,response等
>
> GatewayFilterChain 当前过滤器链执行完后，调用下一个过滤器

```java
@Component
@RequiredArgsConstruct
public class AuthGlobalFilter implements GlobalFilter,Ordered{
	...
    @Override
    public Mono<Void> filter(ServerWebExchange exchange,GatewayFilterChain chain){
       	...
        String userInfo = userId.toString();
        // 5. 传递用户信息,将其放入请求头
        ServerWebExchange swe = exchange.mutate()
            .request(builder->builder.header("user-info",userInfo))
            .build();
        // 6.放行
        return chain.filter(swe);
    }
	...
}
```

### hm-common编写拦截器

**需求**：由于每个微服务都可能获取登录用户的需求，因此直接在hm-common模块定义，这样微服务只需要**引入该模块依赖**即可生效，无需重复编写

`UserInfoInterceptor`

```java
public class UserInfoInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 获取登录用户信息(userId)
        String userInfo = request.getHeader("user-info");
        if(StrUtil.isNotBland(userInfo)){
            UserContext.setUser(Long.ValueOf(userInfo))
        }
        return true;
    }
    
   @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 清理用户 视图渲染前
        UserContext.removeUser();
    }
}
```

`MvcConfig`

> 由于网关Gateway依赖不需要,且不存在WebMvcConfigurer，所以当网关hm-gateway模块也引入了hm-common时，将会报错不存在WebMvcConfigurer,所以应该加上**条件**

```java
@Configuration
@ConditionalOnClass(DispatcherServlet.class)
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 默认拦截所有路径
        registry.addInterceptor(new UserInfoInterceptor());
    }
}
```

==自动装配==

> 由于其他微服务启动类扫描不到hm-common包下的MvcConfig等配置类,所以需要采用自动装配的方式
>
> 当其他微服务引入hm-common模块时，将自动装配该拦截器

在resoureces/META-INF/spring文件夹

`org.springframework.boot.autoconfigure.AutoConfiguration.imports` 文件

中写入配置类的`全类名`

```java
com.hmall.common.config.MvcConfig
```

## OpenFeign传递用户

> **微服务之间**的请求调用，并不是从网关发过来的，所以UserContext中不存在拦截器中的userInfo信息

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091647320.png" alt="image-20240609164730173" style="zoom:80%;" />

### OpenFeign拦截器

> OpenFeign提供了一个拦截器接口，所有由OpenFeign发起的请求都会先调用拦截器处理请求
>
> 由于其他微服务模块都会引入hm-api模块，且hm-api又引入了hm-common(UserContext)，所以在hm-api模块中引入该拦截器

由于该请求时trade-service模块发起，是经过了网关登录校验器的，所以该服务是有UserContext,由此发起的http请求，请求头信息中包含userInfo信息，所以openfeign调用时，可以获取到userInfo

```java
// 未添加 @Configuraton
public class DefaultFeignConfig{
    @Bean
    public RequestInterceptor userInfoRequestInterceptor(){
        return new RequestInterceptor(){
            @Override
            public void apply(RequestTemplate template){
                Long UserId = UserContext.getUser();
                if(UserId!=null){
                    template.header("user-info",UserId.toString());
                }
            }
        }
    }
}
```

在trade-service模块启动类添加，来开启该配置

```java
@Enable(basePackages = "com.hmall.api.cloents",defaultConfiguration	= DefaultFeignConfig.class)
```

## 总结

### 微服务登录解决方案

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091707974.png" alt="image-20240609170755772" style="zoom:80%;" />

# 配置管理

**问题**

- 微服务重复配置过多，维护成本高
- 业务配置经常变动，每次修改都要重启服务
- 网关路由配置写死，如果变更要重启网关

**解决方案**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091713502.png" alt="image-20240609171325339" style="zoom:80%;" />

### 配置共享

#### 添加配置都Nacos

添加一些共享配置到Nacos中，包括：jdbc、MybatisPlus、日志、Swagger、OpenFeign等配置

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091719169.png" alt="image-20240609171908034" style="zoom:67%;" />

![image-20240609172515904](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091725060.png)

> ==发布失败问题==
>
> **原因**：nacos容器中conf目录下的schema.sql文件下的config_info表没有encrypted_data_key字段
>
> **解决**：将mysql容器nacos数据库中的config_info 和 his_config_info 表中非空encrypted_data_key字段设置为可以为空，或者直接删除该字段

#### 拉取共享配置

基于NacosConfig拉取共享配置代替微服务的本地配置<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091736763.png" alt="image-20240609173626602" style="zoom:67%;" />

1. 引入依赖

   ```xml
   <!--nacos配置管理-->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   <!--读取bootstrap文件-->
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-bootstrap</artifactId>
   </dependency>
   ```

2. resource包新建`bootstrap.yaml`

   ```yaml
   spring:
   	applicatinon:
   		name: cart-service #服务名称
       profiles:
       	active: dev
      	cloud:	
      		nacos:
      			server-addr: localhost:8848 # nacos地址
      			config:
      				file-extension: yaml # 文件后缀名
      				shared-configs:  # 共享配置
      					- dataId: shared-jdbc.yaml
      					- dataId: share-log.yaml
      					- dataId: xxx
   ```

   

### 配置热更新

**配置热更新**：当修改配置文件中的配置时，微服务**无需重启**即可使配置生效

**前提条件**：

1. nacos中要有一个与微服务名有关的配置文件

   ```java
   // 微服务名称             项目profile(可选)		文件名后缀
   [spring.application.name]-[spring.active].[profile.file-extension]
   ```

   <img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091753504.png" alt="image-20240609175331348" style="zoom:67%;" />

2. 微服务要以特定方式读取需要热更新的配置属性

   ```java
   // 动态设置(无需重启) 购物车商品 最大添加值
   @Data
   @Component
   @ConfigurationProperties(prefix = "hm.cart")
   public class CartProperties{
       private Integer maxItems;
   }
   ```

   

### 动态路由

要实现**动态路由**首先要将路由配置保存到Nacos，当Nacos中的路由配置变更时，推送最新配置到网关，实时更新网关中的路由信息

- 监听Nacos配置变更的信息
- 当配置变更时，将最新的路由信息更新到网关路由表

1. hm-gateway模块引入nacos配置管理，bootstrap读取依赖

   ```xml
   <!--nacos配置管理-->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   <!--读取bootstrap文件-->
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-bootstrap</artifactId>
   </dependency>
   ```

2. 编写bootstrap.yaml文件

   ```yaml
   spring:
   	applicatinon:
   		name: gateway #服务名称
       profiles:
       	active: dev
      	cloud:	
      		nacos:
      			server-addr: localhost:8848 # nacos地址
      			config:
      				file-extension: yaml # 文件后缀名
      				shared-configs:  # 共享配置
      					- dataId: share-log.yaml
   ```

3. 编写监听器 `DynamicRouteLoader`

   ```java
   @Slf4j
   @component
   @RequiredArgsConstructor
   public class DynamicRouteLoader{
       private final NacosConfigManagement nacosConfigManagement;
       // 用于编写 路由表
       private final RouteDefinitionWriter writer;
   
       private final String dataId = "gateway-routes.json";
       private final String group = "DEFAULT_GROUP";
   
       private final Set<String> routeIds = new HashSet<>();
   
       @PostConstruct // bean初始化后就执行的函数
       public void initRouteConfigListener(){
           // 项目启动，先拉取一次配置，并且添加配置监听器
           String configInfo = nacosConfigManagement.getConfigService()
               .getConfigAndSignListener(dataId,5000,new Listener(){
                   @Overrrid
                   public Executor getExecutor(){
                       return null;
                   }
                   @Overrride
                   public void receiveConfigInfo(String configInfo){
                       // 监听到配置变更，需要去更新路由表
                       updateConfigInfo(configInfo);
                   }
               });
   
           // 首次启动时，读取配置，也需要更新路由表
           updateConfigInfo(configInfo);
       }
   
       public void updateConfigInfo(String configInfo){
           // 解析配置文件，转为 RouteDefinition
           List<RouteDefinition> routeDefinitions = JSONUtil.toList(configInfo,RouteDefinition.class);
           // 删除旧路由表
           for(String routeId : routeIds){
               writer.delete(Mono.just(routeId)).subscribe();
           }
           routeIds.clear();
           // 更新路由表
           for(RouteDefinition routeDefinition : routeDefinitions){
               // Mono包装, 更新
               writer.save(Mono.just(routeDefinition)).subscribe();
               // 记录 路由id 便于下一次更新时删除
               routeIds.add(routeDefinition.getId());
           }
       }
   }
   ```

4. Nacos 添加配置文件,使用JSON格式编写路由信息，便于处理，格式转化RouteDefinition<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406091831546.png" alt="image-20240609183127366" style="zoom:67%;" />



# 微服务保护和分布式事务

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406092032570.png" alt="image-20240609203257374" style="zoom:80%;" />

## 雪崩问题

> 微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。
>
> 反复请求已经故障的微服务，阻塞，导致tomcat资源不足，正常的微服务请求也无法响应

### 原因分析：

雪崩问题产生的原因是什么？

- 微服务相互调用，服务提供者出现故障或阻塞
- 服务调用者没有做好异常处理，导致自身故障
- 调用链中所有服务级联失败，导致整个集群故障

解决问题的思路有哪些？

- 尽量避免出现故障或阻塞
  - 保证带阿米健壮性
  - 保证网络畅通
  - 能应对较高的并发请求
- 服务调用者做好远程调用异常的后备方案，避免故障扩散 

### 解决方案

#### 服务保护方案

- 请求限流：限制访问微服务的请求的并发量，避免服务因流量激增出现故障

- 线程隔离：也叫舱壁模式，模拟船舱隔板的防水原理。通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散

- 服务熔断：由**断路器**统计请求的异常比例或慢调用比例，如果超出阈值则会**熔断**该业务，拦截该接口的请求
- 失败处理：熔断期间，所有请求快速失败，全都走fallback逻辑

#### 服务保护技术

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406092053085.png" alt="image-20240609205306896" style="zoom:67%;" />

## Sentinel控制台

> Sentinel是阿里巴巴开源的一块微服务流量控制组件。

### 快速入门

#### 安装Sentinel控制台

```shell
# docker 拉取 Sentinel 镜像
docker pull docker.io/bladex/sentinel-dashboard
#创建并运行该容器
docker run -d --name sentinel -p 8858:8858 bladex/sentinel-dashboard
```

访问 http://localhost:8858/ 默认用户名密码： sentinel

#### 微服务整合

在 `cart-service`模块中整合sentinel，连接 `sentinel-dashboard`控制台

1. 引入依赖

   ```xml
   <!--Sentinel-->
   <dependency>
   	<groupId>com.alibaba.cloud</groupId>
       <artifaceId>spring-cloud-starter-alibaba-sentinel</artifaceId>
   </dependency>
   ```

2. 配置控制台

   ```yml
   spring:	
   	cloud:
   		sentinel:
   			transport:
   				dashboard: localhost:8858 #sentinel控制台地址
   ```

3. 访问 `cart-service`请求后，`sentinel-dashboard`可查看流量

#### 簇点链路

**簇点链路**，就是单机调用链路。是一次请求进入服务后经过的每一个被Sentinel监控的资源链。默认Sentinel会监控SpringMVC的每一个Endpoint（http接口）。限流、熔断等都是针对簇点链路中的**资源**设置的。而资源默认就是接口的请求路径

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406092114704.png" alt="image-20240609211413537" style="zoom:80%;" />

Restful风格的API请求路径一般都相同，这会导致簇点资源名称重复。因此我们要修改配置，把**请求方式+请求接口**作为簇点资源名称：

```yml
spring:
	cloud:
		sentinel:
			transport:
				dashboard: localhost:8858 #sentinel控制台地址
			http-method-specify: true # 是否设置请求方式作为资源名称
```

### 请求限流

在簇点链路后面点击流控按钮，即可对其做限流配置：

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406092119472.png" alt="image-20240609211936321" style="zoom: 67%;" />

**QPS**：每秒钟的请求数量(并发数量)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406092120717.png" alt="image-20240609212035584" style="zoom:67%;" />

### 线程隔离

当商品服务出现阻塞或故障时，调用商品服务的购物车服务（历史价格比对）可能因此而被拖慢，甚至资源好景。所以必须显示购物车服务中查询商品这个服务的可用线程数，实现线程隔离。

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406092127352.png" alt="image-20240609212712219" style="zoom:67%;" />

对查询商品服务做**并发线程数**限制

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406092130280.png" alt="image-20240609213011129" style="zoom:67%;" />

### Fallback

1. 将FeignClient作为Sentinel的簇点资源：

   ```yml
   feign:
   	sentinel:
   		enabled: true
   ```

2. FeignClient的Fallback有两种配置方式：

   - 方式一：FallbackClass，无法对远程调用的异常做处理
   - 方式二：FallbackFactory，可以对远程调用的异常做处理（一般考虑这种）

#### 步骤一

自定义类，实现FallbackFactory，编写对某个FeignClient的fallback逻辑：

```java
@Slf4j
public class UserClientFallbackFactory implements FallbackFactory<UserClient>{
   @Override
   public UserClient create(Throwable throwable){
      //创建UserClient接口实现类，实现其中方法，编写失败降级处理逻辑
      @Override
      public User findById(Long id){
         //记录异常信息，可以返回空
         log.error("查询用户失败",throwable);
         return null;
      }
   }
}
```

#### 步骤二

将定义的UserClientFallbackFactory注册为一个Bean

```java
@Bean
public UserClientFallbackFactory userClientFallback(){
   return new UserClientFallbackFactory();
}
```

#### 步骤三

在UserClient接口中使用UserClientFallback

```java
@FeignClient(value="user-service",fallbackFactory=UserClientFallbackFactory.class)
public interface UserClient{
   @GetMapping("/user/{id}")
   User findById(@PathVariable("id") id);
}
```

### 服务熔断

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161532183.png" alt="image-20240616153230007" style="zoom:67%;" />

**Sentinel控制台添加熔断**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161534526.png" alt="image-20240616153457349" style="zoom:67%;" />

## 分布式事务

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161541113.png" alt="image-20240616154121901" style="zoom:67%;" />

### 初始Seata

![image-20240616154658295](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161546519.png)

### 部署TC服务

下载配置文件https://pan.baidu.com/s/1FPOtQ_Wp5-nguHrrVLU5nQ?pwd=1234 

#### 准备数据库表

- 创建`seata`数据库

- 运行`seata-tc.sql`创建表(如不存在数据库则创建数据库)

#### 准备配置文件

将资源中的**seata文件夹**拷贝到本地目录作为数据卷,注意修改其中的`application.yml` ==mysql 密码==等配置

#### Docker部署

将seata-tc服务注册到nacos中 

```shell
# 拉取镜像
docker pull seataio/server

# 部署容器 （mysql、nacos 同一网络段）
docker run -d `
--name seata `
-p 8099:8099 `
-p 7099:7099 `
-e SEATA_IP=localhost `
-v /f/Docker/volumes/seata:/seata-server/resources `
--privileged=true `
--network hm-net `
seataio/seata-server
```

http://localhost:8848/nacos (nacos nacos)

http://localhost:7099 (admin admin)

### 微服务集成Seata

1. 引入依赖

   ```xml
   <dependency>
   	<groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
   </dependency>
   ```

2. 在`nacos`中注册 **配置管理 TC服务** ，以便配置共享

   <img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161731663.png" alt="image-20240616173149464" style="zoom:67%;" />

   ```yml
   seata:
     registry: #注册中心配置
       type: nacos # 注册中心类型
       nacos:
         server-addr: localhost:8848 # nacos地址
         namespace: ""
         group: DEFAULT_GROUP
         application: seata-server # seata 服务名称
         username: nacos
         password: nacos
     tx-service-group: hm-trade-tx-group
     service:
       vgroup-mapping:
         hmall: "default"
   ```

3. 在 `trade-service`模块引入seata、nacos等依赖

   ```xml
   <!--nacos配置管理-->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   <!--读取bootstrap文件-->
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-bootstrap</artifactId>
   </dependency>
   <!--seata-->
   <dependency>
   	<groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
   </dependency>
   
   ```
   
4. 配置`bootstrap.yaml`文件

### XA模式

![image-20240616174812121](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161748356.png)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161749301.png" alt="image-20240616174940101" style="zoom:67%;" />

#### 实现XA模式

Seata的starter已经完成了XA模式的自动装配，实现非常简单

1. 修改application.yml文件（nacos中的seata配置），开启XA模式（每个参与事务的微服务）

   ```yml
   seata:
   	data-source-proxy-mode: XA
   ```

2. 给发起全局事务的入口方法添加@GlobalTransactional注解，本例中是OrderServiceImpl中的create方法

   ```java
   @Overrride
   @GlobalTransactional
   public Long createOrder(OrderFormDTO order){
      //创建订单...
      //清理购物车...
      //扣减库存...
      return order.getId();
   }
   ```

3. 重启服务并测试

### AT模式

![image-20240616180430829](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161804072.png)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406161807329.png" alt="image-20240616180735113" style="zoom: 50%;" />

#### 实现AT模式

1. 将资源https://pan.baidu.com/s/1FPOtQ_Wp5-nguHrrVLU5nQ?pwd=1234 中的`seata-at.sql`表导入**每一个要使用事务的数据库**（trade-service、item-service）

2. 修改 application.yml文件(nacos的seata配置)，将事务模式修改为AT模式（默认）

   ```yml
   seata:
   	data-source-proxy-mode: AT
   ```

    

# RabbitMQ

[**详见 消息队列-RabbitMQ 篇**](F:/Typora文件/消息队列/RabbitMQ)





# Elasticsearch

## 初识elasticsearch

Elasticsearch高性能分布式搜索引擎,结合kibana、Logstash、Beats，是一整套技术栈，被叫做ELK。被广泛应用在日志数据分析，实时监控等领域

- 支持分布式，可水平扩展
- 支持Restful接口，可被任何语言调用

### 安装elasticsearch

```shell
# 获取镜像 elasticseach （6/7版本较广且其他版本可能无法安装）
docker pull elasticsearch:7.12.1
# 创建本地目录并映射
docker run -d `
--name es `
-e "ES_JAVA_OPTS=-Xms512m -Xmx1024m" `
-e "discovery.type=single-node" `
-v /f/Docker/volumes/es/data:/usr/share/elasticsearch/data `
-v /f/Docker/volumes/es/plugins:/usr/share/elasticsearch/plugins `
--privileged `
--network hm-net `
-p 9200:9200 `
-p 9300:9300 `
elasticsearch:7.12.1
```

http://localhost:9200 访问 

### 安装kibana（可视化）

```shell
# 获取镜像 可视化kibana
docker pull kibana:7.12.1

# 通过容器名+端口访问elasticsearch 若5601端口不可用，请尝试重启winnat或更换
docker run -d `
--name kibana `
-e ELASTICSEARCH_HOSTS=http://es:9200 `
--network hm-net `
-p 5601:5601 `
kibana:7.12.1
```

http://localhost:5601访问

### 倒排索引

**传统数据库**（如MySql）采用正向索引，例如给表tb_phone中的id创建索引

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406172048871.png" alt="image-20240617204855677" style="zoom:67%;" />

**elasticsearch**采用倒排索引：

- 文档（document）：每条数据就是一个文档
- 词条（term）：文档按照语义分成的词语![image-20240617205730293](C:/Users/35747/AppData/Roaming/Typora/typora-user-images/image-20240617205730293.png)<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406172057902.png" alt="image-20240617205749727" style="zoom:67%;" />

倒排索引，第一次检索词条，第二次检索id，两次都有索引，搜索较快

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406172059932.png" alt="image-20240617205923760" style="zoom:67%;" />

### IK分词器

中文分词往往是根据语义分析，比较复杂，这就需要用到中文分词器，例如IK分词器。IK分词器是采用正向迭代最细粒度切分算法一直沿用至今

1. 下载与elasticsearch、kibana相同对应版本（7.12.1）的ik分词器 https://github.com/infinilabs/analysis-ik/releases

2. 解压缩至 elasticsearch映射至本地的 es/plugins 文件夹 ,并重启elasticsearch `docker restart es`

在Kibana控制台的DevTools中可以使用下面的语法来测试IK分词器：

> POST：请求方式
>
> /_analyze：请求路径，这里省略了 http://localhost:9200,有kibana帮我们补充
>
> "analyzer"：分词器（standard、ik_smart、ik_max_word......）

```json
POST /_analyze
{
   "analyzer":"standard",
   "text":"学java，狠狠赚他一笔"
}
```

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406172302372.png" alt="image-20240617230200200" style="zoom:67%;" />

扩展词典：在es/plugins/config/IKAnalyzer.xml 文件中添加扩展词典、停止词典等 (由于词典在2012年就停止维护)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
	<comment>IK Analyzer 扩展配置</comment>
	<!--用户可以在这里配置自己的扩展字典 -->
	<entry key="ext_dict">ext.dic</entry>
	 <!--用户可以在这里配置自己的扩展停止词字典-->
	<entry key="ext_stopwords">stopword.dic</entry>
	<!--用户可以在这里配置远程扩展字典 -->
	<!-- <entry key="remote_ext_dict">words_location</entry> -->
	<!--用户可以在这里配置远程扩展停止词字典-->
	<!-- <entry key="remote_ext_stopwords">words_location</entry> -->
</properties>

```

### 基础概念

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406212207275.png" alt="image-20240621220719059" style="zoom: 80%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406212209946.png" alt="image-20240621220913743" style="zoom: 80%;" />

### 索引库操作

#### Mapping映射属性

![image-20240621222450225](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406212224406.png)

#### 索引库的CRUD

Elasticsearch提供的所有API都是Restful的接口，遵循Restful的基本规范：

运行elasticsearch和kibana（可视化、会补全）---DevTools

**新增索引库**

```python
#创建索引库并设置mapping映射
PUT /heima
{
  "mappings": {
    "properties": {
      "info":{
        "type": "text",
        "analyzer": "ik_smart"
      },
      "age":{
        "type": "byte"
      },
      "email":{
        "type": "keyword",
        "index": false
      },
      "name":{
        "type": "object",
        "properties": {
          "firstName":{
            "type":"keyword"
          },
          "lastName":{
            "type":"keyword"
          }
        }
      }
    }
  }
}
```

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406212236339.png" alt="image-20240621223641151" style="zoom:67%;" />

**查询索引库**

`GET /heima`

**删除索引库**

`DELETE /heima`

> 索引库和mapping一旦创建==无法修改==，但是可以添加新的字段

```python
PUT /索引库名/_mapping
{
	"properties":{
		"新字段名":{
			"type":"integer"
		}
	}
}
```

### 文档的操作

#### 文档的CRUD

##### 新增文档

```python
POST /索引库名/_doc/文档id
{
   "字段1":"值1",
   "字段2":"值2",
   "字段3":{
      "子属性1":"值3",
      "子属性2":"值4"
   },
}
```

##### 查询文档

`GET /heima/_doc/1`

##### 删除文档

`DELETE /heima/_doc/1`

##### 全量修改

> 会删除旧文档，添加新文档

```python
PUT /heima/_doc/1
{
   "info":"lksjfkls",
   "email":"jslkdfjlk.itcast.cn"
}
```

##### 增量修改

> 修改指定字段值

```python
POST /索引库名/_update/文档id
{
   "doc":{
      "email":"jsdlkfj@itcast.cn"
   }
}
```

#### 批量处理

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221731353.png" alt="image-20240622173147979" style="zoom:67%;" />

```python
POST /_bulk
{"index":{"_index":"heima","_id":3}}
{"info":"黑马jsdlkf","email":"sjdlkfjkl@itcast.cn","name":{"fistName":"五","lastName":"王"}}
```

## JavaRestClient

### 客户端初始化

1. 引入es的RestHighLevelClient依赖

   ```xml
   <dependency>
   	<groupId>org.elasticsearch.client</groupId>
      <artifactId>elasticsearch-rest-high-level-client</artifactId>
   </dependency>
   ```

2. 因为Springboot默认的ES版本是7.17.0，所以我们需要覆盖默认的ES版本：

   ```xml
   <properties>
   	<elasticsearch.version>7.12.1</elasticsearch.version>
   </properties>
   ```

3. 初始化RestHighLevelClient：

   ```java
   RestHighLevelClient client = new RestHighLevelClient(
      RestClient.builder(
   		HttpHost.create("http://localhost:9200")
   ))
   ```

   

### 商品Mapping映射

分析

![image-20240622180251591](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221802980.png)

### 索引库操作

#### 创建索引库的JavaApi和Restful接口API对比：

![image-20240622181033491](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221810886.png)

#### 删除索引库

![image-20240622181103562](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221811890.png)

#### 查询索引库![image-20240622181116236](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221811557.png)

### 文档操作

#### 新增文档的JavaAPI

![image-20240622181618017](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221816415.png)

1. 准备ItemDoc为需要记录es的Item类型
2. 数据库查询Hutool工具拷贝类型
3. 准备文档操作Request
4. 将数据转化为JSON作为请求参数

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221823175.png" alt="image-20240622182341809" style="zoom:67%;" />

#### 查询文档

包含查询和解析响应结果两部分

![image-20240622182828079](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221828453.png)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221832708.png" alt="image-20240622183243276" style="zoom:67%;" />

#### 删除文档

![image-20240622183307091](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221833460.png)

#### 文档修改

- 方式一：全量更新。再次写入id一样的文档，就会删除旧文档，添加新文档

- 方式二：局部更新。只更新指定部分字段

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221839640.png" alt="image-20240622183908511" style="zoom:67%;" />

### 批处理

![image-20240622184219325](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221842472.png)

![image-20240622184756025](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406221847214.png)

## DSL查询

### 快速入门

基于DSL的查询语法

```python
GET /indexName/_search
{
   "query":{
      "查询类型":{
         "查询条件":"条件值"
      }
   }
}
# 查询所有
GET /items/_search
{
   "query":{
      "match_all":{}
   }
}
```

### 叶子查询

![image-20240622211828097](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406222118311.png)

**match**查询：全文检索查询的一种，会对用户输入内容分词，然后去倒排索引库检索：

```python
GET /indexName/_search
{
   "query":{
      "match":{
         "FILED":"TEXT"
      }
   }
}
```

**muti_match**：与match查询类似，只不过允许同时查询多个字段：

```java
GET /indexName/_search
{
   "query":{
      "multi_match":{
         "query":"TEXT",
         "fileds";["FIELD1","FIELD2",...]
      }
   }
}
```

**精确查询**

![image-20240622213635651](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406222136840.png)

### 复合查询

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406222138116.png" alt="image-20240622213844886" style="zoom:67%;" />

#### 布尔查询

![image-20240622214133655](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406222141875.png)

> 需求：我们需要搜索“智能手机”，但品牌必须是华为，价格必须是900~1599

```python
GET /items/_search
{
   "query":{
      "bool":{
         "must":[
            {
               "match":{
                  "name":"智能手机"
               }
            }
         ],
         "filter":[
            {
               "term":{
                  "brand":"华为"
               }
            },
            {
               "range":{
                  "price":{
                     "gte":90000,
                     "lte":159900
                  }
               }
            }
         ]
      }
   }
}
```

### 排序和分页

es支持对搜索结果排序，默认根据相关度算分（_score）来排序，也可指定字段排序

> 需求：搜索商品，按照销量排序,销量一样，价格升序

```python
GET /items/_search
{
   "query":{
      "match_all":{}
   },
   "sort"[
      {
         "sold":"desc"
      },
      {
         "price":"asc"
      }
   ]
}
```

es默认情况下只返回top10的数据，而如果需要查询更多数据就需要修改分页参数

- from：从第几个文档开始
- size：总共查询几个文档

```python
GET /items/_search
{
   "query":{
      "match_all":{}
   },
   "from":0, # 分页开始位置，默认为0
   "size":10, # 期望获取的文档总数
   "sort":[
      {
         "price":"asc"
      }
   ]
}
```

### 深度分页问题

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231502870.png" alt="image-20240623150219627" style="zoom:67%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231502395.png" alt="image-20240623150233190" style="zoom:67%;" />

### 高亮显示

 ![image-20240623150745183](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231507434.png)

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231508805.png" alt="image-20240623150829590" style="zoom:67%;" />

## JavaRestClient查询

### 快速入门

- 构建并发起请求
- 解析查询结果

```java
@Test
public void testMatchAll() throws IOException{
   //1.创建request对象
   SearchRequest request = new SearchRequest("items");
   //2.配置request 参数
   request.source()
      .query(QueryBuilders.matchAllQuery());
   //3.发送请求
   SearchResponse response = client.search(request,RequestOptions.DEFAULT);
   //4.解析结果
   SearchHits searchHits = response.getHits();
   //4.1总条数
   long total = searchHits.getTotalHits().value;
   //4.2命中的数据
   SearchHit[] hits = searchHits.getHits();
   for(SearchHit hit: hits){
      //4.2.1获取source结果
      String json = hit.getSourceAsString();
      //4.2.2转为ItemDoc
      ItemDoc doc = JSONUtil.toBean(json,ItemDoc.class);
      System.out.println("doc ="+doc);
   }
}
```

### 构建条件查询

在JavaRestAPI中，所有类型的query查询条件都是由QueryBuilders来构建的

**全文检索**的查询条件构造API如下：

![image-20240623152853612](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231528840.png)

**精确查询**的查询条件构造API如下：

![image-20240623152925252](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231529490.png)

**布尔查询**的查询条件构造API如下：

![image-20240623153016482](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231530711.png)

#### 构造复杂查询条件的搜索

> 需求：利用JavaRestClient实现搜索功能，条件如下：
>
> - 搜索关键字为“脱脂牛奶”
> - 品牌必须为“德亚”
> - 价格必须低于 300

```java
@Test
public void testSearch()throws IOException{
    //1.创建request对象
   SearchRequest request = new SearchRequest("items");
   //2.配置request 参数
   request.source()
      .query(QueryBuilders.boolQuery()
            .must(QueryBuilders.matchQuery("name","脱脂牛奶"))
            .filter(QueryBuilders.termQuery("brand","德亚"))
            .filter(QueryBuilders.rangeQuery("price").lt(30000))
            );
   //3.发送请求
   SearchResponse response = client.search(request,RequestOptions.DEFAULT);
   //4.解析结果
   ...
}
```

### 排序和分页

```java
@Test
public void testSortAndPage()throws IOException{
   //0.模拟前端传递的分页参数
   int pageNo = 1,pageSize = 5;
   //1.创建request对象
   SearchRequest request = new SearchRequest("items");
   //2.1配置request 参数
   request.source().query(QueryBuilders.matchAllQuery());
   request.source().from((pageNo-1)*pageSize).size(pageSize);
   //2.2排序
   request.source()
      .sort("sold",SortOrder.DESC)
      .sort("price",SortOrder.ASC);
   //3.发送请求
   SearchResponse response = client.search(request,RequestOptions.DEFAULT);
   //4.解析结果
   ...
}
```

### 高亮显示

```java
@Test
void testHighLight()throws IOException{
   //1.创建request对象
   SearchRequest request = new SearchRequest("items");
   //2.组织DSL参数
   request.source().query(QueryBuilders.matchQuery("name","脱脂牛奶"));
   request.source().highlighter(SearchSourceBuilder.highlight().field("name"));
   //3.发送请求
   SearchResponse response = client.search(request,RequestOptions.DEFAULT);
   //4.解析结果
   parseResponseResult(response);
}

private static void parseResponseResult(SearchResponse response){
   SearchHits searchHits = response.getHits();
   //4.1总条数
   long total = searchHits.getTotal.value;
   //4.2命中的数据
   SearchHits[] hits = searchHits.getHits();
   for(searchHit hit: hits){
      //4.2.1获取source结果
      String json = hit.getSourceAsString();
      //4.2.2转化为ItemDoc
      ItemDoc doc = JSONUtil.toBean(json,ItemDoc.class);
      //4.3处理高亮结果
      Map<String,HighlightField> hfs = hit.getHightlightFields();
      if(hfs!=null&&!hfs.isEmpty()){
         //4.3.1根据高亮字段名获取高亮结果
         HightlightField hf = hfs.get("name");
         //4.3.2获取高亮结构，覆盖非高亮结果
         String hfName = hf.getFragments()[0].string();
         doc.setName(ifName);
      }
      System.out.println("doc ="+doc);
   }
}

```

### 数据聚合

![image-20240623160310232](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231603611.png)

#### DSL聚合

> 我们要统计所有商品中共有哪些商品分类，其实就是以分类（category）字段对数据分组。category值一样的放在同义组，属于Bucket聚合中的Term聚合

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231606355.png" alt="image-20240623160601998" style="zoom:67%;" />

**带条件的聚合**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231608489.png" alt="image-20240623160816166" style="zoom:67%;" />

**嵌套的聚合**

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231609677.png" alt="image-20240623160944318" style="zoom:67%;" />

#### RestClient聚合

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406231614610.png" alt="image-20240623161429244" />
