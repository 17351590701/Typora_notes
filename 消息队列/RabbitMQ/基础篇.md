> **publishe**r发送消息**Message**
>
> 消息到达**exchange**交换机（路由转发消息到队列，不存储）
>
> 发送到**queue**队列（**queue在==内存==中，如果queue和Message未进行durable持久化时，当RabbitMQ重启，Message将丢失**）
>
> 由consumer消费者监听



<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737151.png" alt="image-20240601144531958" style="zoom:67%;" />

## 一、快速入门

需求：在RabbitMQ的控制台完成下列操作

- 新建队列hello.queue1和hello.queue2
- 向默认的amp.fanout交换机发送一条消息
- 查看消息是否到达hello.queue1和hello.queue2
- 总结规律

### 新建两个队列

> hello.queue1
>
> hello.queue2

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737152.png" alt="image-20240601144902983" style="zoom:67%;" />

### 绑定交换机和队列

> amp.fanou和queue1，queue2
>

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737153.png" alt="image-20240601145641749" style="zoom:67%;" />

### 交换机发送消息

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737154.png" alt="image-20240601145912384" style="zoom: 67%;" />

### 查看消息是否到达队列

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737155.png" alt="image-20240601150405494" style="zoom:67%;" />

## 二、数据隔离

需求：在RabbitMQ的控制台完成下列操作：

- 新建一个用户hmall
- 为hmall用户创建一个virtual host
- 测试不同virtual host 之间的数据隔离现象

### 新建用户

> 用户名 hmall 密码 123 标签 Admin
>
> 退出用户 guest 登录hmall

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737156.png" alt="image-20240601151307151" style="zoom:67%;" />

### 创建虚拟主机

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737157.png" alt="image-20240601151813480" style="zoom:67%;" />

## 三、Java客户端

### 快速入门

#### 1.父工程配置

引入AMQP依赖

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

在<project>中配置打包方式是 pom 而非 jar

`<packaging>pom</packaging>`

#### 2.新建两个模块

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737158.png" alt="image-20240601154952639" style="zoom:67%;" />

在<project>引入父工程的坐标

```java
    <parent>
        <groupId>org.example</groupId>
        <artifactId>mq-demo</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
```

#### 3.AMQP配置

在两个子模块application.yml中配置

> 子模块并不会读取继承父模块的application.yml，如果没有配置，会采用springboot默认配置

```yml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    virtual-host: /hmall #hmall用户创建的virtual host
    username: hmall
    password: 123
```

#### 4.发送消息

引入`RabbitTemplate`

向 hmall 用户的队列 simple.queue 发送消息

```java
@Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    void contextLoads() {
        String queueName = "simple.queue";
        String msg = "hello world";
        rabbitTemplate.convertAndSend(queueName,msg);
    }
```

#### 5.接受消息

配置要监听的queue队列，并打印消息

```java
@Slf4j
@Component
public class MqListener {
    @RabbitListener(queues = "simple.queue")
    public void listenSimpleQueueMessage(String msg) {
        log.info("消费者接收到消息:{}", msg);
    }
}
```



## Work Queue

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737159.png" alt="image-20240601165431516" style="zoom:67%;" />



实现一个队列绑定多个消费者

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737160.png" alt="image-20240601165557798" style="zoom:67%;" />

### 发送消息

```java
    @Test
    void testWork() throws InterruptedException {
        String queueName = "work.queue";
        for (int i = 1; i <= 50; i++) {
            String msg = "helloWork,message_"+i;
            rabbitTemplate.convertAndSend(queueName, msg);
        }
    }
```

### 接收消息

```java
    @RabbitListener(queues = "work.queue")
    public void listenWorkQueue1(String msg) {
        System.out.println("消费者1接收到消息:"+msg);
        Thread.sleepL(20);
    }
    @RabbitListener(queues = "work.queue")
    public void listenWorkQueue2(String msg) {
        System.err.println("消费者2接收到消息:"+msg);
        Thread.sleepL(200);
    }
```

### 现象弊端

消息被依次平均的分配给每一个消费者

即使消费者1接受处理消息速度远超消费者2，消费者1也只会接受处理其中25条，之后便不再处理

### 消费者消息推送机制

> ==默认==情况下，RabbitMQ会将消息依次==轮询==投递给绑定在队列上的每一个消费者。但这并没有考虑消费者是否已经处理完消息，可能出现消息堆积

修改 consumer模块application.yml 配置 preFetch 值为 1 ，确保同一时刻最多投递给消费者1条消息：

```yml
spring:
  rabbitmq:
    listener:
      simple:
        prefetch: 1 #每次只能获取一条消息，处理完才能接着获取
```

现象：==能者多劳== 消费者1处理了更多的消息

## Exchanges交换机

> 真正的生产环境会经过exchange来发送消息，而不是直接发送到队列，交换机有以下三种类型
>
> - **Fanout**：广播
> - **Direct**：定向
> - **Topic**：话题

### AMQP演示Fanout

**Fanout Exchange 会将接收到的消息广播到每一个跟其绑定的queue，所以也叫广播模式**

*模拟演示*：

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737161.png" alt="image-20240601201200063" style="zoom:67%;" />

#### 新建两个queue

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737162.png" alt="image-20240601201218078" style="zoom:67%;" />

#### 新建fanout类型exchange

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737163.png" alt="image-20240601201313173" style="zoom:67%;" />

#### 绑定交换机与队列

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737164.png" alt="image-20240601201434009" style="zoom:67%;" />

#### 创建消费者监听

创建两个消费者分别监听queue1，queue2

```java
    @RabbitListener(queues = "fanout.queue1")
    public void listenFanoutQueue1(String msg) throws InterruptedException {
        System.out.println("消费者1监听fanout.queue1接收到消息:"+msg);
    }
    @RabbitListener(queues = "fanout.queue2")
    public void listenFanoutQueue2(String msg) throws InterruptedException {
        System.err.println("消费者2监听fanout.queue2接收到消息:"+msg);
    }
```

#### 发送消息

```java
    @Test
    void testSendFanout(){
        String exchangeName = "hmall.fanout";
        String msg ="hello.everyone";
        //第二个参数为routingKey
        rabbitTemplate.convertAndSend(exchangeName, "", msg);
    }
```



### AMQP演示Direct

> 通过绑定的bindingKey来定向

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737165.png" alt="image-20240601202827801" style="zoom:67%;" />

#### 新建两个队列

direct.queue1   direct.queue2

#### 新建交换机

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737166.png" alt="image-20240601203014414" style="zoom:67%;" />

#### 交换机绑定队列与key

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737167.png" alt="image-20240601203059245" style="zoom:67%;" />

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737168.png" alt="image-20240601203155253" style="zoom:67%;" />

#### 创建消费者

```java
    @RabbitListener(queues = "direct.queue1")
    public void listenDirectQueue1(String msg) throws InterruptedException {
        System.out.println("消费者1监听direct.queue1接收到消息:"+msg);
    }
    @RabbitListener(queues = "direct.queue2")
    public void listenDirectQueue2(String msg) throws InterruptedException {
        System.err.println("消费者2监听direct.queue2接收到消息:"+msg);
    }
```



#### 发送消息

```java
    @Test
    void testSendDirect(){
        String exchangeName = "hmall.direct";
        String msg ="红色警报，大地震";
        // rabbitTemplate.convertAndSend(exchangeName, "red", msg);
        rabbitTemplate.convertAndSend(exchangeName, "blue", msg);
    }
```

### AMQP演示Topic

> TopicExchange与DirectExchange类似，区别在于routingKey可以是多个单词的列表，并且以**==.==**分隔
>
> Queue与Exchange指定BingdingKey时，可以使用通配符：#，*

 <img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737169.png" alt="image-20240601204154967" style="zoom:67%;" />

*模拟演示：*

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737170.png" alt="image-20240601204246596" style="zoom:67%;" />

#### 新建两个队列 

topic.queue1   topic.queue2

#### 新建topic交换机

hmall.topic

#### 绑定交换机

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737171.png" alt="image-20240601204538535" style="zoom:67%;" />

#### 发送消息

```java
    @Test
    void testSendTopic(){
        String exchangeName = "hmall.topic";
        String msg ="红色警报，哥斯拉";
        rabbitTemplate.convertAndSend(exchangeName, "japan.news", msg);
        rabbitTemplate.convertAndSend(exchangeName, "china.news", msg);
        rabbitTemplate.convertAndSend(exchangeName, "china.weather", msg);
    }
```

### 声明队列和交换机

#### 基于Bean声明

```java
@Configuration
public class FanoutConfig {
  	//创建fanout交换机
    @Bean
    public FanoutExchange fanoutExchange() {
        // ExchangeBuilder.fanoutExchange("hmall.fanout2").build();
        return new FanoutExchange("hmall.fanout2");
    }
		//创建queue
    @Bean
    public Queue fanoutQueue3() {
        // QueueBuilder.durable("fanout.queue3").build();
        return new Queue("fanout.queue3");
    }
  	//绑定exchange与queue
    @Bean
    public Binding fanoutBinding3(){
        return BindingBuilder.bind(fanoutQueue3()).to(fanoutExchange());// .with("bindKey")
    }
}
```

#### 基于@RabbitListner 声明

```java
    @RabbitListener(bindings = @QueueBinding(
            value=@Queue(name = "direct.queue1",durable = "true"),
            exchange = @Exchange(name = "hmall.direct",type = "direct"),
            key = {"red","blue"}
    ))
    public void listenDirectQueue1(String msg) throws InterruptedException {
        System.out.println("消费者1监听direct.queue1接收到消息:"+msg);
    }
```

### 消息转换器

#### 问题

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737172.png" alt="image-20240601211640801" style="zoom:67%;" />

```java
    @Test
    void testObject(){
        Map<String,Object> msg =  new HashMap<>();
        msg.put("name","jack");
        msg.put("age",18);
        rabbitTemplate.convertAndSend("object.queue", msg);
    }
```

现象：<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061737173.png" alt="image-20240601212753312" style="zoom:67%;" />

> Spring的对消息对象的处理由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter,基于JDK的ObjectOutputStream完成序列化
>
> 存在下列问题：
>
> - JDK的序列化有安全风险
> - JDK序列化的消息太大
> - JDK序列化的消息可读性差



#### 解决

采用Json序列化代替默认的JDK序列化

##### 引入依赖

==注意==：springMvc项目自带jackson处理器，不用再次引入依赖

在父工程中引入jackson依赖

```xml
<!--jackson-->
<dependency>
  <groupId>com.fasterxml.jackson.dataformat</groupId>
  <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
```

##### 配置bean

在publisher与consumer启动项中配置bean

```java
   @Bean
    public MessageConverter jacksonMessageConverter(){
        return new Jackson2JsonMessageConverter();
    }
```

