# 数据类型

## 1.数值类型

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061735092.png" alt="image-20240509152113472" style="zoom:67%;" />

## 2.日期和时间类型

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061735093.png" alt="image-20240509152131336" style="zoom:67%;" />

## 3.字符串类型

<img src="https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061735094.png" alt="image-20240509152144047" style="zoom:67%;" />



# SQL

## DDL操作

### DDL-数据库操作

查询所有数据库`show databases;`

使用数据库 `use xxx;`

查看当前数据库`select database();`

创建 `create database xxx;`

```sql
create database itcase 
  character set utf8mb4
  collate utf8mb4_unicode_cli;
```

删除 `drop database xxx;`



### DDL-表操作

查询数据库==所有==表 `show tables;`

表创建 

```sql
create table user (
  id int primary key auto_increment comment 'id',
  username varchar(30) comment '用户名',
  password varchar(30) comment '密码'
)comment '用户表';
```

查询表结构 `desc xxx;`

查询指定表的建表语句 `show create table xxx;`

新增表字段 `alter table 表名 add column nickname varchar(20);`

修改数据类型 `alter table 表名 modify 字段名 数据类型;`

修改字段名和数据类型`alter table 表名 modify 旧字段名 新字段名 数据类型;`

删除字段 `alter table 表名 drop 字段名;`

修改表名 `alter table 表名 rename to 新表名;`

删除表 `drop table 表名;`

删除表并重新创建该表(保留表结构) `truncate table 表名;`



## DML操作

插入数据：

-指定字段

`insert into 表名(id,name,...) values(default,"zyr",...);`

-不指定字段

`insert into 表名 values(default,"zyr",...),(default,"sef",...),(default,"sef",...);`

修改数据

 `update 表名 set 字段名1=值,字段名2=值 where 条件;`

删除 

`delete from 表名 where 条件`



## DQL操作

查询 `select 字段名，字段名...from 表名`

别名 as 可省略 ,distinct 去重`select distinct name as '姓名' from 表名`

条件查询 `selct * from 表名 where 条件`

### 1.条件查询

```sql
select * from employee where age = 88;
select * from employee where age < 20;
select * from employee where age <=20;
-- 身份证为null
select * from employee where idcart is NUll;
select * from employee where idcart is not NUll;
-- 不等于 '!=' 或者 '<>'
select * from emplouee where age != 88;
-- 年龄15到20（包括）'&&'='and'
select * from employee where age>=15 and age<=20;
select * from employee where age between 15 and 20;
-- 且
select * from employee where gender = '女' and age = 20;
-- 或
select * from employee where age = 18 or age = 20 or age = 30;
select * from employye where age in(18,20,30);
-- 模糊('_'匹配单个字符，'%'匹配任意个字符)
select * from employee where name like '张__';
select * from employee where idcard like '%666';

```

### 2.聚合函数

统计数量 `select count(*) from employee;`  ==不忽略null==

​	      `select count(age) from employee;` ==忽略null==

求平均值 `select avg(age) from employee;`

最大值 `selet max(age) from employee;`

最小值 `select min(age) from employee;`

求和 `select sum(age) from employee where address='江苏'`

### 3.分组查询

`select 字段名 from 表名|where 条件| group by 分组字段名 |having 分组后过滤条件|`

> 执行时间：where分组之前进行过滤,having分组后过滤
>
> 判断条件：where不能对聚合函数进行判断，having可以

```sql
-- 根据性别分组，统计男女员工数量
select gender,count(*) from employee group by gender;
-- 分组计算男女平均年龄
select gender,AVG(age) from employee GROUP BY gender;
-- 年龄小于45，根据工作地分组，获取员工数量大于等于3的工作地
select workaddress,count(*) "工作地人数" from employee group by workaddress having count(*)>=3
```



### 4.排序查询

`select 字段 from 表名 order by 字段1 排序方式,字段2 排序方式;`

> ASC:升序（默认）
>
> DESC：降序

```sql
-- 年龄降序
select * from employee ORDER BY age DESC;
-- 年龄升序，如果年龄相同，入职降序
select * from employee order by age,entrydate desc;
```



### 5.分页查询

`select 字段 from 表名 limit 起始索引,查询记录数;`

> 起始索引从0开始，起始索引=（查询页码-1）*每页显示记录数
>
> 如果查询的是第一页，起始索引可以省略 如 limit 10;

```sql
-- 查询第一页,10条
select * from employee LIMIT 0,10;
select * from employee limit 10;
-- 查询第二页，10条
select * from employee limit 10,10;
```



### 案例

```sql
-- 女且年龄21,22,23
select * from employee where gender='F' and age in(21,22,23);

-- 性别男，年龄20-40 ，姓名三个字("()"看起来更清晰)
select * from employee where gender='M' and (age between 20 and 40) and name like '___';

-- 年龄小于60的男女员工数量
select gender,count(*) from employee where age<60 group by gender;

-- 年龄小于等于35的员工姓名和年龄，对结果按年龄升序，入职降序
select name,age from employee where age<=35 order by age,entrydate desc;

-- 性别男，年龄20-40的5个员工，结果年龄升序，入职升序(先排序后limit)
select * from employee where gender='M' and (age between 20 and 40) ORDER BY age,entrydate limit 5;
```



### DQL执行顺序

==编写顺序==

```sql
SELECT
	字段名
FROM 
	表名
WHERE
	条件列表
GROUP BY 
	分组字段列表
HAVING
	分组后条件列表
ORDER BY 
	排序字段列表
LIMIT
	分页参数
```

==执行顺序==

```sql
FROM 
	表名
WHERE
	条件列表
GROUP BY 
	分组字段列表
HAVING
	分组后条件列表
SELECT
	字段名
ORDER BY 
	排序字段列表
LIMIT
	分页参数
```

```sql
-- 先 from , where 之后 select
select e.name,e.age from employee e where e.age>15 order by age asc;
```



## DCL操作

### 用户管理

查询用户

`use mysql;
select User from user;`

创建用户

`create user '用户名'@'主机名' identified by '密码';`

```sql
-- 本机可访问
create user 'itcase'@'localhost' identified by '123456';
-- 任意主机可访问
create user 'itcase'@'%' identified by '123456';
```

修改用户密码

`alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';`

删除用户

`drop user '用户名'@'主机名';`

### 权限控制

查询权限列表

`show grants for '用户名'@'主机名';`

授予权限

`grant 权限列表 on 数据库名.表名 to '用户名‘@’主机名';`

撤销权限

`revoke 权限列表 on 数据库名.表名 from '用户名‘@’主机名';`



# 函数

## 1.字符串函数



| 函数                     | 功能                           |
| ------------------------ | ------------------------------ |
| concat(s1,s2,...)        | 拼接字符串                     |
| lower(str)               | 字符串全小写                   |
| upper(str)               | 大写                           |
| lpad(str,n,pad)          | 左填充,总长度n用pad添加在str前 |
| rpad(str,n,pad)          | 右填充                         |
| trim(str)                | 去除两侧空格                   |
| substring(str,start,len) | str从start起的n个字符串        |

==练习==

```sql
-- 员工工号不足5为补0，比如 1号员工:00001
update employee set workno=LPAD(workno,5,'0');
```

## 2.数值函数



| 函数       | 功能                     |
| ---------- | ------------------------ |
| ceil(x)    | 向上取整                 |
| floor(x)   | 向下取整                 |
| mod(x,y)   | 返回x/y取余              |
| rand()     | 返回0-1随机数            |
| round(x,y) | 参数x四舍五入，留y位小数 |

==练习==

```sql
-- 随机生成六位数验证码,不保留小数，不足六位，左侧补0
SELECT LPAD(ROUND(RAND()*1000000,0),6,0) ;
```

## 3.日期函数

| 函数                              | 功能                                              |
| --------------------------------- | ------------------------------------------------- |
| curdate()                         | 当前日期                                          |
| curtime()                         | 当前时间                                          |
| now()                             | 当前日期和时间                                    |
| year(date)                        | 获取指定date的年份                                |
| month(date)                       | 获取指定date的月份                                |
| day(date)                         | 获取指定date的日期                                |
| date_add(date,interval expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |
| datediff(date1,date2)             | 返回起始date1减去结束date2之间的天数              |

==练习==

```sql
-- 当前日期向后推70天
SELECT DATE_ADD(now(),INTERVAL 70 DAY);
-- 查询所有员工的入职天数,倒序排序
SELECT NAME,DATEDIFF( CURDATE(), entrydate ) AS 'entrydays' FROM employee ORDER BY entrydays DESC;
```

## 4.流程函数



| 函数                                                      | 功能                                      |
| --------------------------------------------------------- | ----------------------------------------- |
| if(value,t,f)                                             | 如果value为true，则t，否则f               |
| ifnull(value1,value2)                                     | 如果value不为空则返回vallue1,否则value2   |
| case when [val1] then [res1]...else [default] end         | 如果val1为true,返回res1,...否则default    |
| case [expr] when [val1] then [res1] ...else [default] end | 如果expr等于val1，返回res1,...否则default |

==练习==

```sql
-- 查询员工姓名和工作地址（北京、上海--->一线城市,其他--->二线城市）
SELECT name,
CASE address
	WHEN '北京' THEN
		'一线城市'
		WHEN '上海' THEN
		'一线城市'
	ELSE
		'二线城市'
END AS '工作城市' FROM employee;

-- 统计班级各个学员的成绩，展示规则: >=85,展示优秀, >=60,展示及格, 否则展示不及格
SELECT
	id,
	NAME,
	( CASE WHEN math >= 85 THEN '优秀' WHEN math >= 60 THEN '及格' ELSE '不及格' END ) AS '数学' ,
	( CASE WHEN english >= 85 THEN '优秀' WHEN english >= 60 THEN '及格' ELSE '不及格' END ) AS '英语' ,
	( CASE WHEN chinese >= 85 THEN '优秀' WHEN chinese >= 60 THEN '及格' ELSE '不及格' END ) AS '语文' 
FROM
	score;
```



# 约束

> 约束作用于表中字段上，用于限制存储字表中的数据
>
> 保证数据库中数据的正确，有效性和完整性

## 分类

| 约束     | 描述                                 | 关键字      |
| -------- | ------------------------------------ | ----------- |
| 非空约束 | 字段不能为null                       | NOT NULL    |
| 唯一约束 | 该字段的所有数据唯一，不重复         | UNIQUE      |
| 主键约束 | 唯一标识，非空且唯一                 | PRIMARY KEY |
| 默认约束 | 保存时，未指定则采取默认             | DEFAULT     |
| 检查约束 | 保证字段满足某一条件                 | CHECK       |
| 外键约束 | 两张表数据之间连接，数据一致性完整性 | FOREIGN KEY |

==练习== 

```sql
CREATE TABLE user(
 	id int primary key auto_increment comment '主键',
  name varchar(10) not null unique comment '姓名唯一',
  age int check(age>0 and age<=120) comment '年龄限制',
  status char(1) default '1' comment '默认状态1',
  gender char(1) comment '性别'
) COMMENT '用户表';
```

## 外键约束

建表时添加外键

```sql
create table 表名(
...
  [constraint] [外键表名] foreign key [外键字段名] reference 主表 [主表列名]
);
```

后期添加外键(将employee表中的dept_id字段与dept中的id字段产生外键关联)

`alter table employee add constraint foreign key (dept_id) references dept(id);`

删除外键

`alter table employee drop foreign key dept_id;`



## 删除、更新行为

| 行为        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| NO_ACTION   | 变更父表，先检查该记录是否有对应外键，有则不允许删除、更新。[与RESTRICT一致] |
| RESTRICT    | 变更父表，先检查该记录是否有对应外键，有则不允许删除、更新。[与NO_ACTION一致] |
| CASCADE     | 变更父表，先检查该记录是否有对应外键，有，则也更新外键在子表中的记录 |
| SET NULL    | 删除父表记录，先检查是否有对应外键，有则设子表外键null（要求该外键允许null） |
| SET DETAULT | 父表变更时，子表将外键设置成一个默认值（lnnodb不支持）       |

更新时一起变更，删除时，设置为null

`alter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名（主表字段名）on update cascade on delete set null;`



# 多表查询

## 多表关系

==一对多==

案例：一个部门，多个员工

实现：在多的一方建立外键，指向一的一方的主键

==多对多==

案例：学生与课程

实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键

==一对一==

案例：用户与用户详情

关系：用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升效率

实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一`UNIQUE`



## 多表查询

笛卡尔积,A表和B表所有组合

`SELECT workno,name,dept.dept_name FROM employee,dept ;`

![image-20240510144606823](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061735095.png)

消除无效笛卡尔积

`SELECT workno,name,dept.dept_name FROM employee,dept WHERE employee.dept_id = dept.id;`

![image-20240510144542123](https://gitee.com/yurun-zhang/typora-tu-chuang/raw/master/202406061735096.png)

### 分类

内连接：相当于查询A，B交集部分数据

外连接：

​	左外连接：查询`左表`所有数据，以及两表交集部分数据

​	右外连接：查询`右表`所有数据，以及两表交集部分数据

自连接：当前表与自身的连接查询，自连接必须使用表`别名`

### 内连接

> 查询两表交集部分，没有形成关联的数据查询不出来

隐式内连接：`select 字段列表 from 表1，表2 where 条件...;`

```sql
-- From起别名后不得再通过原表名限定字段
SELECT
	e.NAME,
	d.dept_name 
FROM
	employee AS e,
	dept AS d 
WHERE
	e.dept_id = d.id;
```

显式内连接：`select 字段列表 from 表1 [inner] join 表2 on 条件...;`

```sql
SELECT
	e.NAME,
	d.dept_name 
FROM
	employee AS e
	JOIN dept AS d ON e.dept_id = d.id;
```



### 外连接

左外连接：

`SELECT 字段列表 FROM 表1 LEFT [outer] JOIN 表2 ON 条件...;`

相当于查询表1（左表）所有以及交集部分数据

```sql
-- 查询employee表所有，dept表部门名称
SELECT
	e.*,
	d.dept_name 
FROM
	employee AS e
	LEFT JOIN dept AS d ON e.dept_id = d.id;
```

右外连接：

`SELECT 字段列表 FROM 表1 RIGHT [outer] JOIN 表2 ON 条件...; `

相当于查询表2（右表）所有以及交集部分数据

```sql
-- 查询dept表所有，和对应员工信息
SELECT
	d.*,
	e.* 
FROM
	employee AS e
	RIGHT JOIN dept AS d ON e.dept_id = d.id;
```



### 自连接

`SELECT 字段列表  FROM 表A 别名A JOIN 表B 别名B 条件...；`

自连接查询，可以使内连接，也可是外连接

```sql
-- 查询 员工 及其所属 领导的名字 id,name,manager_id
SELECT 
	a.name,
  b.name
FROM 
	employee as a 
	JOIN employee as b
WHERE a.manager_id = b.id;
```

```sql
-- 查询 所有employee表 员工 及其领导名字，如果没有领导也要查询出来
SELECT 
	a.name,
	b.name
FROM employee as a
	LEFT JOIN employee as b
ON a,manager_id = b.id;
```



### 联合查询

对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果表

> 保留ALL，相当于两次结果拼接，去除ALL，相当于去重
>
> 多张表的列数，字段类型必须相同

```sql
SELECT 字段列表 FROM 表A...
UNION [ALL]
SELECT 字段列表 FROM 表B...
```

案例:

```sql
-- 薪资低于 5000 的员工，和 年龄 大于 50 的员工全部查询出来
SELECT * FROM employee WHERE salary < 5000
UNION 
SELECT * FROM employee WHERE age > 50;
```



### 子查询

SQL语句中嵌套SELECT语句，称为==嵌套查询==，又称==子查询==

`SELECT * FROM t1 WHERE colum1=(SELECT column1 FROM t2);`

> 子查询外部的语句可以是ISNERT,UPDATE,DELETE,SELECT的任何一个

#### 标量子查询

子查询结果为单个值

```sql
-- 查询销售部所有员工信息
SELECT * FROM employee 
WHERE employee.dept_id =( SELECT id FROM dept WHERE dept_name = '销售部' );
```

```sql
-- 查询在“秦晓明”后的入职员工信息
SELECT * FROM employee 
WHERE entrydate >( SELECT entrydate FROM employee WHERE NAME = '秦晓明' );
```

#### 列子查询

> 常用操作符： IN, NOT IN,ANY,SOME,ALL

子查询结果为一列

```sql
-- 查询“销售部”和“市场部”的员工信息
SELECT
	* 
FROM
	employee 
WHERE
	dept_id IN (
	SELECT
		id 
	FROM
		dept 
WHERE
	dept_name IN ( "销售部", "市场部" ));
```

```sql
-- 查询 比“财务部”所有人工资都高的员工信息
SELECT
	* 
FROM
	employee 
WHERE
	salary > ALL (
	SELECT
		salary 
	FROM
		employee 
WHERE
	dept_id = ( SELECT id FROM dept WHERE dept_name = "财务部" ));
```

```sql
-- 查询比研发部其中任意一人工资高的员工信息（any和some作用相同）
SELECT
	* 
FROM
	employee 
WHERE
	salary > ANY (
	SELECT
		salary 
	FROM
		employee 
WHERE
	dept_id = ( SELECT id FROM dept WHERE dept_name = "研发部" ));
```

#### 行子查询

子查询结果为一行

```sql
-- 查询与“张无忌”薪资与直属领导相同的员工信息
SELECT 
	* 
FROM 
	employee
WHERE 
	(salary,manager_id)
	=(SELECT salary,manager_id FROM employee WHERE name = "张无忌")
```

#### 表子查询

子查询结果为多行多列

```sql
-- 查询与“张无忌”，“宋远桥”职位和薪资相同的员工信息
SELECT 
	*
FROM 
	employee
WHERE （job,salary) in
(
SELECT 
	job,salary 
FROM 
 	employee
WHERE 
	name IN(“张无忌”，“宋远桥”)
)
```

```sql
-- 查询入职日期 “2006-01-01”之后的员工信息，及其部门信息
SELECT
	e.*,
	dept_name 
FROM
	( SELECT * FROM employee WHERE entrydate > "2006-01-01" ) AS e
	LEFT JOIN dept ON e.dept_id = dept.id;
```



### 案例

```sql
-- 查询研发部所有员工信息和对应工资等级
SELECT
	e.*,
	s.grade 
FROM
	employee e,
	dept d,
	salaryed s 
WHERE
	e.dept_id = d.id 
	AND ( e.salary BETWEEN s.low AND s.high ) 
	AND d.dept_name = "研发部";
```

```sql
-- 查询研发部所有员工平均薪资
SELECT
	avg( salary ) 
FROM
	employee e,
	dept d 
WHERE
	e.dept_id = d.id 
	AND d.dept_name = "研发部";
```

```sql
-- 查询各部门平均薪资并按部门名分组
SELECT
	d.dept_name,
	avg( e.salary )
FROM
	employee e,
	dept d 
WHERE
	e.dept_id = d.id 
GROUP BY
	d.dept_name;
```

```sql
-- 查询所有部门信息，并统计员工人数
SELECT 
	d.dept_name,
	( SELECT count(*) FROM employee e WHERE e.dept_id = d.id ) AS "人数" 
FROM
	dept d;
```

# 事务

## 概念

> 事务：一组操作的集合，它是一个不可分割的单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么==同时成功==，要么==同时失败==

-- 转账操作

```sql
-- 方式一
SELECT @@autocommit;
-- 关闭自动提交，设置为手动commit
set @@autocommit=0;
update user set money = money-1000 where name ="张三";
在sql中这句话是异常
UPDATE user set money = money+1000 WHERE name = "李四";

-- 手动提交事务
commit;

-- 出现异常后，不提交而是回滚事务
rollback;
```

```sql
-- 方式二
-- 开启事务
start transaction;

update user set money = money-1000 where name ="张三";
在sql中这句话是异常
UPDATE user set money = money+1000 WHERE name = "李四";

-- 提交事务
commit;

-- 回滚事务
rollback;

```



##四大特性





| 特性   | 说明                                                   |
| ------ | ------------------------------------------------------ |
| 原子性 | 事务是不可分割的最小操作单位，同成功，通失败           |
| 一致性 | 事务完成时，必须使所有的数据保持一致状态               |
| 隔离性 | 隔离机制，保证事务在不受外部并发操作影响的独立环境运行 |
| 持久性 | 事务一旦提交完成回滚，它对数据库中的数据改变是永久的   |



## 并发事务问题

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另一个事务还没提交的数据                         |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取结果不同               |
| 幻读       | 一个事务按条件查询数据时，没有对应的数据行，但在插入时，又发现该数据已经存在 |

## 隔离级别

| 隔离级别              | 脏读 | 不可重复度 | 幻读 |
| --------------------- | :--: | :--------: | :--: |
| Read uncommitted      |  √   |     √      |  √   |
| Read committed        |  ×   |     √      |  √   |
| Repeatable Read(默认) |  ×   |     ×      |  √   |
| Serializable          |  ×   |     ×      |  ×   |



