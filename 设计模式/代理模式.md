## JDK代理与CGLIB对比

> JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才生成代理对象。
>
> CGLIB动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。
>
> JDK Proxy的优势：
>
> 最小化依赖关系、代码实现简单、简化开发和维护、JDK原生支持，比CGLIB更加可靠，随JDK版本平滑升级。而字节码类库通常需要进行更新以保证在新版Java上能够使用。
>
> 基于CGLIB的优势：
>
> 无需实现接口，达到代理类无侵入，只操作关心的类，而不必为其他相关类增加工作量。高性能。

## JDK动态代理

> 特点：jdk动态代理，必须有接口，目标类必须实现接口， 没有接口时，需要使用cglib动态代理

抽象主题接口

```java
public interface UserService {
    void select();
    void update();
}
```

具体主题类

```java
public class UserServiceImpl implements UserService{
    @Override
    public void select() {
        System.out.println("查询了用户");
    }

    @Override
    public void update() {
        System.out.println("更新了用户");
    }
}
```

代理类(增强)

```java
public class ProxyUtil {
    public static UserService createProxy(UserService userService){
        //参数1：一般为本类类加载器，也可用主题类对象加载器
        //参数2：代理类接口
        //参数3：执行invoke处理
        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(
          			ProxyUtil.class.getClassLoader(),
                new Class[]{UserService.class},
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("开始时间:"+new Date());
                       	//反射，执行具体主题对象userService的方法method，参数为args
                        Object rs = method.invoke(userService, args);
                        System.out.println("结束时间:"+new Date());
                        return rs;
                    }
                });
       //返回代理类
        return userServiceProxy;
    }
}
```

（简化）

```java
public class ProxyUtil {
    public static UserService createProxy(UserService userService){
        return (UserService)Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(),
                new Class[]{UserService.class},
                (proxy, method, args) -> {
                    System.out.println("开始时间:"+new Date());
                    Object rs = method.invoke(userService, args);
                    System.out.println("结束时间:"+new Date());
                    return rs;
                });
    }
}
```

转化成通用泛型：

```java
public class ProxyUtil {

    /**
     * 创建代理对象，泛型方法，适用于任何实现了T接口的对象
     *
     * @param target 实现了特定接口的目标对象
     * @param <T>    代表接口类型
     * @return 代理对象
     */
    public static <T> T createProxy(T target) {
        return (T) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
           		 //获取主题对象的所有接口
                target.getClass().getInterfaces(),
                (proxy, method, args) -> {
                    System.out.println("开始时间:" + new Date());
                    Object result = method.invoke(target, args);
                    System.out.println("结束时间:" + new Date());
                    return result;
                });
    }
}
```

测试

```java
public class Test {
    public static void main(String[] args) {
        UserService userService = new UserServiceImpl();
        UserService proxy = ProxyUtil.createProxy(userService);
        proxy.select();
        proxy.update();
    }
}
```

## CGLIB代理

> 代理过程：
>
> - 查找目标类上的所有非final的public类型的方法定义；
> - 将符合条件的方法定义转换成字节码；
> - 将组成的字节码转换成相应的代理的class对象；
> - 实现MethodInterceptor接口，用来处理对代理类上所有方法的请求。

引入Cglib依赖

```xml
        <!-- https://mvnrepository.com/artifact/cglib/cglib -->
        <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.3.0</version>
        </dependency>
```

主题类

```java
public class UserDao {
    public void findAllUser() {
        System.out.println("UserDao 查询所有用户");
    }

    public void findUserById(int id) {
        System.out.println("UserDao 根据id:" + id + "查询用户");
    }
}
```

方法拦截

```java
public class LoginInterceptor implements MethodInterceptor {
    // 参数1： obj 表示要增强的对象
    // 参数2： method 表示被拦截的方法
    // 参数3： objects 表示被拦截方法的参数
    // 参数4： methodProxy 表示被拦截方法的代理对象
    @Override
    public Object intercept(Object obj, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("调用方法" + method.getName() + "之【前】的日志处理");
        // 执行原始类方法
        Object rs = methodProxy.invokeSuper(obj, objects);
        System.out.println("调用方法" + method.getName() + "之【后】的日志处理");
        return rs;
    }
}
```

测试

```java
public class CglibTest {
    public static void main(String[] args) {
        // 创建Enhancer对象,类似于JDK代理的Proxy类
        Enhancer enhancer = new Enhancer();
        // 设置目标类的字节码文件
        enhancer.setSuperclass(UserDao.class);
        // 设置回调函数
        enhancer.setCallback(new LoginInterceptor());
        // create方法用于创建代理对象
        UserDao userDao = (UserDao) enhancer.create();
        userDao.findAllUser();
        userDao.findUserById(1);
    }
}
```

